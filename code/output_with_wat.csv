fn_name,parameters,description,return_statement,c_implementation,corresponding_wat_implementation
arraylist_free,ArrayList *arraylist,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void arraylist_free(ArrayList *arraylist)
{
	/* Do not free if a NULL pointer is passed */
	if (arraylist != NULL) {
		free(arraylist->data);
		free(arraylist);
	}
}","(func $arraylist_free (type 2) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.ne
    local.set 6
    i32.const 1
    local.set 7
    local.get 6
    local.get 7
    i32.and
    local.set 8
    block  ;; label = @1
      local.get 8
      i32.eqz
      br_if 0 (;@1;)
      local.get 3
      i32.load offset=12
      local.set 9
      local.get 9
      i32.load
      local.set 10
      local.get 10
      call $free
      local.get 3
      i32.load offset=12
      local.set 11
      local.get 11
      call $free
    end
    i32.const 16
    local.set 12
    local.get 3
    local.get 12
    i32.add
    local.set 13
    local.get 13
    global.set $__stack_pointer
    return)"
arraylist_enlarge,ArrayList *arraylist,"Resizes or reallocates an internal buffer to a new size.
Updates allocation metadata and returns an indication of success or failure.",0 | 1,"
static int arraylist_enlarge(ArrayList *arraylist)
{
	ArrayListValue *data;
	unsigned int newsize;

	/* Double the allocated size */
	newsize = arraylist->_alloced * 2;

	/* Reallocate the array to the new size */
	data = realloc(arraylist->data, sizeof(ArrayListValue) * newsize);

	if (data == NULL) {
		return 0;
	} else {
		arraylist->data = data;
		arraylist->_alloced = newsize;

		return 1;
	}
}","(func $arraylist_enlarge (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 4
    local.get 4
    i32.load offset=8
    local.set 5
    i32.const 1
    local.set 6
    local.get 5
    local.get 6
    i32.shl
    local.set 7
    local.get 3
    local.get 7
    i32.store
    local.get 3
    i32.load offset=8
    local.set 8
    local.get 8
    i32.load
    local.set 9
    local.get 3
    i32.load
    local.set 10
    i32.const 2
    local.set 11
    local.get 10
    local.get 11
    i32.shl
    local.set 12
    local.get 9
    local.get 12
    call $realloc
    local.set 13
    local.get 3
    local.get 13
    i32.store offset=4
    local.get 3
    i32.load offset=4
    local.set 14
    i32.const 0
    local.set 15
    local.get 14
    local.get 15
    i32.eq
    local.set 16
    i32.const 1
    local.set 17
    local.get 16
    local.get 17
    i32.and
    local.set 18
    block  ;; label = @1
      block  ;; label = @2
        local.get 18
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 19
        local.get 3
        local.get 19
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=4
      local.set 20
      local.get 3
      i32.load offset=8
      local.set 21
      local.get 21
      local.get 20
      i32.store
      local.get 3
      i32.load
      local.set 22
      local.get 3
      i32.load offset=8
      local.set 23
      local.get 23
      local.get 22
      i32.store offset=8
      i32.const 1
      local.set 24
      local.get 3
      local.get 24
      i32.store offset=12
    end
    local.get 3
    i32.load offset=12
    local.set 25
    i32.const 16
    local.set 26
    local.get 3
    local.get 26
    i32.add
    local.set 27
    local.get 27
    global.set $__stack_pointer
    local.get 25
    return)"
arraylist_insert,"ArrayList *arraylist, unsigned int index, ArrayListValue data","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | 1,"
int arraylist_insert(ArrayList *arraylist, unsigned int index,
                     ArrayListValue data)
{
	/* Sanity check the index */
	if (index > arraylist->length) {
		return 0;
	}

	/* Increase the size if necessary */
	if (arraylist->length + 1 > arraylist->_alloced) {
		if (!arraylist_enlarge(arraylist)) {
			return 0;
		}
	}

	/* Move the contents of the array forward from the index
	 * onwards */
	memmove(&arraylist->data[index + 1], &arraylist->data[index],
	        (arraylist->length - index) * sizeof(ArrayListValue));

	/* Insert the new entry at the index */
	arraylist->data[index] = data;
	++arraylist->length;

	return 1;
}","(func $arraylist_insert (type 4) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=8
    local.get 5
    local.get 1
    i32.store offset=4
    local.get 5
    local.get 2
    i32.store
    local.get 5
    i32.load offset=4
    local.set 6
    local.get 5
    i32.load offset=8
    local.set 7
    local.get 7
    i32.load offset=4
    local.set 8
    local.get 6
    local.get 8
    i32.gt_u
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 12
        local.get 5
        local.get 12
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=8
      local.set 13
      local.get 13
      i32.load offset=4
      local.set 14
      i32.const 1
      local.set 15
      local.get 14
      local.get 15
      i32.add
      local.set 16
      local.get 5
      i32.load offset=8
      local.set 17
      local.get 17
      i32.load offset=8
      local.set 18
      local.get 16
      local.get 18
      i32.gt_u
      local.set 19
      i32.const 1
      local.set 20
      local.get 19
      local.get 20
      i32.and
      local.set 21
      block  ;; label = @2
        local.get 21
        i32.eqz
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=8
        local.set 22
        local.get 22
        call $arraylist_enlarge
        local.set 23
        block  ;; label = @3
          local.get 23
          br_if 0 (;@3;)
          i32.const 0
          local.set 24
          local.get 5
          local.get 24
          i32.store offset=12
          br 2 (;@1;)
        end
      end
      local.get 5
      i32.load offset=8
      local.set 25
      local.get 25
      i32.load
      local.set 26
      local.get 5
      i32.load offset=4
      local.set 27
      i32.const 1
      local.set 28
      local.get 27
      local.get 28
      i32.add
      local.set 29
      i32.const 2
      local.set 30
      local.get 29
      local.get 30
      i32.shl
      local.set 31
      local.get 26
      local.get 31
      i32.add
      local.set 32
      local.get 5
      i32.load offset=8
      local.set 33
      local.get 33
      i32.load
      local.set 34
      local.get 5
      i32.load offset=4
      local.set 35
      i32.const 2
      local.set 36
      local.get 35
      local.get 36
      i32.shl
      local.set 37
      local.get 34
      local.get 37
      i32.add
      local.set 38
      local.get 5
      i32.load offset=8
      local.set 39
      local.get 39
      i32.load offset=4
      local.set 40
      local.get 5
      i32.load offset=4
      local.set 41
      local.get 40
      local.get 41
      i32.sub
      local.set 42
      i32.const 2
      local.set 43
      local.get 42
      local.get 43
      i32.shl
      local.set 44
      local.get 44
      i32.eqz
      local.set 45
      block  ;; label = @2
        local.get 45
        br_if 0 (;@2;)
        local.get 32
        local.get 38
        local.get 44
        memory.copy
      end
      local.get 5
      i32.load
      local.set 46
      local.get 5
      i32.load offset=8
      local.set 47
      local.get 47
      i32.load
      local.set 48
      local.get 5
      i32.load offset=4
      local.set 49
      i32.const 2
      local.set 50
      local.get 49
      local.get 50
      i32.shl
      local.set 51
      local.get 48
      local.get 51
      i32.add
      local.set 52
      local.get 52
      local.get 46
      i32.store
      local.get 5
      i32.load offset=8
      local.set 53
      local.get 53
      i32.load offset=4
      local.set 54
      i32.const 1
      local.set 55
      local.get 54
      local.get 55
      i32.add
      local.set 56
      local.get 53
      local.get 56
      i32.store offset=4
      i32.const 1
      local.set 57
      local.get 5
      local.get 57
      i32.store offset=12
    end
    local.get 5
    i32.load offset=12
    local.set 58
    i32.const 16
    local.set 59
    local.get 5
    local.get 59
    i32.add
    local.set 60
    local.get 60
    global.set $__stack_pointer
    local.get 58
    return)"
arraylist_append,"ArrayList *arraylist, ArrayListValue data","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.","arraylist_insert(arraylist, arraylist->length, data)","
int arraylist_append(ArrayList *arraylist, ArrayListValue data)
{
	return arraylist_insert(arraylist, arraylist->length, data);
}","(func $arraylist_append (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=12
    local.set 6
    local.get 6
    i32.load offset=4
    local.set 7
    local.get 4
    i32.load offset=8
    local.set 8
    local.get 5
    local.get 7
    local.get 8
    call $arraylist_insert
    local.set 9
    i32.const 16
    local.set 10
    local.get 4
    local.get 10
    i32.add
    local.set 11
    local.get 11
    global.set $__stack_pointer
    local.get 9
    return)"
arraylist_prepend,"ArrayList *arraylist, ArrayListValue data","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.","arraylist_insert(arraylist, 0, data)","
int arraylist_prepend(ArrayList *arraylist, ArrayListValue data)
{
	return arraylist_insert(arraylist, 0, data);
}","(func $arraylist_prepend (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    i32.const 0
    local.set 7
    local.get 5
    local.get 7
    local.get 6
    call $arraylist_insert
    local.set 8
    i32.const 16
    local.set 9
    local.get 4
    local.get 9
    i32.add
    local.set 10
    local.get 10
    global.set $__stack_pointer
    local.get 8
    return)"
arraylist_remove_range,"ArrayList *arraylist, unsigned int index, unsigned int length","Removes a range of elements from a collection and updates its size.
Moves remaining elements to close the gap and adjusts counters.",null,"
void arraylist_remove_range(ArrayList *arraylist, unsigned int index,
                            unsigned int length)
{
	/* Check this is a valid range */
	if (index > arraylist->length || index + length > arraylist->length) {
		return;
	}

	/* Move back the entries following the range to be removed */
	memmove(&arraylist->data[index], &arraylist->data[index + length],
	        (arraylist->length - (index + length)) *
	            sizeof(ArrayListValue));

	/* Decrease the counter */
	arraylist->length -= length;
}","(func $arraylist_remove_range (type 5) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    local.get 0
    i32.store offset=12
    local.get 5
    local.get 1
    i32.store offset=8
    local.get 5
    local.get 2
    i32.store offset=4
    local.get 5
    i32.load offset=8
    local.set 6
    local.get 5
    i32.load offset=12
    local.set 7
    local.get 7
    i32.load offset=4
    local.set 8
    local.get 6
    local.get 8
    i32.gt_u
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 11
          br_if 0 (;@3;)
          local.get 5
          i32.load offset=8
          local.set 12
          local.get 5
          i32.load offset=4
          local.set 13
          local.get 12
          local.get 13
          i32.add
          local.set 14
          local.get 5
          i32.load offset=12
          local.set 15
          local.get 15
          i32.load offset=4
          local.set 16
          local.get 14
          local.get 16
          i32.gt_u
          local.set 17
          i32.const 1
          local.set 18
          local.get 17
          local.get 18
          i32.and
          local.set 19
          local.get 19
          i32.eqz
          br_if 1 (;@2;)
        end
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=12
      local.set 20
      local.get 20
      i32.load
      local.set 21
      local.get 5
      i32.load offset=8
      local.set 22
      i32.const 2
      local.set 23
      local.get 22
      local.get 23
      i32.shl
      local.set 24
      local.get 21
      local.get 24
      i32.add
      local.set 25
      local.get 5
      i32.load offset=12
      local.set 26
      local.get 26
      i32.load
      local.set 27
      local.get 5
      i32.load offset=8
      local.set 28
      local.get 5
      i32.load offset=4
      local.set 29
      local.get 28
      local.get 29
      i32.add
      local.set 30
      i32.const 2
      local.set 31
      local.get 30
      local.get 31
      i32.shl
      local.set 32
      local.get 27
      local.get 32
      i32.add
      local.set 33
      local.get 5
      i32.load offset=12
      local.set 34
      local.get 34
      i32.load offset=4
      local.set 35
      local.get 5
      i32.load offset=8
      local.set 36
      local.get 5
      i32.load offset=4
      local.set 37
      local.get 36
      local.get 37
      i32.add
      local.set 38
      local.get 35
      local.get 38
      i32.sub
      local.set 39
      i32.const 2
      local.set 40
      local.get 39
      local.get 40
      i32.shl
      local.set 41
      local.get 41
      i32.eqz
      local.set 42
      block  ;; label = @2
        local.get 42
        br_if 0 (;@2;)
        local.get 25
        local.get 33
        local.get 41
        memory.copy
      end
      local.get 5
      i32.load offset=4
      local.set 43
      local.get 5
      i32.load offset=12
      local.set 44
      local.get 44
      i32.load offset=4
      local.set 45
      local.get 45
      local.get 43
      i32.sub
      local.set 46
      local.get 44
      local.get 46
      i32.store offset=4
    end
    return)"
arraylist_remove,"ArrayList *arraylist, unsigned int index",Decrease the counter,null,"
void arraylist_remove(ArrayList *arraylist, unsigned int index)
{
	arraylist_remove_range(arraylist, index, 1);
}","(func $arraylist_remove (type 6) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    i32.const 1
    local.set 7
    local.get 5
    local.get 6
    local.get 7
    call $arraylist_remove_range
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    return)"
arraylist_index_of,"ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data","Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",(int) i | -1,"
int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback,
                       ArrayListValue data)
{
	unsigned int i;

	for (i = 0; i < arraylist->length; ++i) {
		if (callback(arraylist->data[i], data) != 0) {
			return (int) i;
		}
	}

	return -1;
}","(func $arraylist_index_of (type 4) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 32
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=24
    local.get 5
    local.get 1
    i32.store offset=20
    local.get 5
    local.get 2
    i32.store offset=16
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.store offset=12
    block  ;; label = @1
      block  ;; label = @2
        loop  ;; label = @3
          local.get 5
          i32.load offset=12
          local.set 7
          local.get 5
          i32.load offset=24
          local.set 8
          local.get 8
          i32.load offset=4
          local.set 9
          local.get 7
          local.get 9
          i32.lt_u
          local.set 10
          i32.const 1
          local.set 11
          local.get 10
          local.get 11
          i32.and
          local.set 12
          local.get 12
          i32.eqz
          br_if 1 (;@2;)
          local.get 5
          i32.load offset=20
          local.set 13
          local.get 5
          i32.load offset=24
          local.set 14
          local.get 14
          i32.load
          local.set 15
          local.get 5
          i32.load offset=12
          local.set 16
          i32.const 2
          local.set 17
          local.get 16
          local.get 17
          i32.shl
          local.set 18
          local.get 15
          local.get 18
          i32.add
          local.set 19
          local.get 19
          i32.load
          local.set 20
          local.get 5
          i32.load offset=16
          local.set 21
          local.get 20
          local.get 21
          local.get 13
          call_indirect (type 0)
          local.set 22
          block  ;; label = @4
            local.get 22
            i32.eqz
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=12
            local.set 23
            local.get 5
            local.get 23
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 5
          i32.load offset=12
          local.set 24
          i32.const 1
          local.set 25
          local.get 24
          local.get 25
          i32.add
          local.set 26
          local.get 5
          local.get 26
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      i32.const -1
      local.set 27
      local.get 5
      local.get 27
      i32.store offset=28
    end
    local.get 5
    i32.load offset=28
    local.set 28
    i32.const 32
    local.set 29
    local.get 5
    local.get 29
    i32.add
    local.set 30
    local.get 30
    global.set $__stack_pointer
    local.get 28
    return)"
arraylist_clear,ArrayList *arraylist,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void arraylist_clear(ArrayList *arraylist)
{
	/* To clear the list, simply set the length to zero */
	arraylist->length = 0;
}","(func $arraylist_clear (type 2) (param i32)
    (local i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    return)"
arraylist_sort_internal,"ArrayListValue *list_data, unsigned int list_length, ArrayListCompareFunc compare_func","To clear the list, simply set the length to zero",null,"
static void arraylist_sort_internal(ArrayListValue *list_data,
                                    unsigned int list_length,
                                    ArrayListCompareFunc compare_func)
{
	ArrayListValue pivot;
	ArrayListValue tmp;
	unsigned int i;
	unsigned int list1_length;
	unsigned int list2_length;

	/* If less than two items, it is always sorted. */
	if (list_length <= 1) {
		return;
	}

	/* Take the last item as the pivot. */
	pivot = list_data[list_length - 1];

	/* Divide the list into two lists:
	 *
	 * List 1 contains data less than the pivot.
	 * List 2 contains data more than the pivot.
	 *
	 * As the lists are build up, they are stored sequentially after
	 * each other, ie. list_data[list1_length-1] is the last item
	 * in list 1, list_data[list1_length] is the first item in
	 * list 2.
	 */
	list1_length = 0;

	for (i = 0; i < list_length - 1; ++i) {

		if (compare_func(list_data[i], pivot) < 0) {

			/* This should be in list 1.  Therefore it is in the
			 * wrong position. Swap the data immediately following
			 * the last item in list 1 with this data. */
			tmp = list_data[i];
			list_data[i] = list_data[list1_length];
			list_data[list1_length] = tmp;

			++list1_length;

		} else {
			/* This should be in list 2.  This is already in the
			 * right position. */
		}
	}

	/* The length of list 2 can be calculated. */
	list2_length = list_length - list1_length - 1;

	/* list_data[0..list1_length-1] now contains all items which are
	 * before the pivot.
	 * list_data[list1_length..list_length-2] contains all items after
	 * or equal to the pivot.
	 * Move the pivot into place, by swapping it with the item
	 * immediately following the end of list 1. */
	list_data[list_length - 1] = list_data[list1_length];
	list_data[list1_length] = pivot;

	/* Recursively sort the sublists. */
	arraylist_sort_internal(list_data, list1_length, compare_func);

	arraylist_sort_internal(&list_data[list1_length + 1], list2_length,
	                        compare_func);
}","(func $arraylist_sort_internal (type 5) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 32
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=28
    local.get 5
    local.get 1
    i32.store offset=24
    local.get 5
    local.get 2
    i32.store offset=20
    local.get 5
    i32.load offset=24
    local.set 6
    i32.const 1
    local.set 7
    local.get 6
    local.get 7
    i32.le_u
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      block  ;; label = @2
        local.get 10
        i32.eqz
        br_if 0 (;@2;)
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=28
      local.set 11
      local.get 5
      i32.load offset=24
      local.set 12
      i32.const 1
      local.set 13
      local.get 12
      local.get 13
      i32.sub
      local.set 14
      i32.const 2
      local.set 15
      local.get 14
      local.get 15
      i32.shl
      local.set 16
      local.get 11
      local.get 16
      i32.add
      local.set 17
      local.get 17
      i32.load
      local.set 18
      local.get 5
      local.get 18
      i32.store offset=16
      i32.const 0
      local.set 19
      local.get 5
      local.get 19
      i32.store offset=4
      i32.const 0
      local.set 20
      local.get 5
      local.get 20
      i32.store offset=8
      block  ;; label = @2
        loop  ;; label = @3
          local.get 5
          i32.load offset=8
          local.set 21
          local.get 5
          i32.load offset=24
          local.set 22
          i32.const 1
          local.set 23
          local.get 22
          local.get 23
          i32.sub
          local.set 24
          local.get 21
          local.get 24
          i32.lt_u
          local.set 25
          i32.const 1
          local.set 26
          local.get 25
          local.get 26
          i32.and
          local.set 27
          local.get 27
          i32.eqz
          br_if 1 (;@2;)
          local.get 5
          i32.load offset=20
          local.set 28
          local.get 5
          i32.load offset=28
          local.set 29
          local.get 5
          i32.load offset=8
          local.set 30
          i32.const 2
          local.set 31
          local.get 30
          local.get 31
          i32.shl
          local.set 32
          local.get 29
          local.get 32
          i32.add
          local.set 33
          local.get 33
          i32.load
          local.set 34
          local.get 5
          i32.load offset=16
          local.set 35
          local.get 34
          local.get 35
          local.get 28
          call_indirect (type 0)
          local.set 36
          i32.const 0
          local.set 37
          local.get 36
          local.get 37
          i32.lt_s
          local.set 38
          i32.const 1
          local.set 39
          local.get 38
          local.get 39
          i32.and
          local.set 40
          block  ;; label = @4
            block  ;; label = @5
              local.get 40
              i32.eqz
              br_if 0 (;@5;)
              local.get 5
              i32.load offset=28
              local.set 41
              local.get 5
              i32.load offset=8
              local.set 42
              i32.const 2
              local.set 43
              local.get 42
              local.get 43
              i32.shl
              local.set 44
              local.get 41
              local.get 44
              i32.add
              local.set 45
              local.get 45
              i32.load
              local.set 46
              local.get 5
              local.get 46
              i32.store offset=12
              local.get 5
              i32.load offset=28
              local.set 47
              local.get 5
              i32.load offset=4
              local.set 48
              i32.const 2
              local.set 49
              local.get 48
              local.get 49
              i32.shl
              local.set 50
              local.get 47
              local.get 50
              i32.add
              local.set 51
              local.get 51
              i32.load
              local.set 52
              local.get 5
              i32.load offset=28
              local.set 53
              local.get 5
              i32.load offset=8
              local.set 54
              i32.const 2
              local.set 55
              local.get 54
              local.get 55
              i32.shl
              local.set 56
              local.get 53
              local.get 56
              i32.add
              local.set 57
              local.get 57
              local.get 52
              i32.store
              local.get 5
              i32.load offset=12
              local.set 58
              local.get 5
              i32.load offset=28
              local.set 59
              local.get 5
              i32.load offset=4
              local.set 60
              i32.const 2
              local.set 61
              local.get 60
              local.get 61
              i32.shl
              local.set 62
              local.get 59
              local.get 62
              i32.add
              local.set 63
              local.get 63
              local.get 58
              i32.store
              local.get 5
              i32.load offset=4
              local.set 64
              i32.const 1
              local.set 65
              local.get 64
              local.get 65
              i32.add
              local.set 66
              local.get 5
              local.get 66
              i32.store offset=4
              br 1 (;@4;)
            end
          end
          local.get 5
          i32.load offset=8
          local.set 67
          i32.const 1
          local.set 68
          local.get 67
          local.get 68
          i32.add
          local.set 69
          local.get 5
          local.get 69
          i32.store offset=8
          br 0 (;@3;)
        end
      end
      local.get 5
      i32.load offset=24
      local.set 70
      local.get 5
      i32.load offset=4
      local.set 71
      local.get 70
      local.get 71
      i32.sub
      local.set 72
      i32.const 1
      local.set 73
      local.get 72
      local.get 73
      i32.sub
      local.set 74
      local.get 5
      local.get 74
      i32.store
      local.get 5
      i32.load offset=28
      local.set 75
      local.get 5
      i32.load offset=4
      local.set 76
      i32.const 2
      local.set 77
      local.get 76
      local.get 77
      i32.shl
      local.set 78
      local.get 75
      local.get 78
      i32.add
      local.set 79
      local.get 79
      i32.load
      local.set 80
      local.get 5
      i32.load offset=28
      local.set 81
      local.get 5
      i32.load offset=24
      local.set 82
      i32.const 1
      local.set 83
      local.get 82
      local.get 83
      i32.sub
      local.set 84
      i32.const 2
      local.set 85
      local.get 84
      local.get 85
      i32.shl
      local.set 86
      local.get 81
      local.get 86
      i32.add
      local.set 87
      local.get 87
      local.get 80
      i32.store
      local.get 5
      i32.load offset=16
      local.set 88
      local.get 5
      i32.load offset=28
      local.set 89
      local.get 5
      i32.load offset=4
      local.set 90
      i32.const 2
      local.set 91
      local.get 90
      local.get 91
      i32.shl
      local.set 92
      local.get 89
      local.get 92
      i32.add
      local.set 93
      local.get 93
      local.get 88
      i32.store
      local.get 5
      i32.load offset=28
      local.set 94
      local.get 5
      i32.load offset=4
      local.set 95
      local.get 5
      i32.load offset=20
      local.set 96
      local.get 94
      local.get 95
      local.get 96
      call $arraylist_sort_internal
      local.get 5
      i32.load offset=28
      local.set 97
      local.get 5
      i32.load offset=4
      local.set 98
      i32.const 1
      local.set 99
      local.get 98
      local.get 99
      i32.add
      local.set 100
      i32.const 2
      local.set 101
      local.get 100
      local.get 101
      i32.shl
      local.set 102
      local.get 97
      local.get 102
      i32.add
      local.set 103
      local.get 5
      i32.load
      local.set 104
      local.get 5
      i32.load offset=20
      local.set 105
      local.get 103
      local.get 104
      local.get 105
      call $arraylist_sort_internal
    end
    i32.const 32
    local.set 106
    local.get 5
    local.get 106
    i32.add
    local.set 107
    local.get 107
    global.set $__stack_pointer
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""arraylist_new"" (func $arraylist_new))
  (export ""arraylist_free"" (func $arraylist_free))
  (export ""arraylist_insert"" (func $arraylist_insert))
  (export ""arraylist_append"" (func $arraylist_append))
  (export ""arraylist_prepend"" (func $arraylist_prepend))
  (export ""arraylist_remove_range"" (func $arraylist_remove_range))
  (export ""arraylist_remove"" (func $arraylist_remove))
  (export ""arraylist_index_of"" (func $arraylist_index_of))
  (export ""__indirect_function_table"" (table 0))
  (export ""arraylist_clear"" (func $arraylist_clear))
  (export ""arraylist_sort"" (func $arraylist_sort))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
arraylist_sort,"ArrayList *arraylist, ArrayListCompareFunc compare_func","Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",null,"
void arraylist_sort(ArrayList *arraylist, ArrayListCompareFunc compare_func)
{
	/* Perform the recursive sort */
	arraylist_sort_internal(arraylist->data, arraylist->length,
	                        compare_func);
}","(func $arraylist_sort (type 6) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 5
    i32.load
    local.set 6
    local.get 4
    i32.load offset=12
    local.set 7
    local.get 7
    i32.load offset=4
    local.set 8
    local.get 4
    i32.load offset=8
    local.set 9
    local.get 6
    local.get 8
    local.get 9
    call $arraylist_sort_internal
    i32.const 16
    local.set 10
    local.get 4
    local.get 10
    i32.add
    local.set 11
    local.get 11
    global.set $__stack_pointer
    return)"
avl_tree_update_height,AVLTreeNode *node,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"static void avl_tree_update_height(AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	int left_height, right_height;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];
	left_height = avl_tree_subtree_height(left_subtree);
	right_height = avl_tree_subtree_height(right_subtree);

	if (left_height > right_height) {
		node->height = left_height + 1;
	} else {
		node->height = right_height + 1;
	}
}","(func $avl_tree_update_height (type 2) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 32
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=28
    local.get 3
    i32.load offset=28
    local.set 4
    local.get 4
    i32.load
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=24
    local.get 3
    i32.load offset=28
    local.set 6
    local.get 6
    i32.load offset=4
    local.set 7
    local.get 3
    local.get 7
    i32.store offset=20
    local.get 3
    i32.load offset=24
    local.set 8
    local.get 8
    call $avl_tree_subtree_height
    local.set 9
    local.get 3
    local.get 9
    i32.store offset=16
    local.get 3
    i32.load offset=20
    local.set 10
    local.get 10
    call $avl_tree_subtree_height
    local.set 11
    local.get 3
    local.get 11
    i32.store offset=12
    local.get 3
    i32.load offset=16
    local.set 12
    local.get 3
    i32.load offset=12
    local.set 13
    local.get 12
    local.get 13
    i32.gt_s
    local.set 14
    i32.const 1
    local.set 15
    local.get 14
    local.get 15
    i32.and
    local.set 16
    block  ;; label = @1
      block  ;; label = @2
        local.get 16
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=16
        local.set 17
        i32.const 1
        local.set 18
        local.get 17
        local.get 18
        i32.add
        local.set 19
        local.get 3
        i32.load offset=28
        local.set 20
        local.get 20
        local.get 19
        i32.store offset=20
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 21
      i32.const 1
      local.set 22
      local.get 21
      local.get 22
      i32.add
      local.set 23
      local.get 3
      i32.load offset=28
      local.set 24
      local.get 24
      local.get 23
      i32.store offset=20
    end
    i32.const 32
    local.set 25
    local.get 3
    local.get 25
    i32.add
    local.set 26
    local.get 26
    global.set $__stack_pointer
    return)"
avl_tree_node_replace,"AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",new_root | node,"static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1,
                                  AVLTreeNode *node2)
{
	int side;

	/* Set the node's parent pointer. */
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}

	/* The root node? */
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = avl_tree_node_parent_side(node1);
		node1->parent->children[side] = node2;

		avl_tree_update_height(node1->parent);
	}
}

/* Rotate a section of the tree.  'node' is the node at the top
 * of the section to be rotated.  'direction' is the direction in
 * which to rotate the tree: left or right, as shown in the following
 * diagram:
 *
 * Left rotation:              Right rotation:
 *
 *      B                             D
 *     / \                           / \
 *    A   D                         B   E
 *       / \                       / \
 *      C   E                     A   C

 * is rotated to:              is rotated to:
 *
 *        D                           B
 *       / \                         / \
 *      B   E                       A   D
 *     / \                             / \
 *    A   C                           C   E
 */
static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node,
                                    AVLTreeNodeSide direction)
{
	AVLTreeNode *new_root;

	/* The child of this node will take its place:
	   for a left rotation, it is the right child, and vice versa. */
	new_root = node->children[1 - direction];

	/* Make new_root the root, update parent pointers. */
	avl_tree_node_replace(tree, node, new_root);

	/* Rearrange pointers */
	node->children[1 - direction] = new_root->children[direction];
	new_root->children[direction] = node;

	/* Update parent references */
	node->parent = new_root;

	if (node->children[1 - direction] != NULL) {
		node->children[1 - direction]->parent = node;
	}

	/* Update heights of the affected nodes */
	avl_tree_update_height(new_root);
	avl_tree_update_height(node);

	return new_root;
}

/* Balance a particular tree node.
 *
 * Returns the root node of the new subtree which is replacing the
 * old one. */
static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	AVLTreeNode *child;
	int diff;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];

	/* Check the heights of the child trees.  If there is an unbalance
	 * (difference between left and right > 2), then rotate nodes
	 * around to fix it */
	diff = avl_tree_subtree_height(right_subtree) -
	       avl_tree_subtree_height(left_subtree);

	if (diff >= 2) {

		/* Biased toward the right side too much. */
		child = right_subtree;

		if (avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_RIGHT]) <
		    avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_LEFT])) {

			/* If the right child is biased toward the left
			 * side, it must be rotated right first (double
			 * rotation) */
			avl_tree_rotate(tree, right_subtree,
			                AVL_TREE_NODE_RIGHT);
		}

		/* Perform a left rotation.  After this, the right child will
		 * take the place of this node.  Update the node pointer. */
		node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);

	} else if (diff <= -2) {

		/* Biased toward the left side too much. */
		child = node->children[AVL_TREE_NODE_LEFT];

		if (avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_LEFT]) <
		    avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_RIGHT])) {

			/* If the left child is biased toward the right
			 * side, it must be rotated right left (double
			 * rotation) */
			avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);
		}

		/* Perform a right rotation.  After this, the left child will
		 * take the place of this node.  Update the node pointer. */
		node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);
	}

	/* Update the height of this node */
	avl_tree_update_height(node);

	return node;
}

/* Walk up the tree from the given node, performing any needed rotations */
static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *rover;

	rover = node;

	while (rover != NULL) {

		/* Balance this node if necessary */
		rover = avl_tree_node_balance(tree, rover);

		/* Go to this node's parent */
		rover = rover->parent;
	}","(func $avl_tree_node_replace (type 6) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=12
    local.get 5
    local.get 1
    i32.store offset=8
    local.get 5
    local.get 2
    i32.store offset=4
    local.get 5
    i32.load offset=4
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.ne
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      i32.eqz
      br_if 0 (;@1;)
      local.get 5
      i32.load offset=8
      local.set 11
      local.get 11
      i32.load offset=8
      local.set 12
      local.get 5
      i32.load offset=4
      local.set 13
      local.get 13
      local.get 12
      i32.store offset=8
    end
    local.get 5
    i32.load offset=8
    local.set 14
    local.get 14
    i32.load offset=8
    local.set 15
    i32.const 0
    local.set 16
    local.get 15
    local.get 16
    i32.eq
    local.set 17
    i32.const 1
    local.set 18
    local.get 17
    local.get 18
    i32.and
    local.set 19
    block  ;; label = @1
      block  ;; label = @2
        local.get 19
        i32.eqz
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=4
        local.set 20
        local.get 5
        i32.load offset=12
        local.set 21
        local.get 21
        local.get 20
        i32.store
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=8
      local.set 22
      local.get 22
      call $avl_tree_node_parent_side
      local.set 23
      local.get 5
      local.get 23
      i32.store
      local.get 5
      i32.load offset=4
      local.set 24
      local.get 5
      i32.load offset=8
      local.set 25
      local.get 25
      i32.load offset=8
      local.set 26
      local.get 5
      i32.load
      local.set 27
      i32.const 2
      local.set 28
      local.get 27
      local.get 28
      i32.shl
      local.set 29
      local.get 26
      local.get 29
      i32.add
      local.set 30
      local.get 30
      local.get 24
      i32.store
      local.get 5
      i32.load offset=8
      local.set 31
      local.get 31
      i32.load offset=8
      local.set 32
      local.get 32
      call $avl_tree_update_height
    end
    i32.const 16
    local.set 33
    local.get 5
    local.get 33
    i32.add
    local.set 34
    local.get 34
    global.set $__stack_pointer
    return)"
avl_tree_balance_to_root,"AVLTree *tree, AVLTreeNode *node","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.","NULL | new_node | result | 0 | 1 | this node */
			return node | avl_tree_null_value | node->value | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes | array","static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *rover;

	rover = node;

	while (rover != NULL) {

		/* Balance this node if necessary */
		rover = avl_tree_node_balance(tree, rover);

		/* Go to this node's parent */
		rover = rover->parent;
	}
}

AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)
{
	AVLTreeNode **rover;
	AVLTreeNode *new_node;
	AVLTreeNode *previous_node;

	/* Walk down the tree until we reach a NULL pointer */
	rover = &tree->root_node;
	previous_node = NULL;

	while (*rover != NULL) {
		previous_node = *rover;
		if (tree->compare_func(key, (*rover)->key) < 0) {
			rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);
		} else {
			rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);
		}
	}

	/* Create a new node.  Use the last node visited as the parent link. */
	new_node = (AVLTreeNode *) malloc(sizeof(AVLTreeNode));

	if (new_node == NULL) {
		return NULL;
	}

	new_node->children[AVL_TREE_NODE_LEFT] = NULL;
	new_node->children[AVL_TREE_NODE_RIGHT] = NULL;
	new_node->parent = previous_node;
	new_node->key = key;
	new_node->value = value;
	new_node->height = 1;

	/* Insert at the NULL pointer that was reached */
	*rover = new_node;

	/* Rebalance the tree, starting from the previous node. */
	avl_tree_balance_to_root(tree, previous_node);

	/* Keep track of the number of entries */
	++tree->num_nodes;

	return new_node;
}

/* Find the nearest node to the given node, to replace it.
 * The node returned is unlinked from the tree.
 * Returns NULL if the node has no children. */
static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree,
                                                  AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	AVLTreeNode *result;
	AVLTreeNode *child;
	int left_height, right_height;
	int side;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];

	/* No children? */
	if (left_subtree == NULL && right_subtree == NULL) {
		return NULL;
	}

	/* Pick a node from whichever subtree is taller.  This helps to
	 * keep the tree balanced. */
	left_height = avl_tree_subtree_height(left_subtree);
	right_height = avl_tree_subtree_height(right_subtree);

	if (left_height < right_height) {
		side = AVL_TREE_NODE_RIGHT;
	} else {
		side = AVL_TREE_NODE_LEFT;
	}

	/* Search down the tree, back towards the center. */
	result = node->children[side];

	while (result->children[1 - side] != NULL) {
		result = result->children[1 - side];
	}

	/* Unlink the result node, and hook in its remaining child
	 * (if it has one) to replace it. */
	child = result->children[side];
	avl_tree_node_replace(tree, result, child);

	/* Update the subtree height for the result node's old parent. */
	avl_tree_update_height(result->parent);

	return result;
}

/* Remove a node from a tree */
void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *swap_node;
	AVLTreeNode *balance_startpoint;
	int i;

	/* The node to be removed must be swapped with an ""adjacent""
	 * node, ie. one which has the closest key to this one. Find
	 * a node to swap with. */
	swap_node = avl_tree_node_get_replacement(tree, node);

	if (swap_node == NULL) {

		/* This is a leaf node and has no children, therefore
		 * it can be immediately removed. */
		/* Unlink this node from its parent. */
		avl_tree_node_replace(tree, node, NULL);

		/* Start rebalancing from the parent of the original node */
		balance_startpoint = node->parent;

	} else {
		/* We will start rebalancing from the old parent of the
		 * swap node.  Sometimes, the old parent is the node we
		 * are removing, in which case we must start rebalancing
		 * from the swap node. */
		if (swap_node->parent == node) {
			balance_startpoint = swap_node;
		} else {
			balance_startpoint = swap_node->parent;
		}

		/* Copy references in the node into the swap node */
		for (i = 0; i < 2; ++i) {
			swap_node->children[i] = node->children[i];

			if (swap_node->children[i] != NULL) {
				swap_node->children[i]->parent = swap_node;
			}
		}

		swap_node->height = node->height;

		/* Link the parent's reference to this node */
		avl_tree_node_replace(tree, node, swap_node);
	}

	/* Destroy the node */
	free(node);

	/* Keep track of the number of nodes */
	--tree->num_nodes;

	/* Rebalance the tree */
	avl_tree_balance_to_root(tree, balance_startpoint);
}

/* Remove a node by key */
int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}

AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;
	int diff;

	/* Search down the tree and attempt to find the node which
	 * has the specified key */
	node = tree->root_node;

	while (node != NULL) {

		diff = tree->compare_func(key, node->key);

		if (diff == 0) {

			/* Keys are equal: return this node */
			return node;

		} else if (diff < 0) {
			node = node->children[AVL_TREE_NODE_LEFT];
		} else {
			node = node->children[AVL_TREE_NODE_RIGHT];
		}
	}

	/* Not found */
	return NULL;
}

AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		return avl_tree_null_value;
	} else {
		return node->value;
	}
}

AVLTreeNode *avl_tree_root_node(AVLTree *tree)
{
	return tree->root_node;
}

AVLTreeKey avl_tree_node_key(AVLTreeNode *node)
{
	return node->key;
}

AVLTreeValue avl_tree_node_value(AVLTreeNode *node)
{
	return node->value;
}

AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)
{
	if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)
{
	return node->parent;
}

unsigned int avl_tree_num_entries(AVLTree *tree)
{
	return tree->num_nodes;
}

static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}

AVLTreeKey *avl_tree_to_array(AVLTree *tree)
{
	AVLTreeKey *array;
	int index;

	/* Allocate the array */
	array = malloc(sizeof(AVLTreeKey) * tree->num_nodes);

	if (array == NULL) {
		return NULL;
	}

	index = 0;

	/* Add all keys */
	avl_tree_to_array_add_subtree(tree->root_node, array, &index);

	return array;
}","(func $avl_tree_balance_to_root (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=4
        local.set 6
        i32.const 0
        local.set 7
        local.get 6
        local.get 7
        i32.ne
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=12
        local.set 11
        local.get 4
        i32.load offset=4
        local.set 12
        local.get 11
        local.get 12
        call $avl_tree_node_balance
        local.set 13
        local.get 4
        local.get 13
        i32.store offset=4
        local.get 4
        i32.load offset=4
        local.set 14
        local.get 14
        i32.load offset=8
        local.set 15
        local.get 4
        local.get 15
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 16
    local.get 4
    local.get 16
    i32.add
    local.set 17
    local.get 17
    global.set $__stack_pointer
    return)"
avl_tree_remove_node,"AVLTree *tree, AVLTreeNode *node","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.","0 | 1 | this node */
			return node | NULL | avl_tree_null_value | node->value | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes | array","void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *swap_node;
	AVLTreeNode *balance_startpoint;
	int i;

	/* The node to be removed must be swapped with an ""adjacent""
	 * node, ie. one which has the closest key to this one. Find
	 * a node to swap with. */
	swap_node = avl_tree_node_get_replacement(tree, node);

	if (swap_node == NULL) {

		/* This is a leaf node and has no children, therefore
		 * it can be immediately removed. */
		/* Unlink this node from its parent. */
		avl_tree_node_replace(tree, node, NULL);

		/* Start rebalancing from the parent of the original node */
		balance_startpoint = node->parent;

	} else {
		/* We will start rebalancing from the old parent of the
		 * swap node.  Sometimes, the old parent is the node we
		 * are removing, in which case we must start rebalancing
		 * from the swap node. */
		if (swap_node->parent == node) {
			balance_startpoint = swap_node;
		} else {
			balance_startpoint = swap_node->parent;
		}

		/* Copy references in the node into the swap node */
		for (i = 0; i < 2; ++i) {
			swap_node->children[i] = node->children[i];

			if (swap_node->children[i] != NULL) {
				swap_node->children[i]->parent = swap_node;
			}
		}

		swap_node->height = node->height;

		/* Link the parent's reference to this node */
		avl_tree_node_replace(tree, node, swap_node);
	}

	/* Destroy the node */
	free(node);

	/* Keep track of the number of nodes */
	--tree->num_nodes;

	/* Rebalance the tree */
	avl_tree_balance_to_root(tree, balance_startpoint);
}

/* Remove a node by key */
int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}

AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;
	int diff;

	/* Search down the tree and attempt to find the node which
	 * has the specified key */
	node = tree->root_node;

	while (node != NULL) {

		diff = tree->compare_func(key, node->key);

		if (diff == 0) {

			/* Keys are equal: return this node */
			return node;

		} else if (diff < 0) {
			node = node->children[AVL_TREE_NODE_LEFT];
		} else {
			node = node->children[AVL_TREE_NODE_RIGHT];
		}
	}

	/* Not found */
	return NULL;
}

AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		return avl_tree_null_value;
	} else {
		return node->value;
	}
}

AVLTreeNode *avl_tree_root_node(AVLTree *tree)
{
	return tree->root_node;
}

AVLTreeKey avl_tree_node_key(AVLTreeNode *node)
{
	return node->key;
}

AVLTreeValue avl_tree_node_value(AVLTreeNode *node)
{
	return node->value;
}

AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)
{
	if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)
{
	return node->parent;
}

unsigned int avl_tree_num_entries(AVLTree *tree)
{
	return tree->num_nodes;
}

static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}

AVLTreeKey *avl_tree_to_array(AVLTree *tree)
{
	AVLTreeKey *array;
	int index;

	/* Allocate the array */
	array = malloc(sizeof(AVLTreeKey) * tree->num_nodes);

	if (array == NULL) {
		return NULL;
	}

	index = 0;

	/* Add all keys */
	avl_tree_to_array_add_subtree(tree->root_node, array, &index);

	return array;
}","(func $avl_tree_remove_node (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=28
    local.get 4
    local.get 1
    i32.store offset=24
    local.get 4
    i32.load offset=28
    local.set 5
    local.get 4
    i32.load offset=24
    local.set 6
    local.get 5
    local.get 6
    call $avl_tree_node_get_replacement
    local.set 7
    local.get 4
    local.get 7
    i32.store offset=20
    local.get 4
    i32.load offset=20
    local.set 8
    i32.const 0
    local.set 9
    local.get 8
    local.get 9
    i32.eq
    local.set 10
    i32.const 1
    local.set 11
    local.get 10
    local.get 11
    i32.and
    local.set 12
    block  ;; label = @1
      block  ;; label = @2
        local.get 12
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=28
        local.set 13
        local.get 4
        i32.load offset=24
        local.set 14
        i32.const 0
        local.set 15
        local.get 13
        local.get 14
        local.get 15
        call $avl_tree_node_replace
        local.get 4
        i32.load offset=24
        local.set 16
        local.get 16
        i32.load offset=8
        local.set 17
        local.get 4
        local.get 17
        i32.store offset=16
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=20
      local.set 18
      local.get 18
      i32.load offset=8
      local.set 19
      local.get 4
      i32.load offset=24
      local.set 20
      local.get 19
      local.get 20
      i32.eq
      local.set 21
      i32.const 1
      local.set 22
      local.get 21
      local.get 22
      i32.and
      local.set 23
      block  ;; label = @2
        block  ;; label = @3
          local.get 23
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=20
          local.set 24
          local.get 4
          local.get 24
          i32.store offset=16
          br 1 (;@2;)
        end
        local.get 4
        i32.load offset=20
        local.set 25
        local.get 25
        i32.load offset=8
        local.set 26
        local.get 4
        local.get 26
        i32.store offset=16
      end
      i32.const 0
      local.set 27
      local.get 4
      local.get 27
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=12
          local.set 28
          i32.const 2
          local.set 29
          local.get 28
          local.get 29
          i32.lt_s
          local.set 30
          i32.const 1
          local.set 31
          local.get 30
          local.get 31
          i32.and
          local.set 32
          local.get 32
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=24
          local.set 33
          local.get 4
          i32.load offset=12
          local.set 34
          i32.const 2
          local.set 35
          local.get 34
          local.get 35
          i32.shl
          local.set 36
          local.get 33
          local.get 36
          i32.add
          local.set 37
          local.get 37
          i32.load
          local.set 38
          local.get 4
          i32.load offset=20
          local.set 39
          local.get 4
          i32.load offset=12
          local.set 40
          i32.const 2
          local.set 41
          local.get 40
          local.get 41
          i32.shl
          local.set 42
          local.get 39
          local.get 42
          i32.add
          local.set 43
          local.get 43
          local.get 38
          i32.store
          local.get 4
          i32.load offset=20
          local.set 44
          local.get 4
          i32.load offset=12
          local.set 45
          i32.const 2
          local.set 46
          local.get 45
          local.get 46
          i32.shl
          local.set 47
          local.get 44
          local.get 47
          i32.add
          local.set 48
          local.get 48
          i32.load
          local.set 49
          i32.const 0
          local.set 50
          local.get 49
          local.get 50
          i32.ne
          local.set 51
          i32.const 1
          local.set 52
          local.get 51
          local.get 52
          i32.and
          local.set 53
          block  ;; label = @4
            local.get 53
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=20
            local.set 54
            local.get 4
            i32.load offset=20
            local.set 55
            local.get 4
            i32.load offset=12
            local.set 56
            i32.const 2
            local.set 57
            local.get 56
            local.get 57
            i32.shl
            local.set 58
            local.get 55
            local.get 58
            i32.add
            local.set 59
            local.get 59
            i32.load
            local.set 60
            local.get 60
            local.get 54
            i32.store offset=8
          end
          local.get 4
          i32.load offset=12
          local.set 61
          i32.const 1
          local.set 62
          local.get 61
          local.get 62
          i32.add
          local.set 63
          local.get 4
          local.get 63
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      local.get 4
      i32.load offset=24
      local.set 64
      local.get 64
      i32.load offset=20
      local.set 65
      local.get 4
      i32.load offset=20
      local.set 66
      local.get 66
      local.get 65
      i32.store offset=20
      local.get 4
      i32.load offset=28
      local.set 67
      local.get 4
      i32.load offset=24
      local.set 68
      local.get 4
      i32.load offset=20
      local.set 69
      local.get 67
      local.get 68
      local.get 69
      call $avl_tree_node_replace
    end
    local.get 4
    i32.load offset=24
    local.set 70
    local.get 70
    call $free
    local.get 4
    i32.load offset=28
    local.set 71
    local.get 71
    i32.load offset=8
    local.set 72
    i32.const -1
    local.set 73
    local.get 72
    local.get 73
    i32.add
    local.set 74
    local.get 71
    local.get 74
    i32.store offset=8
    local.get 4
    i32.load offset=28
    local.set 75
    local.get 4
    i32.load offset=16
    local.set 76
    local.get 75
    local.get 76
    call $avl_tree_balance_to_root
    i32.const 32
    local.set 77
    local.get 4
    local.get 77
    i32.add
    local.set 78
    local.get 78
    global.set $__stack_pointer
    return)"
avl_tree_remove,"AVLTree *tree, AVLTreeKey key","Removes an element or a range of elements from a collection.
Shifts remaining elements and decrements the length counter.",0 | 1,"int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}","(func $avl_tree_remove (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    i32.load offset=4
    local.set 6
    local.get 5
    local.get 6
    call $avl_tree_lookup_node
    local.set 7
    local.get 4
    local.get 7
    i32.store
    local.get 4
    i32.load
    local.set 8
    i32.const 0
    local.set 9
    local.get 8
    local.get 9
    i32.eq
    local.set 10
    i32.const 1
    local.set 11
    local.get 10
    local.get 11
    i32.and
    local.set 12
    block  ;; label = @1
      block  ;; label = @2
        local.get 12
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 13
        local.get 4
        local.get 13
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=8
      local.set 14
      local.get 4
      i32.load
      local.set 15
      local.get 14
      local.get 15
      call $avl_tree_remove_node
      i32.const 1
      local.set 16
      local.get 4
      local.get 16
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 17
    i32.const 16
    local.set 18
    local.get 4
    local.get 18
    i32.add
    local.set 19
    local.get 19
    global.set $__stack_pointer
    local.get 17
    return)"
avl_tree_to_array_add_subtree,"AVLTreeNode *subtree, AVLTreeKey *array, int *index","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}","(func $avl_tree_to_array_add_subtree (type 6) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=12
    local.get 5
    local.get 1
    i32.store offset=8
    local.get 5
    local.get 2
    i32.store offset=4
    local.get 5
    i32.load offset=12
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.eq
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      block  ;; label = @2
        local.get 10
        i32.eqz
        br_if 0 (;@2;)
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=12
      local.set 11
      local.get 11
      i32.load
      local.set 12
      local.get 5
      i32.load offset=8
      local.set 13
      local.get 5
      i32.load offset=4
      local.set 14
      local.get 12
      local.get 13
      local.get 14
      call $avl_tree_to_array_add_subtree
      local.get 5
      i32.load offset=12
      local.set 15
      local.get 15
      i32.load offset=12
      local.set 16
      local.get 5
      i32.load offset=8
      local.set 17
      local.get 5
      i32.load offset=4
      local.set 18
      local.get 18
      i32.load
      local.set 19
      i32.const 2
      local.set 20
      local.get 19
      local.get 20
      i32.shl
      local.set 21
      local.get 17
      local.get 21
      i32.add
      local.set 22
      local.get 22
      local.get 16
      i32.store
      local.get 5
      i32.load offset=4
      local.set 23
      local.get 23
      i32.load
      local.set 24
      i32.const 1
      local.set 25
      local.get 24
      local.get 25
      i32.add
      local.set 26
      local.get 23
      local.get 26
      i32.store
      local.get 5
      i32.load offset=12
      local.set 27
      local.get 27
      i32.load offset=4
      local.set 28
      local.get 5
      i32.load offset=8
      local.set 29
      local.get 5
      i32.load offset=4
      local.set 30
      local.get 28
      local.get 29
      local.get 30
      call $avl_tree_to_array_add_subtree
    end
    i32.const 16
    local.set 31
    local.get 5
    local.get 31
    i32.add
    local.set 32
    local.get 32
    global.set $__stack_pointer
    return)"
binary_heap_cmp,"BinaryHeap *heap, BinaryHeapValue data1, BinaryHeapValue data2",Null value that can be returned without creating a local variable,"heap->compare_func(data1, data2) | -heap->compare_func(data1, data2)","
static int binary_heap_cmp(BinaryHeap *heap, BinaryHeapValue data1,
                           BinaryHeapValue data2)
{
	if (heap->heap_type == BINARY_HEAP_TYPE_MIN) {
		return heap->compare_func(data1, data2);
	} else {
		return -heap->compare_func(data1, data2);
	}
}","(func $binary_heap_cmp (type 4) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=8
    local.get 5
    local.get 1
    i32.store offset=4
    local.get 5
    local.get 2
    i32.store
    local.get 5
    i32.load offset=8
    local.set 6
    local.get 6
    i32.load
    local.set 7
    block  ;; label = @1
      block  ;; label = @2
        local.get 7
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=8
        local.set 8
        local.get 8
        i32.load offset=16
        local.set 9
        local.get 5
        i32.load offset=4
        local.set 10
        local.get 5
        i32.load
        local.set 11
        local.get 10
        local.get 11
        local.get 9
        call_indirect (type 0)
        local.set 12
        local.get 5
        local.get 12
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=8
      local.set 13
      local.get 13
      i32.load offset=16
      local.set 14
      local.get 5
      i32.load offset=4
      local.set 15
      local.get 5
      i32.load
      local.set 16
      local.get 15
      local.get 16
      local.get 14
      call_indirect (type 0)
      local.set 17
      i32.const 0
      local.set 18
      local.get 18
      local.get 17
      i32.sub
      local.set 19
      local.get 5
      local.get 19
      i32.store offset=12
    end
    local.get 5
    i32.load offset=12
    local.set 20
    i32.const 16
    local.set 21
    local.get 5
    local.get 21
    i32.add
    local.set 22
    local.get 22
    global.set $__stack_pointer
    local.get 20
    return)"
binary_heap_free,BinaryHeap *heap,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void binary_heap_free(BinaryHeap *heap)
{
	free(heap->values);
	free(heap);
}","(func $binary_heap_free (type 2) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    local.get 5
    call $free
    local.get 3
    i32.load offset=12
    local.set 6
    local.get 6
    call $free
    i32.const 16
    local.set 7
    local.get 3
    local.get 7
    i32.add
    local.set 8
    local.get 8
    global.set $__stack_pointer
    return)"
binary_heap_insert,"BinaryHeap *heap, BinaryHeapValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | 1,"
int binary_heap_insert(BinaryHeap *heap, BinaryHeapValue value)
{
	BinaryHeapValue *new_values;
	unsigned int index;
	unsigned int new_size;
	unsigned int parent;

	/* Possibly realloc the heap to a larger size */
	if (heap->num_values >= heap->alloced_size) {

		/* Double the table size */
		new_size = heap->alloced_size * 2;
		new_values =
		    realloc(heap->values, sizeof(BinaryHeapValue) * new_size);

		if (new_values == NULL) {
			return 0;
		}

		heap->alloced_size = new_size;
		heap->values = new_values;
	}

	/* Add to the bottom of the heap and start from there */
	index = heap->num_values;
	++heap->num_values;

	/* Percolate the value up to the top of the heap */
	while (index > 0) {

		/* The parent index is found by halving the node index */
		parent = (index - 1) / 2;

		/* Compare the node with its parent */
		if (binary_heap_cmp(heap, heap->values[parent], value) < 0) {

			/* Ordered correctly - insertion is complete */
			break;

		} else {

			/* Need to swap this node with its parent */
			heap->values[index] = heap->values[parent];

			/* Advance up to the parent */
			index = parent;
		}
	}

	/* Save the new value in the final location */
	heap->values[index] = value;

	return 1;
}","(func $binary_heap_insert (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 5
    i32.load offset=8
    local.set 6
    local.get 4
    i32.load offset=24
    local.set 7
    local.get 7
    i32.load offset=12
    local.set 8
    local.get 6
    local.get 8
    i32.ge_u
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=24
        local.set 12
        local.get 12
        i32.load offset=12
        local.set 13
        i32.const 1
        local.set 14
        local.get 13
        local.get 14
        i32.shl
        local.set 15
        local.get 4
        local.get 15
        i32.store offset=8
        local.get 4
        i32.load offset=24
        local.set 16
        local.get 16
        i32.load offset=4
        local.set 17
        local.get 4
        i32.load offset=8
        local.set 18
        i32.const 2
        local.set 19
        local.get 18
        local.get 19
        i32.shl
        local.set 20
        local.get 17
        local.get 20
        call $realloc
        local.set 21
        local.get 4
        local.get 21
        i32.store offset=16
        local.get 4
        i32.load offset=16
        local.set 22
        i32.const 0
        local.set 23
        local.get 22
        local.get 23
        i32.eq
        local.set 24
        i32.const 1
        local.set 25
        local.get 24
        local.get 25
        i32.and
        local.set 26
        block  ;; label = @3
          local.get 26
          i32.eqz
          br_if 0 (;@3;)
          i32.const 0
          local.set 27
          local.get 4
          local.get 27
          i32.store offset=28
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=8
        local.set 28
        local.get 4
        i32.load offset=24
        local.set 29
        local.get 29
        local.get 28
        i32.store offset=12
        local.get 4
        i32.load offset=16
        local.set 30
        local.get 4
        i32.load offset=24
        local.set 31
        local.get 31
        local.get 30
        i32.store offset=4
      end
      local.get 4
      i32.load offset=24
      local.set 32
      local.get 32
      i32.load offset=8
      local.set 33
      local.get 4
      local.get 33
      i32.store offset=12
      local.get 4
      i32.load offset=24
      local.set 34
      local.get 34
      i32.load offset=8
      local.set 35
      i32.const 1
      local.set 36
      local.get 35
      local.get 36
      i32.add
      local.set 37
      local.get 34
      local.get 37
      i32.store offset=8
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=12
          local.set 38
          i32.const 0
          local.set 39
          local.get 38
          local.get 39
          i32.gt_u
          local.set 40
          i32.const 1
          local.set 41
          local.get 40
          local.get 41
          i32.and
          local.set 42
          local.get 42
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=12
          local.set 43
          i32.const 1
          local.set 44
          local.get 43
          local.get 44
          i32.sub
          local.set 45
          i32.const 1
          local.set 46
          local.get 45
          local.get 46
          i32.shr_u
          local.set 47
          local.get 4
          local.get 47
          i32.store offset=4
          local.get 4
          i32.load offset=24
          local.set 48
          local.get 4
          i32.load offset=24
          local.set 49
          local.get 49
          i32.load offset=4
          local.set 50
          local.get 4
          i32.load offset=4
          local.set 51
          i32.const 2
          local.set 52
          local.get 51
          local.get 52
          i32.shl
          local.set 53
          local.get 50
          local.get 53
          i32.add
          local.set 54
          local.get 54
          i32.load
          local.set 55
          local.get 4
          i32.load offset=20
          local.set 56
          local.get 48
          local.get 55
          local.get 56
          call $binary_heap_cmp
          local.set 57
          i32.const 0
          local.set 58
          local.get 57
          local.get 58
          i32.lt_s
          local.set 59
          i32.const 1
          local.set 60
          local.get 59
          local.get 60
          i32.and
          local.set 61
          block  ;; label = @4
            local.get 61
            i32.eqz
            br_if 0 (;@4;)
            br 2 (;@2;)
          end
          local.get 4
          i32.load offset=24
          local.set 62
          local.get 62
          i32.load offset=4
          local.set 63
          local.get 4
          i32.load offset=4
          local.set 64
          i32.const 2
          local.set 65
          local.get 64
          local.get 65
          i32.shl
          local.set 66
          local.get 63
          local.get 66
          i32.add
          local.set 67
          local.get 67
          i32.load
          local.set 68
          local.get 4
          i32.load offset=24
          local.set 69
          local.get 69
          i32.load offset=4
          local.set 70
          local.get 4
          i32.load offset=12
          local.set 71
          i32.const 2
          local.set 72
          local.get 71
          local.get 72
          i32.shl
          local.set 73
          local.get 70
          local.get 73
          i32.add
          local.set 74
          local.get 74
          local.get 68
          i32.store
          local.get 4
          i32.load offset=4
          local.set 75
          local.get 4
          local.get 75
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      local.get 4
      i32.load offset=20
      local.set 76
      local.get 4
      i32.load offset=24
      local.set 77
      local.get 77
      i32.load offset=4
      local.set 78
      local.get 4
      i32.load offset=12
      local.set 79
      i32.const 2
      local.set 80
      local.get 79
      local.get 80
      i32.shl
      local.set 81
      local.get 78
      local.get 81
      i32.add
      local.set 82
      local.get 82
      local.get 76
      i32.store
      i32.const 1
      local.set 83
      local.get 4
      local.get 83
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 84
    i32.const 32
    local.set 85
    local.get 4
    local.get 85
    i32.add
    local.set 86
    local.get 86
    global.set $__stack_pointer
    local.get 84
    return)"
binomial_heap_merge_undo,"BinomialTree **new_roots, unsigned int count","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"static void binomial_heap_merge_undo(BinomialTree **new_roots,
                                     unsigned int count)
{
	unsigned int i;

	for (i = 0; i <= count; ++i) {
		binomial_tree_unref(new_roots[i]);
	}

	free(new_roots);
}","(func $binomial_heap_merge_undo (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=4
        local.set 6
        local.get 4
        i32.load offset=8
        local.set 7
        local.get 6
        local.get 7
        i32.le_u
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=12
        local.set 11
        local.get 4
        i32.load offset=4
        local.set 12
        i32.const 2
        local.set 13
        local.get 12
        local.get 13
        i32.shl
        local.set 14
        local.get 11
        local.get 14
        i32.add
        local.set 15
        local.get 15
        i32.load
        local.set 16
        local.get 16
        call $binomial_tree_unref
        local.get 4
        i32.load offset=4
        local.set 17
        i32.const 1
        local.set 18
        local.get 17
        local.get 18
        i32.add
        local.set 19
        local.get 4
        local.get 19
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    local.get 4
    i32.load offset=12
    local.set 20
    local.get 20
    call $free
    i32.const 16
    local.set 21
    local.get 4
    local.get 21
    i32.add
    local.set 22
    local.get 22
    global.set $__stack_pointer
    return)"
binomial_heap_merge,"BinomialHeap *heap, BinomialHeap *other","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",0 | 1,"static int binomial_heap_merge(BinomialHeap *heap, BinomialHeap *other)
{
	BinomialTree **new_roots;
	unsigned int new_roots_length;
	BinomialTree *vals[3];
	int num_vals;
	BinomialTree *carry;
	BinomialTree *new_carry;
	unsigned int max;
	unsigned int i;

	/* Find the maximum length of the two heaps.  Add one because
	 * after merging we may have one more value to carry over. */
	if (heap->roots_length > other->roots_length) {
		max = heap->roots_length + 1;
	} else {
		max = other->roots_length + 1;
	}

	/* Allocate an array for the new roots */
	new_roots = malloc(sizeof(BinomialTree *) * max);

	if (new_roots == NULL) {
		return 0;
	}

	/* Go through one entry at a time.  This works kind of like a
	 * ripple-carry adder. */
	new_roots_length = 0;
	carry = NULL;

	for (i = 0; i < max; ++i) {

		/* Build up 'vals' as a list of all the values we must
		 * merge at this step. */
		num_vals = 0;

		/* If there is a value in 'heap', add it */
		if (i < heap->roots_length && heap->roots[i] != NULL) {
			vals[num_vals] = heap->roots[i];
			++num_vals;
		}

		/* If there is a value in 'other', add it */
		if (i < other->roots_length && other->roots[i] != NULL) {
			vals[num_vals] = other->roots[i];
			++num_vals;
		}

		/* If there is a carried value from the previous iteration,
		 * add it */
		if (carry != NULL) {
			vals[num_vals] = carry;
			++num_vals;
		}

		/* When num_vals == 1 or 3, we store a value. */
		if ((num_vals & 1) != 0) {

			/* Save the last value into new_roots. */
			new_roots[i] = vals[num_vals - 1];
			binomial_tree_ref(new_roots[i]);
			new_roots_length = i + 1;

		} else {

			/* No value to store at this iteration */
			new_roots[i] = NULL;
		}

		/* When num_vals == 2 or 3, we must carry over to the
		 * next iteration */
		if ((num_vals & 2) != 0) {

			/* Merge the first two values and carry to the
			 * next iteration */
			new_carry = binomial_tree_merge(heap, vals[0], vals[1]);

			if (new_carry == NULL) {

				/* Remove references that we have added
				 * (freeing any BinomialTree structures
				 * that were created in the process) */
				binomial_heap_merge_undo(new_roots, i);

				/* Unreference the carry variable */
				binomial_tree_unref(carry);

				return 0;
			}

		} else {

			/* Nothing to carry */
			new_carry = NULL;
		}

		/* Unreference previous carried value */
		binomial_tree_unref(carry);

		/* Assign the new value of carry, and add a reference */
		carry = new_carry;

		binomial_tree_ref(carry);
	}

	/* Unreference all values in the old 'roots' array, freeing unused
	 * BinomialTree structures as necessary. */
	for (i = 0; i < heap->roots_length; ++i) {
		if (heap->roots[i] != NULL) {
			binomial_tree_unref(heap->roots[i]);
		}
	}

	/* Free the old roots array and use the new one */
	free(heap->roots);
	heap->roots = new_roots;
	heap->roots_length = new_roots_length;

	/* Merged successfully */
	return 1;
}","(func $binomial_heap_merge (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 64
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=56
    local.get 4
    local.get 1
    i32.store offset=52
    local.get 4
    i32.load offset=56
    local.set 5
    local.get 5
    i32.load offset=16
    local.set 6
    local.get 4
    i32.load offset=52
    local.set 7
    local.get 7
    i32.load offset=16
    local.set 8
    local.get 6
    local.get 8
    i32.gt_u
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=56
        local.set 12
        local.get 12
        i32.load offset=16
        local.set 13
        i32.const 1
        local.set 14
        local.get 13
        local.get 14
        i32.add
        local.set 15
        local.get 4
        local.get 15
        i32.store offset=16
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=52
      local.set 16
      local.get 16
      i32.load offset=16
      local.set 17
      i32.const 1
      local.set 18
      local.get 17
      local.get 18
      i32.add
      local.set 19
      local.get 4
      local.get 19
      i32.store offset=16
    end
    local.get 4
    i32.load offset=16
    local.set 20
    i32.const 2
    local.set 21
    local.get 20
    local.get 21
    i32.shl
    local.set 22
    local.get 22
    call $malloc
    local.set 23
    local.get 4
    local.get 23
    i32.store offset=48
    local.get 4
    i32.load offset=48
    local.set 24
    i32.const 0
    local.set 25
    local.get 24
    local.get 25
    i32.eq
    local.set 26
    i32.const 1
    local.set 27
    local.get 26
    local.get 27
    i32.and
    local.set 28
    block  ;; label = @1
      block  ;; label = @2
        local.get 28
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 29
        local.get 4
        local.get 29
        i32.store offset=60
        br 1 (;@1;)
      end
      i32.const 0
      local.set 30
      local.get 4
      local.get 30
      i32.store offset=44
      i32.const 0
      local.set 31
      local.get 4
      local.get 31
      i32.store offset=24
      i32.const 0
      local.set 32
      local.get 4
      local.get 32
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=12
          local.set 33
          local.get 4
          i32.load offset=16
          local.set 34
          local.get 33
          local.get 34
          i32.lt_u
          local.set 35
          i32.const 1
          local.set 36
          local.get 35
          local.get 36
          i32.and
          local.set 37
          local.get 37
          i32.eqz
          br_if 1 (;@2;)
          i32.const 0
          local.set 38
          local.get 4
          local.get 38
          i32.store offset=28
          local.get 4
          i32.load offset=12
          local.set 39
          local.get 4
          i32.load offset=56
          local.set 40
          local.get 40
          i32.load offset=16
          local.set 41
          local.get 39
          local.get 41
          i32.lt_u
          local.set 42
          i32.const 1
          local.set 43
          local.get 42
          local.get 43
          i32.and
          local.set 44
          block  ;; label = @4
            local.get 44
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=56
            local.set 45
            local.get 45
            i32.load offset=12
            local.set 46
            local.get 4
            i32.load offset=12
            local.set 47
            i32.const 2
            local.set 48
            local.get 47
            local.get 48
            i32.shl
            local.set 49
            local.get 46
            local.get 49
            i32.add
            local.set 50
            local.get 50
            i32.load
            local.set 51
            i32.const 0
            local.set 52
            local.get 51
            local.get 52
            i32.ne
            local.set 53
            i32.const 1
            local.set 54
            local.get 53
            local.get 54
            i32.and
            local.set 55
            local.get 55
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=56
            local.set 56
            local.get 56
            i32.load offset=12
            local.set 57
            local.get 4
            i32.load offset=12
            local.set 58
            i32.const 2
            local.set 59
            local.get 58
            local.get 59
            i32.shl
            local.set 60
            local.get 57
            local.get 60
            i32.add
            local.set 61
            local.get 61
            i32.load
            local.set 62
            local.get 4
            i32.load offset=28
            local.set 63
            i32.const 32
            local.set 64
            local.get 4
            local.get 64
            i32.add
            local.set 65
            local.get 65
            local.set 66
            i32.const 2
            local.set 67
            local.get 63
            local.get 67
            i32.shl
            local.set 68
            local.get 66
            local.get 68
            i32.add
            local.set 69
            local.get 69
            local.get 62
            i32.store
            local.get 4
            i32.load offset=28
            local.set 70
            i32.const 1
            local.set 71
            local.get 70
            local.get 71
            i32.add
            local.set 72
            local.get 4
            local.get 72
            i32.store offset=28
          end
          local.get 4
          i32.load offset=12
          local.set 73
          local.get 4
          i32.load offset=52
          local.set 74
          local.get 74
          i32.load offset=16
          local.set 75
          local.get 73
          local.get 75
          i32.lt_u
          local.set 76
          i32.const 1
          local.set 77
          local.get 76
          local.get 77
          i32.and
          local.set 78
          block  ;; label = @4
            local.get 78
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=52
            local.set 79
            local.get 79
            i32.load offset=12
            local.set 80
            local.get 4
            i32.load offset=12
            local.set 81
            i32.const 2
            local.set 82
            local.get 81
            local.get 82
            i32.shl
            local.set 83
            local.get 80
            local.get 83
            i32.add
            local.set 84
            local.get 84
            i32.load
            local.set 85
            i32.const 0
            local.set 86
            local.get 85
            local.get 86
            i32.ne
            local.set 87
            i32.const 1
            local.set 88
            local.get 87
            local.get 88
            i32.and
            local.set 89
            local.get 89
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=52
            local.set 90
            local.get 90
            i32.load offset=12
            local.set 91
            local.get 4
            i32.load offset=12
            local.set 92
            i32.const 2
            local.set 93
            local.get 92
            local.get 93
            i32.shl
            local.set 94
            local.get 91
            local.get 94
            i32.add
            local.set 95
            local.get 95
            i32.load
            local.set 96
            local.get 4
            i32.load offset=28
            local.set 97
            i32.const 32
            local.set 98
            local.get 4
            local.get 98
            i32.add
            local.set 99
            local.get 99
            local.set 100
            i32.const 2
            local.set 101
            local.get 97
            local.get 101
            i32.shl
            local.set 102
            local.get 100
            local.get 102
            i32.add
            local.set 103
            local.get 103
            local.get 96
            i32.store
            local.get 4
            i32.load offset=28
            local.set 104
            i32.const 1
            local.set 105
            local.get 104
            local.get 105
            i32.add
            local.set 106
            local.get 4
            local.get 106
            i32.store offset=28
          end
          local.get 4
          i32.load offset=24
          local.set 107
          i32.const 0
          local.set 108
          local.get 107
          local.get 108
          i32.ne
          local.set 109
          i32.const 1
          local.set 110
          local.get 109
          local.get 110
          i32.and
          local.set 111
          block  ;; label = @4
            local.get 111
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=24
            local.set 112
            local.get 4
            i32.load offset=28
            local.set 113
            i32.const 32
            local.set 114
            local.get 4
            local.get 114
            i32.add
            local.set 115
            local.get 115
            local.set 116
            i32.const 2
            local.set 117
            local.get 113
            local.get 117
            i32.shl
            local.set 118
            local.get 116
            local.get 118
            i32.add
            local.set 119
            local.get 119
            local.get 112
            i32.store
            local.get 4
            i32.load offset=28
            local.set 120
            i32.const 1
            local.set 121
            local.get 120
            local.get 121
            i32.add
            local.set 122
            local.get 4
            local.get 122
            i32.store offset=28
          end
          local.get 4
          i32.load offset=28
          local.set 123
          i32.const 1
          local.set 124
          local.get 123
          local.get 124
          i32.and
          local.set 125
          block  ;; label = @4
            block  ;; label = @5
              local.get 125
              i32.eqz
              br_if 0 (;@5;)
              local.get 4
              i32.load offset=28
              local.set 126
              i32.const 1
              local.set 127
              local.get 126
              local.get 127
              i32.sub
              local.set 128
              i32.const 32
              local.set 129
              local.get 4
              local.get 129
              i32.add
              local.set 130
              local.get 130
              local.set 131
              i32.const 2
              local.set 132
              local.get 128
              local.get 132
              i32.shl
              local.set 133
              local.get 131
              local.get 133
              i32.add
              local.set 134
              local.get 134
              i32.load
              local.set 135
              local.get 4
              i32.load offset=48
              local.set 136
              local.get 4
              i32.load offset=12
              local.set 137
              i32.const 2
              local.set 138
              local.get 137
              local.get 138
              i32.shl
              local.set 139
              local.get 136
              local.get 139
              i32.add
              local.set 140
              local.get 140
              local.get 135
              i32.store
              local.get 4
              i32.load offset=48
              local.set 141
              local.get 4
              i32.load offset=12
              local.set 142
              i32.const 2
              local.set 143
              local.get 142
              local.get 143
              i32.shl
              local.set 144
              local.get 141
              local.get 144
              i32.add
              local.set 145
              local.get 145
              i32.load
              local.set 146
              local.get 146
              call $binomial_tree_ref
              local.get 4
              i32.load offset=12
              local.set 147
              i32.const 1
              local.set 148
              local.get 147
              local.get 148
              i32.add
              local.set 149
              local.get 4
              local.get 149
              i32.store offset=44
              br 1 (;@4;)
            end
            local.get 4
            i32.load offset=48
            local.set 150
            local.get 4
            i32.load offset=12
            local.set 151
            i32.const 2
            local.set 152
            local.get 151
            local.get 152
            i32.shl
            local.set 153
            local.get 150
            local.get 153
            i32.add
            local.set 154
            i32.const 0
            local.set 155
            local.get 154
            local.get 155
            i32.store
          end
          local.get 4
          i32.load offset=28
          local.set 156
          i32.const 2
          local.set 157
          local.get 156
          local.get 157
          i32.and
          local.set 158
          block  ;; label = @4
            block  ;; label = @5
              local.get 158
              i32.eqz
              br_if 0 (;@5;)
              local.get 4
              i32.load offset=56
              local.set 159
              local.get 4
              i32.load offset=32
              local.set 160
              local.get 4
              i32.load offset=36
              local.set 161
              local.get 159
              local.get 160
              local.get 161
              call $binomial_tree_merge
              local.set 162
              local.get 4
              local.get 162
              i32.store offset=20
              local.get 4
              i32.load offset=20
              local.set 163
              i32.const 0
              local.set 164
              local.get 163
              local.get 164
              i32.eq
              local.set 165
              i32.const 1
              local.set 166
              local.get 165
              local.get 166
              i32.and
              local.set 167
              block  ;; label = @6
                local.get 167
                i32.eqz
                br_if 0 (;@6;)
                local.get 4
                i32.load offset=48
                local.set 168
                local.get 4
                i32.load offset=12
                local.set 169
                local.get 168
                local.get 169
                call $binomial_heap_merge_undo
                local.get 4
                i32.load offset=24
                local.set 170
                local.get 170
                call $binomial_tree_unref
                i32.const 0
                local.set 171
                local.get 4
                local.get 171
                i32.store offset=60
                br 5 (;@1;)
              end
              br 1 (;@4;)
            end
            i32.const 0
            local.set 172
            local.get 4
            local.get 172
            i32.store offset=20
          end
          local.get 4
          i32.load offset=24
          local.set 173
          local.get 173
          call $binomial_tree_unref
          local.get 4
          i32.load offset=20
          local.set 174
          local.get 4
          local.get 174
          i32.store offset=24
          local.get 4
          i32.load offset=24
          local.set 175
          local.get 175
          call $binomial_tree_ref
          local.get 4
          i32.load offset=12
          local.set 176
          i32.const 1
          local.set 177
          local.get 176
          local.get 177
          i32.add
          local.set 178
          local.get 4
          local.get 178
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      i32.const 0
      local.set 179
      local.get 4
      local.get 179
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=12
          local.set 180
          local.get 4
          i32.load offset=56
          local.set 181
          local.get 181
          i32.load offset=16
          local.set 182
          local.get 180
          local.get 182
          i32.lt_u
          local.set 183
          i32.const 1
          local.set 184
          local.get 183
          local.get 184
          i32.and
          local.set 185
          local.get 185
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=56
          local.set 186
          local.get 186
          i32.load offset=12
          local.set 187
          local.get 4
          i32.load offset=12
          local.set 188
          i32.const 2
          local.set 189
          local.get 188
          local.get 189
          i32.shl
          local.set 190
          local.get 187
          local.get 190
          i32.add
          local.set 191
          local.get 191
          i32.load
          local.set 192
          i32.const 0
          local.set 193
          local.get 192
          local.get 193
          i32.ne
          local.set 194
          i32.const 1
          local.set 195
          local.get 194
          local.get 195
          i32.and
          local.set 196
          block  ;; label = @4
            local.get 196
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=56
            local.set 197
            local.get 197
            i32.load offset=12
            local.set 198
            local.get 4
            i32.load offset=12
            local.set 199
            i32.const 2
            local.set 200
            local.get 199
            local.get 200
            i32.shl
            local.set 201
            local.get 198
            local.get 201
            i32.add
            local.set 202
            local.get 202
            i32.load
            local.set 203
            local.get 203
            call $binomial_tree_unref
          end
          local.get 4
          i32.load offset=12
          local.set 204
          i32.const 1
          local.set 205
          local.get 204
          local.get 205
          i32.add
          local.set 206
          local.get 4
          local.get 206
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      local.get 4
      i32.load offset=56
      local.set 207
      local.get 207
      i32.load offset=12
      local.set 208
      local.get 208
      call $free
      local.get 4
      i32.load offset=48
      local.set 209
      local.get 4
      i32.load offset=56
      local.set 210
      local.get 210
      local.get 209
      i32.store offset=12
      local.get 4
      i32.load offset=44
      local.set 211
      local.get 4
      i32.load offset=56
      local.set 212
      local.get 212
      local.get 211
      i32.store offset=16
      i32.const 1
      local.set 213
      local.get 4
      local.get 213
      i32.store offset=60
    end
    local.get 4
    i32.load offset=60
    local.set 214
    i32.const 64
    local.set 215
    local.get 4
    local.get 215
    i32.add
    local.set 216
    local.get 216
    global.set $__stack_pointer
    local.get 214
    return)"
binomial_heap_free,BinomialHeap *heap,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void binomial_heap_free(BinomialHeap *heap)
{
	unsigned int i;

	/* Unreference all trees in the heap.  This should free
	 * back all subtrees. */
	for (i = 0; i < heap->roots_length; ++i) {
		binomial_tree_unref(heap->roots[i]);
	}

	/* Free the heap itself */
	free(heap->roots);
	free(heap);
}","(func $binomial_heap_free (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const 0
    local.set 4
    local.get 3
    local.get 4
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load offset=8
        local.set 5
        local.get 3
        i32.load offset=12
        local.set 6
        local.get 6
        i32.load offset=16
        local.set 7
        local.get 5
        local.get 7
        i32.lt_u
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=12
        local.set 11
        local.get 11
        i32.load offset=12
        local.set 12
        local.get 3
        i32.load offset=8
        local.set 13
        i32.const 2
        local.set 14
        local.get 13
        local.get 14
        i32.shl
        local.set 15
        local.get 12
        local.get 15
        i32.add
        local.set 16
        local.get 16
        i32.load
        local.set 17
        local.get 17
        call $binomial_tree_unref
        local.get 3
        i32.load offset=8
        local.set 18
        i32.const 1
        local.set 19
        local.get 18
        local.get 19
        i32.add
        local.set 20
        local.get 3
        local.get 20
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    local.get 3
    i32.load offset=12
    local.set 21
    local.get 21
    i32.load offset=12
    local.set 22
    local.get 22
    call $free
    local.get 3
    i32.load offset=12
    local.set 23
    local.get 23
    call $free
    i32.const 16
    local.set 24
    local.get 3
    local.get 24
    i32.add
    local.set 25
    local.get 25
    global.set $__stack_pointer
    return)"
binomial_heap_insert,"BinomialHeap *heap, BinomialHeapValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | result,"
int binomial_heap_insert(BinomialHeap *heap, BinomialHeapValue value)
{
	BinomialHeap fake_heap;
	BinomialTree *new_tree;
	int result;

	/* Allocate an order 0 tree for storing the new value */
	new_tree = malloc(sizeof(BinomialTree));

	if (new_tree == NULL) {
		return 0;
	}

	/* Fill in values.  This has an initial reference count of 1 that
	 * the ""fake"" heap holds; this will be removed at the end of
	 * this function. */
	new_tree->value = value;
	new_tree->order = 0;
	new_tree->refcount = 1;
	new_tree->subtrees = NULL;

	/* Build a fake heap structure for merging */
	fake_heap.heap_type = heap->heap_type;
	fake_heap.compare_func = heap->compare_func;
	fake_heap.num_values = 1;
	fake_heap.roots = &new_tree;
	fake_heap.roots_length = 1;

	/* Perform the merge */
	result = binomial_heap_merge(heap, &fake_heap);

	if (result != 0) {
		++heap->num_values;
	}

	/* Remove reference to the new tree. */
	binomial_tree_unref(new_tree);

	return result;
}","(func $binomial_heap_insert (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 48
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=40
    local.get 4
    local.get 1
    i32.store offset=36
    i32.const 12
    local.set 5
    local.get 5
    call $malloc
    local.set 6
    local.get 4
    local.get 6
    i32.store offset=12
    local.get 4
    i32.load offset=12
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.eq
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 12
        local.get 4
        local.get 12
        i32.store offset=44
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=36
      local.set 13
      local.get 4
      i32.load offset=12
      local.set 14
      local.get 14
      local.get 13
      i32.store
      local.get 4
      i32.load offset=12
      local.set 15
      i32.const 0
      local.set 16
      local.get 15
      local.get 16
      i32.store16 offset=4
      local.get 4
      i32.load offset=12
      local.set 17
      i32.const 1
      local.set 18
      local.get 17
      local.get 18
      i32.store16 offset=6
      local.get 4
      i32.load offset=12
      local.set 19
      i32.const 0
      local.set 20
      local.get 19
      local.get 20
      i32.store offset=8
      local.get 4
      i32.load offset=40
      local.set 21
      local.get 21
      i32.load
      local.set 22
      local.get 4
      local.get 22
      i32.store offset=16
      local.get 4
      i32.load offset=40
      local.set 23
      local.get 23
      i32.load offset=4
      local.set 24
      local.get 4
      local.get 24
      i32.store offset=20
      i32.const 1
      local.set 25
      local.get 4
      local.get 25
      i32.store offset=24
      i32.const 12
      local.set 26
      local.get 4
      local.get 26
      i32.add
      local.set 27
      local.get 27
      local.set 28
      local.get 4
      local.get 28
      i32.store offset=28
      i32.const 1
      local.set 29
      local.get 4
      local.get 29
      i32.store offset=32
      local.get 4
      i32.load offset=40
      local.set 30
      i32.const 16
      local.set 31
      local.get 4
      local.get 31
      i32.add
      local.set 32
      local.get 32
      local.set 33
      local.get 30
      local.get 33
      call $binomial_heap_merge
      local.set 34
      local.get 4
      local.get 34
      i32.store offset=8
      local.get 4
      i32.load offset=8
      local.set 35
      block  ;; label = @2
        local.get 35
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=40
        local.set 36
        local.get 36
        i32.load offset=8
        local.set 37
        i32.const 1
        local.set 38
        local.get 37
        local.get 38
        i32.add
        local.set 39
        local.get 36
        local.get 39
        i32.store offset=8
      end
      local.get 4
      i32.load offset=12
      local.set 40
      local.get 40
      call $binomial_tree_unref
      local.get 4
      i32.load offset=8
      local.set 41
      local.get 4
      local.get 41
      i32.store offset=44
    end
    local.get 4
    i32.load offset=44
    local.set 42
    i32.const 48
    local.set 43
    local.get 4
    local.get 43
    i32.add
    local.set 44
    local.get 44
    global.set $__stack_pointer
    local.get 42
    return)"
bloom_filter_free,BloomFilter *bloomfilter,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void bloom_filter_free(BloomFilter *bloomfilter)
{
	free(bloomfilter->table);
	free(bloomfilter);
}","(func $bloom_filter_free (type 2) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    local.get 5
    call $free
    local.get 3
    i32.load offset=12
    local.set 6
    local.get 6
    call $free
    i32.const 16
    local.set 7
    local.get 3
    local.get 7
    i32.add
    local.set 8
    local.get 8
    global.set $__stack_pointer
    return)"
bloom_filter_insert,"BloomFilter *bloomfilter, BloomFilterValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"
void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)
{
	unsigned int hash;
	unsigned int subhash;
	unsigned int index;
	unsigned int i;
	unsigned char b;

	/* Generate hash of the value to insert */
	hash = bloomfilter->hash_func(value);

	/* Generate multiple unique hashes by XORing with values in the
	 * salt table. */
	for (i = 0; i < bloomfilter->num_functions; ++i) {

		/* Generate a unique hash */
		subhash = hash ^ salts[i];

		/* Find the index into the table */
		index = subhash % bloomfilter->table_size;

		/* Insert into the table.
		 * index / 8 finds the byte index of the table,
		 * index % 8 gives the bit index within that byte to set. */
		b = (unsigned char) (1 << (index % 8));
		bloomfilter->table[index / 8] |= b;
	}
}","(func $bloom_filter_insert (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=28
    local.get 4
    local.get 1
    i32.store offset=24
    local.get 4
    i32.load offset=28
    local.set 5
    local.get 5
    i32.load
    local.set 6
    local.get 4
    i32.load offset=24
    local.set 7
    local.get 7
    local.get 6
    call_indirect (type 0)
    local.set 8
    local.get 4
    local.get 8
    i32.store offset=20
    i32.const 0
    local.set 9
    local.get 4
    local.get 9
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=8
        local.set 10
        local.get 4
        i32.load offset=28
        local.set 11
        local.get 11
        i32.load offset=12
        local.set 12
        local.get 10
        local.get 12
        i32.lt_u
        local.set 13
        i32.const 1
        local.set 14
        local.get 13
        local.get 14
        i32.and
        local.set 15
        local.get 15
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=20
        local.set 16
        local.get 4
        i32.load offset=8
        local.set 17
        i32.const 1024
        local.set 18
        i32.const 2
        local.set 19
        local.get 17
        local.get 19
        i32.shl
        local.set 20
        local.get 18
        local.get 20
        i32.add
        local.set 21
        local.get 21
        i32.load
        local.set 22
        local.get 16
        local.get 22
        i32.xor
        local.set 23
        local.get 4
        local.get 23
        i32.store offset=16
        local.get 4
        i32.load offset=16
        local.set 24
        local.get 4
        i32.load offset=28
        local.set 25
        local.get 25
        i32.load offset=8
        local.set 26
        local.get 24
        local.get 26
        i32.rem_u
        local.set 27
        local.get 4
        local.get 27
        i32.store offset=12
        local.get 4
        i32.load offset=12
        local.set 28
        i32.const 7
        local.set 29
        local.get 28
        local.get 29
        i32.and
        local.set 30
        i32.const 1
        local.set 31
        local.get 31
        local.get 30
        i32.shl
        local.set 32
        local.get 4
        local.get 32
        i32.store8 offset=7
        local.get 4
        i32.load8_u offset=7
        local.set 33
        i32.const 255
        local.set 34
        local.get 33
        local.get 34
        i32.and
        local.set 35
        local.get 4
        i32.load offset=28
        local.set 36
        local.get 36
        i32.load offset=4
        local.set 37
        local.get 4
        i32.load offset=12
        local.set 38
        i32.const 3
        local.set 39
        local.get 38
        local.get 39
        i32.shr_u
        local.set 40
        local.get 37
        local.get 40
        i32.add
        local.set 41
        local.get 41
        i32.load8_u
        local.set 42
        i32.const 255
        local.set 43
        local.get 42
        local.get 43
        i32.and
        local.set 44
        local.get 44
        local.get 35
        i32.or
        local.set 45
        local.get 41
        local.get 45
        i32.store8
        local.get 4
        i32.load offset=8
        local.set 46
        i32.const 1
        local.set 47
        local.get 46
        local.get 47
        i32.add
        local.set 48
        local.get 4
        local.get 48
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    i32.const 32
    local.set 49
    local.get 4
    local.get 49
    i32.add
    local.set 50
    local.get 50
    global.set $__stack_pointer
    return)"
bloom_filter_query,"BloomFilter *bloomfilter, BloomFilterValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | 1,"
int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)
{
	unsigned int hash;
	unsigned int subhash;
	unsigned int index;
	unsigned int i;
	unsigned char b;
	int bit;

	/* Generate hash of the value to lookup */
	hash = bloomfilter->hash_func(value);

	/* Generate multiple unique hashes by XORing with values in the
	 * salt table. */
	for (i = 0; i < bloomfilter->num_functions; ++i) {

		/* Generate a unique hash */
		subhash = hash ^ salts[i];

		/* Find the index into the table to test */
		index = subhash % bloomfilter->table_size;

		/* The byte at index / 8 holds the value to test */
		b = bloomfilter->table[index / 8];
		bit = 1 << (index % 8);

		/* Test if the particular bit is set; if it is not set,
		 * this value can not have been inserted. */
		if ((b & bit) == 0) {
			return 0;
		}
	}

	/* All necessary bits were set.  This may indicate that the value
	 * was inserted, or the values could have been set through other
	 * insertions. */
	return 1;
}","(func $bloom_filter_query (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 48
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=40
    local.get 4
    local.get 1
    i32.store offset=36
    local.get 4
    i32.load offset=40
    local.set 5
    local.get 5
    i32.load
    local.set 6
    local.get 4
    i32.load offset=36
    local.set 7
    local.get 7
    local.get 6
    call_indirect (type 0)
    local.set 8
    local.get 4
    local.get 8
    i32.store offset=32
    i32.const 0
    local.set 9
    local.get 4
    local.get 9
    i32.store offset=20
    block  ;; label = @1
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=20
          local.set 10
          local.get 4
          i32.load offset=40
          local.set 11
          local.get 11
          i32.load offset=12
          local.set 12
          local.get 10
          local.get 12
          i32.lt_u
          local.set 13
          i32.const 1
          local.set 14
          local.get 13
          local.get 14
          i32.and
          local.set 15
          local.get 15
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=32
          local.set 16
          local.get 4
          i32.load offset=20
          local.set 17
          i32.const 1024
          local.set 18
          i32.const 2
          local.set 19
          local.get 17
          local.get 19
          i32.shl
          local.set 20
          local.get 18
          local.get 20
          i32.add
          local.set 21
          local.get 21
          i32.load
          local.set 22
          local.get 16
          local.get 22
          i32.xor
          local.set 23
          local.get 4
          local.get 23
          i32.store offset=28
          local.get 4
          i32.load offset=28
          local.set 24
          local.get 4
          i32.load offset=40
          local.set 25
          local.get 25
          i32.load offset=8
          local.set 26
          local.get 24
          local.get 26
          i32.rem_u
          local.set 27
          local.get 4
          local.get 27
          i32.store offset=24
          local.get 4
          i32.load offset=40
          local.set 28
          local.get 28
          i32.load offset=4
          local.set 29
          local.get 4
          i32.load offset=24
          local.set 30
          i32.const 3
          local.set 31
          local.get 30
          local.get 31
          i32.shr_u
          local.set 32
          local.get 29
          local.get 32
          i32.add
          local.set 33
          local.get 33
          i32.load8_u
          local.set 34
          local.get 4
          local.get 34
          i32.store8 offset=19
          local.get 4
          i32.load offset=24
          local.set 35
          i32.const 7
          local.set 36
          local.get 35
          local.get 36
          i32.and
          local.set 37
          i32.const 1
          local.set 38
          local.get 38
          local.get 37
          i32.shl
          local.set 39
          local.get 4
          local.get 39
          i32.store offset=12
          local.get 4
          i32.load8_u offset=19
          local.set 40
          i32.const 255
          local.set 41
          local.get 40
          local.get 41
          i32.and
          local.set 42
          local.get 4
          i32.load offset=12
          local.set 43
          local.get 42
          local.get 43
          i32.and
          local.set 44
          block  ;; label = @4
            local.get 44
            br_if 0 (;@4;)
            i32.const 0
            local.set 45
            local.get 4
            local.get 45
            i32.store offset=44
            br 3 (;@1;)
          end
          local.get 4
          i32.load offset=20
          local.set 46
          i32.const 1
          local.set 47
          local.get 46
          local.get 47
          i32.add
          local.set 48
          local.get 4
          local.get 48
          i32.store offset=20
          br 0 (;@3;)
        end
      end
      i32.const 1
      local.set 49
      local.get 4
      local.get 49
      i32.store offset=44
    end
    local.get 4
    i32.load offset=44
    local.set 50
    i32.const 48
    local.set 51
    local.get 4
    local.get 51
    i32.add
    local.set 52
    local.get 52
    global.set $__stack_pointer
    local.get 50
    return)"
bloom_filter_read,"BloomFilter *bloomfilter, unsigned char *array","All necessary bits were set.  This may indicate that the value
was inserted, or the values could have been set through other
insertions.",null,"
void bloom_filter_read(BloomFilter *bloomfilter, unsigned char *array)
{
	unsigned int array_size;

	/* The table is an array of bits, packed into bytes.  Round up
	 * to the nearest byte. */
	array_size = (bloomfilter->table_size + 7) / 8;

	/* Copy into the buffer of the calling routine. */
	memcpy(array, bloomfilter->table, array_size);
}","(func $bloom_filter_read (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 5
    i32.load offset=8
    local.set 6
    i32.const 7
    local.set 7
    local.get 6
    local.get 7
    i32.add
    local.set 8
    i32.const 3
    local.set 9
    local.get 8
    local.get 9
    i32.shr_u
    local.set 10
    local.get 4
    local.get 10
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 11
    local.get 4
    i32.load offset=12
    local.set 12
    local.get 12
    i32.load offset=4
    local.set 13
    local.get 4
    i32.load offset=4
    local.set 14
    local.get 14
    i32.eqz
    local.set 15
    block  ;; label = @1
      local.get 15
      br_if 0 (;@1;)
      local.get 11
      local.get 13
      local.get 14
      memory.copy
    end
    return)"
bloom_filter_load,"BloomFilter *bloomfilter, unsigned char *array",Copy into the buffer of the calling routine.,null,"
void bloom_filter_load(BloomFilter *bloomfilter, unsigned char *array)
{
	unsigned int array_size;

	/* The table is an array of bits, packed into bytes.  Round up
	 * to the nearest byte. */
	array_size = (bloomfilter->table_size + 7) / 8;

	/* Copy from the buffer of the calling routine. */
	memcpy(bloomfilter->table, array, array_size);
}","(func $bloom_filter_load (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 5
    i32.load offset=8
    local.set 6
    i32.const 7
    local.set 7
    local.get 6
    local.get 7
    i32.add
    local.set 8
    i32.const 3
    local.set 9
    local.get 8
    local.get 9
    i32.shr_u
    local.set 10
    local.get 4
    local.get 10
    i32.store offset=4
    local.get 4
    i32.load offset=12
    local.set 11
    local.get 11
    i32.load offset=4
    local.set 12
    local.get 4
    i32.load offset=8
    local.set 13
    local.get 4
    i32.load offset=4
    local.set 14
    local.get 14
    i32.eqz
    local.set 15
    block  ;; label = @1
      local.get 15
      br_if 0 (;@1;)
      local.get 12
      local.get 13
      local.get 14
      memory.copy
    end
    return)"
int_equal,"void *vlocation1, void *vlocation2",Comparison functions for a pointer to an integer,*location1 == *location2,"
int int_equal(void *vlocation1, void *vlocation2)
{
	int *location1;
	int *location2;

	location1 = (int *) vlocation1;
	location2 = (int *) vlocation2;

	return *location1 == *location2;
}","(func $int_equal (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 4
    local.get 6
    i32.store
    local.get 4
    i32.load offset=4
    local.set 7
    local.get 7
    i32.load
    local.set 8
    local.get 4
    i32.load
    local.set 9
    local.get 9
    i32.load
    local.set 10
    local.get 8
    local.get 10
    i32.eq
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.and
    local.set 13
    local.get 13
    return)"
int_compare,"void *vlocation1, void *vlocation2","Compares two values using the provided comparison callback.
Returns a negative, zero, or positive result to indicate ordering.",-1 | 1 | 0,"
int int_compare(void *vlocation1, void *vlocation2)
{
	int *location1;
	int *location2;

	location1 = (int *) vlocation1;
	location2 = (int *) vlocation2;

	if (*location1 < *location2) {
		return -1;
	} else if (*location1 > *location2) {
		return 1;
	} else {
		return 0;
	}
}","(func $int_compare (type 0)))
  (import ""env"" ""binomial_heap_new"" (func $binomial_heap_new (type 0)))
  (import ""env"" ""binomial_heap_free"" (func $binomial_heap_free (type 1)))
  (import ""env"" ""alloc_test_set_limit"" (func $alloc_test_set_limit (type 1)))
  (import ""env"" ""__assert_fail"" (func $__assert_fail (type 2)))
  (import ""env"" ""binomial_heap_insert"" (func $binomial_heap_insert (type 0)))
  (import ""env"" ""binomial_heap_num_entries"" (func $binomial_heap_num_entries (type 3)))
  (import ""env"" ""binomial_heap_pop"" (func $binomial_heap_pop (type 3)))
  (import ""env"" ""run_tests"" (func $run_tests (type 1)))"
pointer_equal,"void *location1, void *location2",Comparison functions for a generic void pointer,location1 == location2,"
int pointer_equal(void *location1, void *location2)
{
	return location1 == location2;
}","(func $pointer_equal (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    local.get 9
    return)"
pointer_compare,"void *location1, void *location2","Compares two values using the provided comparison callback.
Returns a negative, zero, or positive result to indicate ordering.",-1 | 1 | 0,"
int pointer_compare(void *location1, void *location2)
{
	if (location1 < location2) {
		return -1;
	} else if (location1 > location2) {
		return 1;
	} else {
		return 0;
	}
}","(func $pointer_compare (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    i32.load offset=4
    local.set 6
    local.get 5
    local.get 6
    i32.lt_u
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        local.get 9
        i32.eqz
        br_if 0 (;@2;)
        i32.const -1
        local.set 10
        local.get 4
        local.get 10
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=8
      local.set 11
      local.get 4
      i32.load offset=4
      local.set 12
      local.get 11
      local.get 12
      i32.gt_u
      local.set 13
      i32.const 1
      local.set 14
      local.get 13
      local.get 14
      i32.and
      local.set 15
      block  ;; label = @2
        local.get 15
        i32.eqz
        br_if 0 (;@2;)
        i32.const 1
        local.set 16
        local.get 4
        local.get 16
        i32.store offset=12
        br 1 (;@1;)
      end
      i32.const 0
      local.set 17
      local.get 4
      local.get 17
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 18
    local.get 18
    return)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""pointer_equal"" (func $pointer_equal))
  (export ""pointer_compare"" (func $pointer_compare))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
string_nocase_equal,"void *string1, void *string2","Compares two values using the provided comparison callback.
Returns a negative, zero, or positive result to indicate ordering.","string_nocase_compare((char *) string1, (char *) string2) == 0","int string_nocase_equal(void *string1, void *string2)
{
	return string_nocase_compare((char *) string1, (char *) string2) == 0;
}","(func $string_nocase_equal (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 5
    local.get 6
    call $string_nocase_compare
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.eq
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    i32.const 16
    local.set 12
    local.get 4
    local.get 12
    i32.add
    local.set 13
    local.get 13
    global.set $__stack_pointer
    local.get 11
    return)"
string_nocase_compare,"void *string1, void *string2","Compares two values using the provided comparison callback.
Returns a negative, zero, or positive result to indicate ordering.",-1 | 1 | 0,"int string_nocase_compare(void *string1, void *string2)
{
	char *p1;
	char *p2;
	int c1, c2;

	/* Iterate over each character in the strings */
	p1 = (char *) string1;
	p2 = (char *) string2;

	for (;;) {

		c1 = tolower(*p1);
		c2 = tolower(*p2);

		if (c1 != c2) {

			/* Strings are different */
			if (c1 < c2) {
				return -1;
			} else {
				return 1;
			}
		}

		/* End of string */
		if (c1 == '\0') {
			break;
		}

		/* Advance to the next character */
		++p1;
		++p2;
	}

	/* Reached the end of string and no difference found */
	return 0;
}","(func $string_nocase_compare (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=16
    local.get 4
    i32.load offset=20
    local.set 6
    local.get 4
    local.get 6
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=16
        local.set 7
        local.get 7
        i32.load8_u
        local.set 8
        i32.const 24
        local.set 9
        local.get 8
        local.get 9
        i32.shl
        local.set 10
        local.get 10
        local.get 9
        i32.shr_s
        local.set 11
        local.get 11
        call $tolower
        local.set 12
        local.get 4
        local.get 12
        i32.store offset=8
        local.get 4
        i32.load offset=12
        local.set 13
        local.get 13
        i32.load8_u
        local.set 14
        i32.const 24
        local.set 15
        local.get 14
        local.get 15
        i32.shl
        local.set 16
        local.get 16
        local.get 15
        i32.shr_s
        local.set 17
        local.get 17
        call $tolower
        local.set 18
        local.get 4
        local.get 18
        i32.store offset=4
        local.get 4
        i32.load offset=8
        local.set 19
        local.get 4
        i32.load offset=4
        local.set 20
        local.get 19
        local.get 20
        i32.ne
        local.set 21
        i32.const 1
        local.set 22
        local.get 21
        local.get 22
        i32.and
        local.set 23
        block  ;; label = @3
          local.get 23
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=8
          local.set 24
          local.get 4
          i32.load offset=4
          local.set 25
          local.get 24
          local.get 25
          i32.lt_s
          local.set 26
          i32.const 1
          local.set 27
          local.get 26
          local.get 27
          i32.and
          local.set 28
          block  ;; label = @4
            local.get 28
            i32.eqz
            br_if 0 (;@4;)
            i32.const -1
            local.set 29
            local.get 4
            local.get 29
            i32.store offset=28
            br 3 (;@1;)
          end
          i32.const 1
          local.set 30
          local.get 4
          local.get 30
          i32.store offset=28
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=8
        local.set 31
        block  ;; label = @3
          block  ;; label = @4
            local.get 31
            br_if 0 (;@4;)
            br 1 (;@3;)
          end
          local.get 4
          i32.load offset=16
          local.set 32
          i32.const 1
          local.set 33
          local.get 32
          local.get 33
          i32.add
          local.set 34
          local.get 4
          local.get 34
          i32.store offset=16
          local.get 4
          i32.load offset=12
          local.set 35
          i32.const 1
          local.set 36
          local.get 35
          local.get 36
          i32.add
          local.set 37
          local.get 4
          local.get 37
          i32.store offset=12
          br 1 (;@2;)
        end
      end
      i32.const 0
      local.set 38
      local.get 4
      local.get 38
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 39
    i32.const 32
    local.set 40
    local.get 4
    local.get 40
    i32.add
    local.set 41
    local.get 41
    global.set $__stack_pointer
    local.get 39
    return)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""string_equal"" (func $string_equal))
  (export ""string_compare"" (func $string_compare))
  (export ""string_nocase_equal"" (func $string_nocase_equal))
  (export ""string_nocase_compare"" (func $string_nocase_compare))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
hash_table_allocate_table,HashTable *hash_table,"Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",hash_table->table != NULL,"static int hash_table_allocate_table(HashTable *hash_table)
{
	unsigned int new_table_size;

	/* Determine the table size based on the current prime index.
	 * An attempt is made here to ensure sensible behavior if the
	 * maximum prime is exceeded, but in practice other things are
	 * likely to break long before that happens. */
	if (hash_table->prime_index < hash_table_num_primes) {
		new_table_size = hash_table_primes[hash_table->prime_index];
	} else {
		new_table_size = hash_table->entries * 10;
	}

	hash_table->table_size = new_table_size;

	/* Allocate the table and initialise to NULL for all entries */
	hash_table->table =
	    calloc(hash_table->table_size, sizeof(HashTableEntry *));

	return hash_table->table != NULL;
}","(func $hash_table_allocate_table (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=28
    local.set 5
    i32.const 24
    local.set 6
    local.get 5
    local.get 6
    i32.lt_u
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        local.get 9
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=12
        local.set 10
        local.get 10
        i32.load offset=28
        local.set 11
        i32.const 1024
        local.set 12
        i32.const 2
        local.set 13
        local.get 11
        local.get 13
        i32.shl
        local.set 14
        local.get 12
        local.get 14
        i32.add
        local.set 15
        local.get 15
        i32.load
        local.set 16
        local.get 3
        local.get 16
        i32.store offset=8
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 17
      local.get 17
      i32.load offset=24
      local.set 18
      i32.const 10
      local.set 19
      local.get 18
      local.get 19
      i32.mul
      local.set 20
      local.get 3
      local.get 20
      i32.store offset=8
    end
    local.get 3
    i32.load offset=8
    local.set 21
    local.get 3
    i32.load offset=12
    local.set 22
    local.get 22
    local.get 21
    i32.store offset=4
    local.get 3
    i32.load offset=12
    local.set 23
    local.get 23
    i32.load offset=4
    local.set 24
    i32.const 4
    local.set 25
    local.get 24
    local.get 25
    call $calloc
    local.set 26
    local.get 3
    i32.load offset=12
    local.set 27
    local.get 27
    local.get 26
    i32.store
    local.get 3
    i32.load offset=12
    local.set 28
    local.get 28
    i32.load
    local.set 29
    i32.const 0
    local.set 30
    local.get 29
    local.get 30
    i32.ne
    local.set 31
    i32.const 1
    local.set 32
    local.get 31
    local.get 32
    i32.and
    local.set 33
    i32.const 16
    local.set 34
    local.get 3
    local.get 34
    i32.add
    local.set 35
    local.get 35
    global.set $__stack_pointer
    local.get 33
    return)"
hash_table_free_entry,"HashTable *hash_table, HashTableEntry *entry","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"static void hash_table_free_entry(HashTable *hash_table, HashTableEntry *entry)
{
	HashTablePair *pair;

	pair = &(entry->pair);

	/* If there is a function registered for freeing keys, use it to free
	 * the key */
	if (hash_table->key_free_func != NULL) {
		hash_table->key_free_func(pair->key);
	}

	/* Likewise with the value */
	if (hash_table->value_free_func != NULL) {
		hash_table->value_free_func(pair->value);
	}

	/* Free the data structure */
	free(entry);
}","(func $hash_table_free_entry (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    local.get 4
    i32.load offset=12
    local.set 6
    local.get 6
    i32.load offset=16
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.ne
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      local.get 11
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=12
      local.set 12
      local.get 12
      i32.load offset=16
      local.set 13
      local.get 4
      i32.load offset=4
      local.set 14
      local.get 14
      i32.load
      local.set 15
      local.get 15
      local.get 13
      call_indirect (type 0)
    end
    local.get 4
    i32.load offset=12
    local.set 16
    local.get 16
    i32.load offset=20
    local.set 17
    i32.const 0
    local.set 18
    local.get 17
    local.get 18
    i32.ne
    local.set 19
    i32.const 1
    local.set 20
    local.get 19
    local.get 20
    i32.and
    local.set 21
    block  ;; label = @1
      local.get 21
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=12
      local.set 22
      local.get 22
      i32.load offset=20
      local.set 23
      local.get 4
      i32.load offset=4
      local.set 24
      local.get 24
      i32.load offset=4
      local.set 25
      local.get 25
      local.get 23
      call_indirect (type 0)
    end
    local.get 4
    i32.load offset=8
    local.set 26
    local.get 26
    call $free
    i32.const 16
    local.set 27
    local.get 4
    local.get 27
    i32.add
    local.set 28
    local.get 28
    global.set $__stack_pointer
    return)"
hash_table_free,HashTable *hash_table,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void hash_table_free(HashTable *hash_table)
{
	HashTableEntry *rover;
	HashTableEntry *next;
	unsigned int i;

	/* Free all entries in all chains */
	for (i = 0; i < hash_table->table_size; ++i) {
		rover = hash_table->table[i];
		while (rover != NULL) {
			next = rover->next;
			hash_table_free_entry(hash_table, rover);
			rover = next;
		}
	}

	/* Free the table */
	free(hash_table->table);

	/* Free the hash table structure */
	free(hash_table);
}","(func $hash_table_free (type 0) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const 0
    local.set 4
    local.get 3
    local.get 4
    i32.store
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load
        local.set 5
        local.get 3
        i32.load offset=12
        local.set 6
        local.get 6
        i32.load offset=4
        local.set 7
        local.get 5
        local.get 7
        i32.lt_u
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=12
        local.set 11
        local.get 11
        i32.load
        local.set 12
        local.get 3
        i32.load
        local.set 13
        i32.const 2
        local.set 14
        local.get 13
        local.get 14
        i32.shl
        local.set 15
        local.get 12
        local.get 15
        i32.add
        local.set 16
        local.get 16
        i32.load
        local.set 17
        local.get 3
        local.get 17
        i32.store offset=8
        block  ;; label = @3
          loop  ;; label = @4
            local.get 3
            i32.load offset=8
            local.set 18
            i32.const 0
            local.set 19
            local.get 18
            local.get 19
            i32.ne
            local.set 20
            i32.const 1
            local.set 21
            local.get 20
            local.get 21
            i32.and
            local.set 22
            local.get 22
            i32.eqz
            br_if 1 (;@3;)
            local.get 3
            i32.load offset=8
            local.set 23
            local.get 23
            i32.load offset=8
            local.set 24
            local.get 3
            local.get 24
            i32.store offset=4
            local.get 3
            i32.load offset=12
            local.set 25
            local.get 3
            i32.load offset=8
            local.set 26
            local.get 25
            local.get 26
            call $hash_table_free_entry
            local.get 3
            i32.load offset=4
            local.set 27
            local.get 3
            local.get 27
            i32.store offset=8
            br 0 (;@4;)
          end
        end
        local.get 3
        i32.load
        local.set 28
        i32.const 1
        local.set 29
        local.get 28
        local.get 29
        i32.add
        local.set 30
        local.get 3
        local.get 30
        i32.store
        br 0 (;@2;)
      end
    end
    local.get 3
    i32.load offset=12
    local.set 31
    local.get 31
    i32.load
    local.set 32
    local.get 32
    call $free
    local.get 3
    i32.load offset=12
    local.set 33
    local.get 33
    call $free
    i32.const 16
    local.set 34
    local.get 3
    local.get 34
    i32.add
    local.set 35
    local.get 35
    global.set $__stack_pointer
    return)"
hash_table_register_free_functions,"HashTable *hash_table, HashTableKeyFreeFunc key_free_func, HashTableValueFreeFunc value_free_func",Free the hash table structure,null,"
void hash_table_register_free_functions(HashTable *hash_table,
                                        HashTableKeyFreeFunc key_free_func,
                                        HashTableValueFreeFunc value_free_func)
{
	hash_table->key_free_func = key_free_func;
	hash_table->value_free_func = value_free_func;
}","(func $hash_table_register_free_functions (type 5) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    local.get 0
    i32.store offset=12
    local.get 5
    local.get 1
    i32.store offset=8
    local.get 5
    local.get 2
    i32.store offset=4
    local.get 5
    i32.load offset=8
    local.set 6
    local.get 5
    i32.load offset=12
    local.set 7
    local.get 7
    local.get 6
    i32.store offset=16
    local.get 5
    i32.load offset=4
    local.set 8
    local.get 5
    i32.load offset=12
    local.set 9
    local.get 9
    local.get 8
    i32.store offset=20
    return)"
hash_table_enlarge,HashTable *hash_table,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",0 | 1,"
static int hash_table_enlarge(HashTable *hash_table)
{
	HashTableEntry **old_table;
	unsigned int old_table_size;
	unsigned int old_prime_index;
	HashTableEntry *rover;
	HashTablePair *pair;
	HashTableEntry *next;
	unsigned int index;
	unsigned int i;

	/* Store a copy of the old table */
	old_table = hash_table->table;
	old_table_size = hash_table->table_size;
	old_prime_index = hash_table->prime_index;

	/* Allocate a new, larger table */
	++hash_table->prime_index;

	if (!hash_table_allocate_table(hash_table)) {

		/* Failed to allocate the new table */
		hash_table->table = old_table;
		hash_table->table_size = old_table_size;
		hash_table->prime_index = old_prime_index;

		return 0;
	}

	/* Link all entries from all chains into the new table */
	for (i = 0; i < old_table_size; ++i) {
		rover = old_table[i];

		while (rover != NULL) {
			next = rover->next;

			/* Fetch rover HashTablePair */
			pair = &(rover->pair);

			/* Find the index into the new table */
			index = hash_table->hash_func(pair->key) %
			        hash_table->table_size;

			/* Link this entry into the chain */
			rover->next = hash_table->table[index];
			hash_table->table[index] = rover;

			/* Advance to next in the chain */
			rover = next;
		}
	}

	/* Free the old table */
	free(old_table);

	return 1;
}","(func $hash_table_enlarge (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 48
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=40
    local.get 3
    i32.load offset=40
    local.set 4
    local.get 4
    i32.load
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=36
    local.get 3
    i32.load offset=40
    local.set 6
    local.get 6
    i32.load offset=4
    local.set 7
    local.get 3
    local.get 7
    i32.store offset=32
    local.get 3
    i32.load offset=40
    local.set 8
    local.get 8
    i32.load offset=28
    local.set 9
    local.get 3
    local.get 9
    i32.store offset=28
    local.get 3
    i32.load offset=40
    local.set 10
    local.get 10
    i32.load offset=28
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.add
    local.set 13
    local.get 10
    local.get 13
    i32.store offset=28
    local.get 3
    i32.load offset=40
    local.set 14
    local.get 14
    call $hash_table_allocate_table
    local.set 15
    block  ;; label = @1
      block  ;; label = @2
        local.get 15
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=36
        local.set 16
        local.get 3
        i32.load offset=40
        local.set 17
        local.get 17
        local.get 16
        i32.store
        local.get 3
        i32.load offset=32
        local.set 18
        local.get 3
        i32.load offset=40
        local.set 19
        local.get 19
        local.get 18
        i32.store offset=4
        local.get 3
        i32.load offset=28
        local.set 20
        local.get 3
        i32.load offset=40
        local.set 21
        local.get 21
        local.get 20
        i32.store offset=28
        i32.const 0
        local.set 22
        local.get 3
        local.get 22
        i32.store offset=44
        br 1 (;@1;)
      end
      i32.const 0
      local.set 23
      local.get 3
      local.get 23
      i32.store offset=8
      block  ;; label = @2
        loop  ;; label = @3
          local.get 3
          i32.load offset=8
          local.set 24
          local.get 3
          i32.load offset=32
          local.set 25
          local.get 24
          local.get 25
          i32.lt_u
          local.set 26
          i32.const 1
          local.set 27
          local.get 26
          local.get 27
          i32.and
          local.set 28
          local.get 28
          i32.eqz
          br_if 1 (;@2;)
          local.get 3
          i32.load offset=36
          local.set 29
          local.get 3
          i32.load offset=8
          local.set 30
          i32.const 2
          local.set 31
          local.get 30
          local.get 31
          i32.shl
          local.set 32
          local.get 29
          local.get 32
          i32.add
          local.set 33
          local.get 33
          i32.load
          local.set 34
          local.get 3
          local.get 34
          i32.store offset=24
          block  ;; label = @4
            loop  ;; label = @5
              local.get 3
              i32.load offset=24
              local.set 35
              i32.const 0
              local.set 36
              local.get 35
              local.get 36
              i32.ne
              local.set 37
              i32.const 1
              local.set 38
              local.get 37
              local.get 38
              i32.and
              local.set 39
              local.get 39
              i32.eqz
              br_if 1 (;@4;)
              local.get 3
              i32.load offset=24
              local.set 40
              local.get 40
              i32.load offset=8
              local.set 41
              local.get 3
              local.get 41
              i32.store offset=16
              local.get 3
              i32.load offset=24
              local.set 42
              local.get 3
              local.get 42
              i32.store offset=20
              local.get 3
              i32.load offset=40
              local.set 43
              local.get 43
              i32.load offset=8
              local.set 44
              local.get 3
              i32.load offset=20
              local.set 45
              local.get 45
              i32.load
              local.set 46
              local.get 46
              local.get 44
              call_indirect (type 1)
              local.set 47
              local.get 3
              i32.load offset=40
              local.set 48
              local.get 48
              i32.load offset=4
              local.set 49
              local.get 47
              local.get 49
              i32.rem_u
              local.set 50
              local.get 3
              local.get 50
              i32.store offset=12
              local.get 3
              i32.load offset=40
              local.set 51
              local.get 51
              i32.load
              local.set 52
              local.get 3
              i32.load offset=12
              local.set 53
              i32.const 2
              local.set 54
              local.get 53
              local.get 54
              i32.shl
              local.set 55
              local.get 52
              local.get 55
              i32.add
              local.set 56
              local.get 56
              i32.load
              local.set 57
              local.get 3
              i32.load offset=24
              local.set 58
              local.get 58
              local.get 57
              i32.store offset=8
              local.get 3
              i32.load offset=24
              local.set 59
              local.get 3
              i32.load offset=40
              local.set 60
              local.get 60
              i32.load
              local.set 61
              local.get 3
              i32.load offset=12
              local.set 62
              i32.const 2
              local.set 63
              local.get 62
              local.get 63
              i32.shl
              local.set 64
              local.get 61
              local.get 64
              i32.add
              local.set 65
              local.get 65
              local.get 59
              i32.store
              local.get 3
              i32.load offset=16
              local.set 66
              local.get 3
              local.get 66
              i32.store offset=24
              br 0 (;@5;)
            end
          end
          local.get 3
          i32.load offset=8
          local.set 67
          i32.const 1
          local.set 68
          local.get 67
          local.get 68
          i32.add
          local.set 69
          local.get 3
          local.get 69
          i32.store offset=8
          br 0 (;@3;)
        end
      end
      local.get 3
      i32.load offset=36
      local.set 70
      local.get 70
      call $free
      i32.const 1
      local.set 71
      local.get 3
      local.get 71
      i32.store offset=44
    end
    local.get 3
    i32.load offset=44
    local.set 72
    i32.const 48
    local.set 73
    local.get 3
    local.get 73
    i32.add
    local.set 74
    local.get 74
    global.set $__stack_pointer
    local.get 72
    return)"
hash_table_insert,"HashTable *hash_table, HashTableKey key, HashTableValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | 1 | pair->value | hash_table_null_value | result | hash_table->entries | iterator->next_entry != NULL | pair,"
int hash_table_insert(HashTable *hash_table, HashTableKey key,
                      HashTableValue value)
{
	HashTableEntry *rover;
	HashTablePair *pair;
	HashTableEntry *newentry;
	unsigned int index;

	/* If there are too many items in the table with respect to the table
	 * size, the number of hash collisions increases and performance
	 * decreases. Enlarge the table size to prevent this happening */
	if ((hash_table->entries * 3) / hash_table->table_size > 0) {

		/* Table is more than 1/3 full */
		if (!hash_table_enlarge(hash_table)) {

			/* Failed to enlarge the table */
			return 0;
		}
	}

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Traverse the chain at this location and look for an existing
	 * entry with the same key */
	rover = hash_table->table[index];

	while (rover != NULL) {

		/* Fetch rover's HashTablePair entry */
		pair = &(rover->pair);

		if (hash_table->equal_func(pair->key, key) != 0) {

			/* Same key: overwrite this entry with new data */
			/* If there is a value free function, free the old data
			 * before adding in the new data */
			if (hash_table->value_free_func != NULL) {
				hash_table->value_free_func(pair->value);
			}

			/* Same with the key: use the new key value and free
			 * the old one */
			if (hash_table->key_free_func != NULL) {
				hash_table->key_free_func(pair->key);
			}

			pair->key = key;
			pair->value = value;

			/* Finished */
			return 1;
		}

		rover = rover->next;
	}

	/* Not in the hash table yet.  Create a new entry */
	newentry = (HashTableEntry *) malloc(sizeof(HashTableEntry));

	if (newentry == NULL) {
		return 0;
	}

	newentry->pair.key = key;
	newentry->pair.value = value;

	/* Link into the list */
	newentry->next = hash_table->table[index];
	hash_table->table[index] = newentry;

	/* Maintain the count of the number of entries */
	++hash_table->entries;

	/* Added successfully */
	return 1;
}

HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry *rover;
	HashTablePair *pair;
	unsigned int index;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Walk the chain at this index until the corresponding entry is
	 * found */
	rover = hash_table->table[index];

	while (rover != NULL) {
		pair = &(rover->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* Found the entry.  Return the data. */
			return pair->value;
		}

		rover = rover->next;
	}

	/* Not found */
	return hash_table_null_value;
}

int hash_table_remove(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry **rover;
	HashTableEntry *entry;
	HashTablePair *pair;
	unsigned int index;
	int result;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Rover points at the pointer which points at the current entry
	 * in the chain being inspected.  ie. the entry in the table, or
	 * the ""next"" pointer of the previous entry in the chain.  This
	 * allows us to unlink the entry when we find it. */
	result = 0;
	rover = &hash_table->table[index];

	while (*rover != NULL) {

		pair = &((*rover)->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* This is the entry to remove */
			entry = *rover;

			/* Unlink from the list */
			*rover = entry->next;

			/* Destroy the entry structure */
			hash_table_free_entry(hash_table, entry);

			/* Track count of entries */
			--hash_table->entries;

			result = 1;

			break;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	return result;
}

unsigned int hash_table_num_entries(HashTable *hash_table)
{
	return hash_table->entries;
}

void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)
{
	unsigned int chain;

	iterator->hash_table = hash_table;

	/* Default value of next if no entries are found. */
	iterator->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < hash_table->table_size; ++chain) {

		if (hash_table->table[chain] != NULL) {
			iterator->next_entry = hash_table->table[chain];
			iterator->next_chain = chain;
			break;
		}
	}
}

int hash_table_iter_has_more(HashTableIterator *iterator)
{
	return iterator->next_entry != NULL;
}

HashTablePair hash_table_iter_next(HashTableIterator *iterator)
{
	HashTableEntry *current_entry;
	HashTable *hash_table;
	HashTablePair pair = {HASH_TABLE_KEY_NULL, HASH_TABLE_NULL};
	unsigned int chain;

	hash_table = iterator->hash_table;

	if (iterator->next_entry == NULL) {
		return pair;
	}

	/* Result is immediately available */
	current_entry = iterator->next_entry;
	pair = current_entry->pair;

	/* Find the next entry */
	if (current_entry->next != NULL) {

		/* Next entry in current chain */
		iterator->next_entry = current_entry->next;

	} else {

		/* None left in this chain, so advance to the next chain */
		chain = iterator->next_chain + 1;

		/* Default value if no next chain found */
		iterator->next_entry = NULL;

		while (chain < hash_table->table_size) {

			/* Is there anything in this chain? */
			if (hash_table->table[chain] != NULL) {
				iterator->next_entry = hash_table->table[chain];
				break;
			}

			/* Try the next chain */
			++chain;
		}

		iterator->next_chain = chain;
	}

	return pair;
}
","(func $hash_table_insert (type 6) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 32
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=24
    local.get 5
    local.get 1
    i32.store offset=20
    local.get 5
    local.get 2
    i32.store offset=16
    local.get 5
    i32.load offset=24
    local.set 6
    local.get 6
    i32.load offset=24
    local.set 7
    i32.const 3
    local.set 8
    local.get 7
    local.get 8
    i32.mul
    local.set 9
    local.get 5
    i32.load offset=24
    local.set 10
    local.get 10
    i32.load offset=4
    local.set 11
    local.get 9
    local.get 11
    i32.div_u
    local.set 12
    i32.const 0
    local.set 13
    local.get 12
    local.get 13
    i32.gt_u
    local.set 14
    i32.const 1
    local.set 15
    local.get 14
    local.get 15
    i32.and
    local.set 16
    block  ;; label = @1
      block  ;; label = @2
        local.get 16
        i32.eqz
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=24
        local.set 17
        local.get 17
        call $hash_table_enlarge
        local.set 18
        block  ;; label = @3
          local.get 18
          br_if 0 (;@3;)
          i32.const 0
          local.set 19
          local.get 5
          local.get 19
          i32.store offset=28
          br 2 (;@1;)
        end
      end
      local.get 5
      i32.load offset=24
      local.set 20
      local.get 20
      i32.load offset=8
      local.set 21
      local.get 5
      i32.load offset=20
      local.set 22
      local.get 22
      local.get 21
      call_indirect (type 1)
      local.set 23
      local.get 5
      i32.load offset=24
      local.set 24
      local.get 24
      i32.load offset=4
      local.set 25
      local.get 23
      local.get 25
      i32.rem_u
      local.set 26
      local.get 5
      local.get 26
      i32.store
      local.get 5
      i32.load offset=24
      local.set 27
      local.get 27
      i32.load
      local.set 28
      local.get 5
      i32.load
      local.set 29
      i32.const 2
      local.set 30
      local.get 29
      local.get 30
      i32.shl
      local.set 31
      local.get 28
      local.get 31
      i32.add
      local.set 32
      local.get 32
      i32.load
      local.set 33
      local.get 5
      local.get 33
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 5
          i32.load offset=12
          local.set 34
          i32.const 0
          local.set 35
          local.get 34
          local.get 35
          i32.ne
          local.set 36
          i32.const 1
          local.set 37
          local.get 36
          local.get 37
          i32.and
          local.set 38
          local.get 38
          i32.eqz
          br_if 1 (;@2;)
          local.get 5
          i32.load offset=12
          local.set 39
          local.get 5
          local.get 39
          i32.store offset=8
          local.get 5
          i32.load offset=24
          local.set 40
          local.get 40
          i32.load offset=12
          local.set 41
          local.get 5
          i32.load offset=8
          local.set 42
          local.get 42
          i32.load
          local.set 43
          local.get 5
          i32.load offset=20
          local.set 44
          local.get 43
          local.get 44
          local.get 41
          call_indirect (type 2)
          local.set 45
          block  ;; label = @4
            local.get 45
            i32.eqz
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=24
            local.set 46
            local.get 46
            i32.load offset=20
            local.set 47
            i32.const 0
            local.set 48
            local.get 47
            local.get 48
            i32.ne
            local.set 49
            i32.const 1
            local.set 50
            local.get 49
            local.get 50
            i32.and
            local.set 51
            block  ;; label = @5
              local.get 51
              i32.eqz
              br_if 0 (;@5;)
              local.get 5
              i32.load offset=24
              local.set 52
              local.get 52
              i32.load offset=20
              local.set 53
              local.get 5
              i32.load offset=8
              local.set 54
              local.get 54
              i32.load offset=4
              local.set 55
              local.get 55
              local.get 53
              call_indirect (type 0)
            end
            local.get 5
            i32.load offset=24
            local.set 56
            local.get 56
            i32.load offset=16
            local.set 57
            i32.const 0
            local.set 58
            local.get 57
            local.get 58
            i32.ne
            local.set 59
            i32.const 1
            local.set 60
            local.get 59
            local.get 60
            i32.and
            local.set 61
            block  ;; label = @5
              local.get 61
              i32.eqz
              br_if 0 (;@5;)
              local.get 5
              i32.load offset=24
              local.set 62
              local.get 62
              i32.load offset=16
              local.set 63
              local.get 5
              i32.load offset=8
              local.set 64
              local.get 64
              i32.load
              local.set 65
              local.get 65
              local.get 63
              call_indirect (type 0)
            end
            local.get 5
            i32.load offset=20
            local.set 66
            local.get 5
            i32.load offset=8
            local.set 67
            local.get 67
            local.get 66
            i32.store
            local.get 5
            i32.load offset=16
            local.set 68
            local.get 5
            i32.load offset=8
            local.set 69
            local.get 69
            local.get 68
            i32.store offset=4
            i32.const 1
            local.set 70
            local.get 5
            local.get 70
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 5
          i32.load offset=12
          local.set 71
          local.get 71
          i32.load offset=8
          local.set 72
          local.get 5
          local.get 72
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      i32.const 12
      local.set 73
      local.get 73
      call $malloc
      local.set 74
      local.get 5
      local.get 74
      i32.store offset=4
      local.get 5
      i32.load offset=4
      local.set 75
      i32.const 0
      local.set 76
      local.get 75
      local.get 76
      i32.eq
      local.set 77
      i32.const 1
      local.set 78
      local.get 77
      local.get 78
      i32.and
      local.set 79
      block  ;; label = @2
        local.get 79
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 80
        local.get 5
        local.get 80
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=20
      local.set 81
      local.get 5
      i32.load offset=4
      local.set 82
      local.get 82
      local.get 81
      i32.store
      local.get 5
      i32.load offset=16
      local.set 83
      local.get 5
      i32.load offset=4
      local.set 84
      local.get 84
      local.get 83
      i32.store offset=4
      local.get 5
      i32.load offset=24
      local.set 85
      local.get 85
      i32.load
      local.set 86
      local.get 5
      i32.load
      local.set 87
      i32.const 2
      local.set 88
      local.get 87
      local.get 88
      i32.shl
      local.set 89
      local.get 86
      local.get 89
      i32.add
      local.set 90
      local.get 90
      i32.load
      local.set 91
      local.get 5
      i32.load offset=4
      local.set 92
      local.get 92
      local.get 91
      i32.store offset=8
      local.get 5
      i32.load offset=4
      local.set 93
      local.get 5
      i32.load offset=24
      local.set 94
      local.get 94
      i32.load
      local.set 95
      local.get 5
      i32.load
      local.set 96
      i32.const 2
      local.set 97
      local.get 96
      local.get 97
      i32.shl
      local.set 98
      local.get 95
      local.get 98
      i32.add
      local.set 99
      local.get 99
      local.get 93
      i32.store
      local.get 5
      i32.load offset=24
      local.set 100
      local.get 100
      i32.load offset=24
      local.set 101
      i32.const 1
      local.set 102
      local.get 101
      local.get 102
      i32.add
      local.set 103
      local.get 100
      local.get 103
      i32.store offset=24
      i32.const 1
      local.set 104
      local.get 5
      local.get 104
      i32.store offset=28
    end
    local.get 5
    i32.load offset=28
    local.set 105
    i32.const 32
    local.set 106
    local.get 5
    local.get 106
    i32.add
    local.set 107
    local.get 107
    global.set $__stack_pointer
    local.get 105
    return)"
hash_table_remove,"HashTable *hash_table, HashTableKey key",Not found,result,"
int hash_table_remove(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry **rover;
	HashTableEntry *entry;
	HashTablePair *pair;
	unsigned int index;
	int result;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Rover points at the pointer which points at the current entry
	 * in the chain being inspected.  ie. the entry in the table, or
	 * the ""next"" pointer of the previous entry in the chain.  This
	 * allows us to unlink the entry when we find it. */
	result = 0;
	rover = &hash_table->table[index];

	while (*rover != NULL) {

		pair = &((*rover)->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* This is the entry to remove */
			entry = *rover;

			/* Unlink from the list */
			*rover = entry->next;

			/* Destroy the entry structure */
			hash_table_free_entry(hash_table, entry);

			/* Track count of entries */
			--hash_table->entries;

			result = 1;

			break;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	return result;
}","(func $hash_table_remove (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=28
    local.get 4
    local.get 1
    i32.store offset=24
    local.get 4
    i32.load offset=28
    local.set 5
    local.get 5
    i32.load offset=8
    local.set 6
    local.get 4
    i32.load offset=24
    local.set 7
    local.get 7
    local.get 6
    call_indirect (type 1)
    local.set 8
    local.get 4
    i32.load offset=28
    local.set 9
    local.get 9
    i32.load offset=4
    local.set 10
    local.get 8
    local.get 10
    i32.rem_u
    local.set 11
    local.get 4
    local.get 11
    i32.store offset=8
    i32.const 0
    local.set 12
    local.get 4
    local.get 12
    i32.store offset=4
    local.get 4
    i32.load offset=28
    local.set 13
    local.get 13
    i32.load
    local.set 14
    local.get 4
    i32.load offset=8
    local.set 15
    i32.const 2
    local.set 16
    local.get 15
    local.get 16
    i32.shl
    local.set 17
    local.get 14
    local.get 17
    i32.add
    local.set 18
    local.get 4
    local.get 18
    i32.store offset=20
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=20
        local.set 19
        local.get 19
        i32.load
        local.set 20
        i32.const 0
        local.set 21
        local.get 20
        local.get 21
        i32.ne
        local.set 22
        i32.const 1
        local.set 23
        local.get 22
        local.get 23
        i32.and
        local.set 24
        local.get 24
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=20
        local.set 25
        local.get 25
        i32.load
        local.set 26
        local.get 4
        local.get 26
        i32.store offset=12
        local.get 4
        i32.load offset=28
        local.set 27
        local.get 27
        i32.load offset=12
        local.set 28
        local.get 4
        i32.load offset=24
        local.set 29
        local.get 4
        i32.load offset=12
        local.set 30
        local.get 30
        i32.load
        local.set 31
        local.get 29
        local.get 31
        local.get 28
        call_indirect (type 2)
        local.set 32
        block  ;; label = @3
          local.get 32
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=20
          local.set 33
          local.get 33
          i32.load
          local.set 34
          local.get 4
          local.get 34
          i32.store offset=16
          local.get 4
          i32.load offset=16
          local.set 35
          local.get 35
          i32.load offset=8
          local.set 36
          local.get 4
          i32.load offset=20
          local.set 37
          local.get 37
          local.get 36
          i32.store
          local.get 4
          i32.load offset=28
          local.set 38
          local.get 4
          i32.load offset=16
          local.set 39
          local.get 38
          local.get 39
          call $hash_table_free_entry
          local.get 4
          i32.load offset=28
          local.set 40
          local.get 40
          i32.load offset=24
          local.set 41
          i32.const -1
          local.set 42
          local.get 41
          local.get 42
          i32.add
          local.set 43
          local.get 40
          local.get 43
          i32.store offset=24
          i32.const 1
          local.set 44
          local.get 4
          local.get 44
          i32.store offset=4
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=20
        local.set 45
        local.get 45
        i32.load
        local.set 46
        i32.const 8
        local.set 47
        local.get 46
        local.get 47
        i32.add
        local.set 48
        local.get 4
        local.get 48
        i32.store offset=20
        br 0 (;@2;)
      end
    end
    local.get 4
    i32.load offset=4
    local.set 49
    i32.const 32
    local.set 50
    local.get 4
    local.get 50
    i32.add
    local.set 51
    local.get 51
    global.set $__stack_pointer
    local.get 49
    return)"
hash_table_iterate,"HashTable *hash_table, HashTableIterator *iterator","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)
{
	unsigned int chain;

	iterator->hash_table = hash_table;

	/* Default value of next if no entries are found. */
	iterator->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < hash_table->table_size; ++chain) {

		if (hash_table->table[chain] != NULL) {
			iterator->next_entry = hash_table->table[chain];
			iterator->next_chain = chain;
			break;
		}
	}
}","(func $hash_table_iterate (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 6
    local.get 5
    i32.store
    local.get 4
    i32.load offset=8
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.store offset=4
    i32.const 0
    local.set 9
    local.get 4
    local.get 9
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=4
        local.set 10
        local.get 4
        i32.load offset=12
        local.set 11
        local.get 11
        i32.load offset=4
        local.set 12
        local.get 10
        local.get 12
        i32.lt_u
        local.set 13
        i32.const 1
        local.set 14
        local.get 13
        local.get 14
        i32.and
        local.set 15
        local.get 15
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=12
        local.set 16
        local.get 16
        i32.load
        local.set 17
        local.get 4
        i32.load offset=4
        local.set 18
        i32.const 2
        local.set 19
        local.get 18
        local.get 19
        i32.shl
        local.set 20
        local.get 17
        local.get 20
        i32.add
        local.set 21
        local.get 21
        i32.load
        local.set 22
        i32.const 0
        local.set 23
        local.get 22
        local.get 23
        i32.ne
        local.set 24
        i32.const 1
        local.set 25
        local.get 24
        local.get 25
        i32.and
        local.set 26
        block  ;; label = @3
          local.get 26
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=12
          local.set 27
          local.get 27
          i32.load
          local.set 28
          local.get 4
          i32.load offset=4
          local.set 29
          i32.const 2
          local.set 30
          local.get 29
          local.get 30
          i32.shl
          local.set 31
          local.get 28
          local.get 31
          i32.add
          local.set 32
          local.get 32
          i32.load
          local.set 33
          local.get 4
          i32.load offset=8
          local.set 34
          local.get 34
          local.get 33
          i32.store offset=4
          local.get 4
          i32.load offset=4
          local.set 35
          local.get 4
          i32.load offset=8
          local.set 36
          local.get 36
          local.get 35
          i32.store offset=8
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=4
        local.set 37
        i32.const 1
        local.set 38
        local.get 37
        local.get 38
        i32.add
        local.set 39
        local.get 4
        local.get 39
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    return)"
hash_table_iter_has_more,HashTableIterator *iterator,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",iterator->next_entry != NULL,"
int hash_table_iter_has_more(HashTableIterator *iterator)
{
	return iterator->next_entry != NULL;
}","(func $hash_table_iter_has_more (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.ne
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    local.get 9
    return)"
list_free,ListEntry *list,Null value that can be returned without creating a local variable,null,"
void list_free(ListEntry *list)
{
	ListEntry *entry;

	/* Iterate over each entry, freeing each list entry, until the
	 * end is reached */
	entry = list;

	while (entry != NULL) {
		ListEntry *next;

		next = entry->next;

		free(entry);

		entry = next;
	}
}","(func $list_free (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 3
    local.get 4
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load offset=8
        local.set 5
        i32.const 0
        local.set 6
        local.get 5
        local.get 6
        i32.ne
        local.set 7
        i32.const 1
        local.set 8
        local.get 7
        local.get 8
        i32.and
        local.set 9
        local.get 9
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=8
        local.set 10
        local.get 10
        i32.load offset=8
        local.set 11
        local.get 3
        local.get 11
        i32.store offset=4
        local.get 3
        i32.load offset=8
        local.set 12
        local.get 12
        call $free
        local.get 3
        i32.load offset=4
        local.set 13
        local.get 3
        local.get 13
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 14
    local.get 3
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    return)"
list_set_data,"ListEntry *listentry, ListValue value","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void list_set_data(ListEntry *listentry, ListValue value)
{
	if (listentry != NULL) {
		listentry->data = value;
	}
}","(func $list_set_data (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.ne
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      local.get 9
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=8
      local.set 10
      local.get 4
      i32.load offset=12
      local.set 11
      local.get 11
      local.get 10
      i32.store
    end
    return)"
list_remove_entry,"ListEntry **list, ListEntry *entry","Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",0 | 1 | entries_removed | NULL | *list | pivot | more_list_end | rover | *iter->prev_next != NULL | iter->current->next != NULL | list_null_value | iter->current->data,"
int list_remove_entry(ListEntry **list, ListEntry *entry)
{
	/* If the list is empty, or entry is NULL, always fail */
	if (list == NULL || *list == NULL || entry == NULL) {
		return 0;
	}

	/* Action to take is different if the entry is the first in the list */
	if (entry->prev == NULL) {

		/* Unlink the first entry and update the starting pointer */
		*list = entry->next;

		/* Update the second entry's prev pointer, if there is a second
		 * entry */
		if (entry->next != NULL) {
			entry->next->prev = NULL;
		}

	} else {

		/* This is not the first in the list, so we must have a
		 * previous entry.  Update its 'next' pointer to the new
		 * value */
		entry->prev->next = entry->next;

		/* If there is an entry following this one, update its 'prev'
		 * pointer to the new value */
		if (entry->next != NULL) {
			entry->next->prev = entry->prev;
		}
	}

	/* Free the list entry */
	free(entry);

	/* Operation successful */
	return 1;
}

unsigned int list_remove_data(ListEntry **list, ListEqualFunc callback,
                              ListValue data)
{
	unsigned int entries_removed;
	ListEntry *rover;
	ListEntry *next;

	if (list == NULL || callback == NULL) {
		return 0;
	}

	entries_removed = 0;

	/* Iterate over the entries in the list */
	rover = *list;

	while (rover != NULL) {

		next = rover->next;

		if (callback(rover->data, data)) {

			/* This data needs to be removed.  Unlink this entry
			 * from the list. */
			if (rover->prev == NULL) {

				/* This is the first entry in the list */
				*list = rover->next;
			} else {

				/* Point the previous entry at its new
				 * location */
				rover->prev->next = rover->next;
			}

			if (rover->next != NULL) {
				rover->next->prev = rover->prev;
			}

			/* Free the entry */
			free(rover);

			++entries_removed;
		}

		/* Advance to the next list entry */
		rover = next;
	}

	return entries_removed;
}

/* Function used internally for sorting.  Returns the last entry in the
 * new sorted list */
static ListEntry *list_sort_internal(ListEntry **list,
                                     ListCompareFunc compare_func)
{
	ListEntry *pivot;
	ListEntry *rover;
	ListEntry *less_list, *more_list;
	ListEntry *less_list_end, *more_list_end;

	if (list == NULL || compare_func == NULL) {
		return NULL;
	}

	/* If there are less than two entries in this list, it is
	 * already sorted */
	if (*list == NULL || (*list)->next == NULL) {
		return *list;
	}

	/* The first entry is the pivot */
	pivot = *list;

	/* Iterate over the list, starting from the second entry.  Sort
	 * all entries into the less and more lists based on comparisons
	 * with the pivot */
	less_list = NULL;
	more_list = NULL;
	rover = (*list)->next;

	while (rover != NULL) {
		ListEntry *next = rover->next;

		if (compare_func(rover->data, pivot->data) < 0) {

			/* Place this in the less list */
			rover->prev = NULL;
			rover->next = less_list;
			if (less_list != NULL) {
				less_list->prev = rover;
			}
			less_list = rover;

		} else {

			/* Place this in the more list */
			rover->prev = NULL;
			rover->next = more_list;
			if (more_list != NULL) {
				more_list->prev = rover;
			}
			more_list = rover;
		}

		rover = next;
	}

	/* Sort the sublists recursively */
	less_list_end = list_sort_internal(&less_list, compare_func);
	more_list_end = list_sort_internal(&more_list, compare_func);

	/* Create the new list starting from the less list */
	*list = less_list;

	/* Append the pivot to the end of the less list.  If the less list
	 * was empty, start from the pivot */
	if (less_list == NULL) {
		pivot->prev = NULL;
		*list = pivot;
	} else {
		pivot->prev = less_list_end;
		less_list_end->next = pivot;
	}

	/* Append the more list after the pivot */
	pivot->next = more_list;
	if (more_list != NULL) {
		more_list->prev = pivot;
	}

	/* Work out what the last entry in the list is.  If the more list was
	 * empty, the pivot was the last entry.  Otherwise, the end of the
	 * more list is the end of the total list. */
	if (more_list == NULL) {
		return pivot;
	} else {
		return more_list_end;
	}
}

void list_sort(ListEntry **list, ListCompareFunc compare_func)
{
	list_sort_internal(list, compare_func);
}

ListEntry *list_find_data(ListEntry *list, ListEqualFunc callback,
                          ListValue data)
{
	ListEntry *rover;

	/* Iterate over entries in the list until the data is found */
	for (rover = list; rover != NULL; rover = rover->next) {
		if (callback(rover->data, data) != 0) {
			return rover;
		}
	}

	/* Not found */
	return NULL;
}

void list_iterate(ListEntry **list, ListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}

int list_iter_has_more(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {
		/* The current entry as not been deleted since the last
		 * call to list_iter_next: there is a next entry if
		 * current->next is not NULL */
		return iter->current->next != NULL;
	}
}

ListValue list_iter_next(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we are reading the first entry, we have reached
		 * the end of the list, or the previous entry was removed.
		 * Get the next entry with iter->prev_next. */
		iter->current = *iter->prev_next;

	} else {

		/* Last value returned from list_iter_next was not deleted.
		 * Advance to the next entry. */
		iter->prev_next = &iter->current->next;
		iter->current = iter->current->next;
	}

	/* Have we reached the end of the list? */
	if (iter->current == NULL) {
		return list_null_value;
	} else {
		return iter->current->data;
	}
}

void list_iter_remove(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;

		if (iter->current->next != NULL) {
			iter->current->next->prev = iter->current->prev;
		}

		free(iter->current);
		iter->current = NULL;
	}
}
","(func $list_remove_entry (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 9
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=8
          local.set 10
          local.get 10
          i32.load
          local.set 11
          i32.const 0
          local.set 12
          local.get 11
          local.get 12
          i32.eq
          local.set 13
          i32.const 1
          local.set 14
          local.get 13
          local.get 14
          i32.and
          local.set 15
          local.get 15
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=4
          local.set 16
          i32.const 0
          local.set 17
          local.get 16
          local.get 17
          i32.eq
          local.set 18
          i32.const 1
          local.set 19
          local.get 18
          local.get 19
          i32.and
          local.set 20
          local.get 20
          i32.eqz
          br_if 1 (;@2;)
        end
        i32.const 0
        local.set 21
        local.get 4
        local.get 21
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=4
      local.set 22
      local.get 22
      i32.load offset=4
      local.set 23
      i32.const 0
      local.set 24
      local.get 23
      local.get 24
      i32.eq
      local.set 25
      i32.const 1
      local.set 26
      local.get 25
      local.get 26
      i32.and
      local.set 27
      block  ;; label = @2
        block  ;; label = @3
          local.get 27
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=4
          local.set 28
          local.get 28
          i32.load offset=8
          local.set 29
          local.get 4
          i32.load offset=8
          local.set 30
          local.get 30
          local.get 29
          i32.store
          local.get 4
          i32.load offset=4
          local.set 31
          local.get 31
          i32.load offset=8
          local.set 32
          i32.const 0
          local.set 33
          local.get 32
          local.get 33
          i32.ne
          local.set 34
          i32.const 1
          local.set 35
          local.get 34
          local.get 35
          i32.and
          local.set 36
          block  ;; label = @4
            local.get 36
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=4
            local.set 37
            local.get 37
            i32.load offset=8
            local.set 38
            i32.const 0
            local.set 39
            local.get 38
            local.get 39
            i32.store offset=4
          end
          br 1 (;@2;)
        end
        local.get 4
        i32.load offset=4
        local.set 40
        local.get 40
        i32.load offset=8
        local.set 41
        local.get 4
        i32.load offset=4
        local.set 42
        local.get 42
        i32.load offset=4
        local.set 43
        local.get 43
        local.get 41
        i32.store offset=8
        local.get 4
        i32.load offset=4
        local.set 44
        local.get 44
        i32.load offset=8
        local.set 45
        i32.const 0
        local.set 46
        local.get 45
        local.get 46
        i32.ne
        local.set 47
        i32.const 1
        local.set 48
        local.get 47
        local.get 48
        i32.and
        local.set 49
        block  ;; label = @3
          local.get 49
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=4
          local.set 50
          local.get 50
          i32.load offset=4
          local.set 51
          local.get 4
          i32.load offset=4
          local.set 52
          local.get 52
          i32.load offset=8
          local.set 53
          local.get 53
          local.get 51
          i32.store offset=4
        end
      end
      local.get 4
      i32.load offset=4
      local.set 54
      local.get 54
      call $free
      i32.const 1
      local.set 55
      local.get 4
      local.get 55
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 56
    i32.const 16
    local.set 57
    local.get 4
    local.get 57
    i32.add
    local.set 58
    local.get 58
    global.set $__stack_pointer
    local.get 56
    return)"
list_sort,"ListEntry **list, ListCompareFunc compare_func","Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",null,"
void list_sort(ListEntry **list, ListCompareFunc compare_func)
{
	list_sort_internal(list, compare_func);
}","(func $list_sort (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 5
    local.get 6
    call $list_sort_internal
    drop
    i32.const 16
    local.set 7
    local.get 4
    local.get 7
    i32.add
    local.set 8
    local.get 8
    global.set $__stack_pointer
    return)"
list_iterate,"ListEntry **list, ListIterator *iter",Not found,null,"
void list_iterate(ListEntry **list, ListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}","(func $list_iterate (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 6
    local.get 5
    i32.store
    local.get 4
    i32.load offset=8
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.store offset=4
    return)"
list_iter_has_more,ListIterator *iter,We have not yet read the first item.,*iter->prev_next != NULL | iter->current->next != NULL,"
int list_iter_has_more(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {
		/* The current entry as not been deleted since the last
		 * call to list_iter_next: there is a next entry if
		 * current->next is not NULL */
		return iter->current->next != NULL;
	}
}","(func $list_iter_has_more (type 2) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 9
          br_if 0 (;@3;)
          local.get 3
          i32.load offset=8
          local.set 10
          local.get 10
          i32.load offset=4
          local.set 11
          local.get 3
          i32.load offset=8
          local.set 12
          local.get 12
          i32.load
          local.set 13
          local.get 13
          i32.load
          local.set 14
          local.get 11
          local.get 14
          i32.ne
          local.set 15
          i32.const 1
          local.set 16
          local.get 15
          local.get 16
          i32.and
          local.set 17
          local.get 17
          i32.eqz
          br_if 1 (;@2;)
        end
        local.get 3
        i32.load offset=8
        local.set 18
        local.get 18
        i32.load
        local.set 19
        local.get 19
        i32.load
        local.set 20
        i32.const 0
        local.set 21
        local.get 20
        local.get 21
        i32.ne
        local.set 22
        i32.const 1
        local.set 23
        local.get 22
        local.get 23
        i32.and
        local.set 24
        local.get 3
        local.get 24
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=8
      local.set 25
      local.get 25
      i32.load offset=4
      local.set 26
      local.get 26
      i32.load offset=8
      local.set 27
      i32.const 0
      local.set 28
      local.get 27
      local.get 28
      i32.ne
      local.set 29
      i32.const 1
      local.set 30
      local.get 29
      local.get 30
      i32.and
      local.set 31
      local.get 3
      local.get 31
      i32.store offset=12
    end
    local.get 3
    i32.load offset=12
    local.set 32
    local.get 32
    return)"
list_iter_remove,ListIterator *iter,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void list_iter_remove(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;

		if (iter->current->next != NULL) {
			iter->current->next->prev = iter->current->prev;
		}

		free(iter->current);
		iter->current = NULL;
	}
}","(func $list_iter_remove (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 9
          br_if 0 (;@3;)
          local.get 3
          i32.load offset=12
          local.set 10
          local.get 10
          i32.load offset=4
          local.set 11
          local.get 3
          i32.load offset=12
          local.set 12
          local.get 12
          i32.load
          local.set 13
          local.get 13
          i32.load
          local.set 14
          local.get 11
          local.get 14
          i32.ne
          local.set 15
          i32.const 1
          local.set 16
          local.get 15
          local.get 16
          i32.and
          local.set 17
          local.get 17
          i32.eqz
          br_if 1 (;@2;)
        end
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 18
      local.get 18
      i32.load offset=4
      local.set 19
      local.get 19
      i32.load offset=8
      local.set 20
      local.get 3
      i32.load offset=12
      local.set 21
      local.get 21
      i32.load
      local.set 22
      local.get 22
      local.get 20
      i32.store
      local.get 3
      i32.load offset=12
      local.set 23
      local.get 23
      i32.load offset=4
      local.set 24
      local.get 24
      i32.load offset=8
      local.set 25
      i32.const 0
      local.set 26
      local.get 25
      local.get 26
      i32.ne
      local.set 27
      i32.const 1
      local.set 28
      local.get 27
      local.get 28
      i32.and
      local.set 29
      block  ;; label = @2
        local.get 29
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=12
        local.set 30
        local.get 30
        i32.load offset=4
        local.set 31
        local.get 31
        i32.load offset=4
        local.set 32
        local.get 3
        i32.load offset=12
        local.set 33
        local.get 33
        i32.load offset=4
        local.set 34
        local.get 34
        i32.load offset=8
        local.set 35
        local.get 35
        local.get 32
        i32.store offset=4
      end
      local.get 3
      i32.load offset=12
      local.set 36
      local.get 36
      i32.load offset=4
      local.set 37
      local.get 37
      call $free
      local.get 3
      i32.load offset=12
      local.set 38
      i32.const 0
      local.set 39
      local.get 38
      local.get 39
      i32.store offset=4
    end
    i32.const 16
    local.set 40
    local.get 3
    local.get 40
    i32.add
    local.set 41
    local.get 41
    global.set $__stack_pointer
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""list_free"" (func $list_free))
  (export ""list_prepend"" (func $list_prepend))
  (export ""list_append"" (func $list_append))
  (export ""list_data"" (func $list_data))
  (export ""list_set_data"" (func $list_set_data))
  (export ""list_prev"" (func $list_prev))
  (export ""list_next"" (func $list_next))
  (export ""list_nth_entry"" (func $list_nth_entry))
  (export ""list_nth_data"" (func $list_nth_data))
  (export ""list_length"" (func $list_length))
  (export ""list_to_array"" (func $list_to_array))
  (export ""list_remove_entry"" (func $list_remove_entry))
  (export ""list_remove_data"" (func $list_remove_data))
  (export ""__indirect_function_table"" (table 0))
  (export ""list_sort"" (func $list_sort))
  (export ""list_find_data"" (func $list_find_data))
  (export ""list_iterate"" (func $list_iterate))
  (export ""list_iter_has_more"" (func $list_iter_has_more))
  (export ""list_iter_next"" (func $list_iter_next))
  (export ""list_iter_remove"" (func $list_iter_remove))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
queue_free,Queue *queue,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void queue_free(Queue *queue)
{
	/* Empty the queue */
	while (!queue_is_empty(queue)) {
		queue_pop_head(queue);
	}

	/* Free back the queue */
	free(queue);
}","(func $queue_free (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load offset=12
        local.set 4
        local.get 4
        call $queue_is_empty
        local.set 5
        i32.const 0
        local.set 6
        local.get 5
        local.get 6
        i32.ne
        local.set 7
        i32.const -1
        local.set 8
        local.get 7
        local.get 8
        i32.xor
        local.set 9
        i32.const 1
        local.set 10
        local.get 9
        local.get 10
        i32.and
        local.set 11
        local.get 11
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=12
        local.set 12
        local.get 12
        call $queue_pop_head
        drop
        br 0 (;@2;)
      end
    end
    local.get 3
    i32.load offset=12
    local.set 13
    local.get 13
    call $free
    i32.const 16
    local.set 14
    local.get 3
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    return)"
queue_push_head,"Queue *queue, QueueValue data",Free back the queue,0 | 1,"
int queue_push_head(Queue *queue, QueueValue data)
{
	QueueEntry *new_entry;

	/* Create the new entry and fill in the fields in the structure */
	new_entry = malloc(sizeof(QueueEntry));

	if (new_entry == NULL) {
		return 0;
	}

	new_entry->data = data;
	new_entry->prev = NULL;
	new_entry->next = queue->head;

	/* Insert into the queue */
	if (queue->head == NULL) {

		/* If the queue was previously empty, both the head and
		 * tail must be pointed at the new entry */
		queue->head = new_entry;
		queue->tail = new_entry;

	} else {

		/* First entry in the list must have prev pointed back to this
		 * new entry */
		queue->head->prev = new_entry;

		/* Only the head must be pointed at the new entry */
		queue->head = new_entry;
	}

	return 1;
}","(func $queue_push_head (type 4) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 12
    local.set 5
    local.get 5
    call $malloc
    local.set 6
    local.get 4
    local.get 6
    i32.store
    local.get 4
    i32.load
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.eq
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 12
        local.get 4
        local.get 12
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=4
      local.set 13
      local.get 4
      i32.load
      local.set 14
      local.get 14
      local.get 13
      i32.store
      local.get 4
      i32.load
      local.set 15
      i32.const 0
      local.set 16
      local.get 15
      local.get 16
      i32.store offset=4
      local.get 4
      i32.load offset=8
      local.set 17
      local.get 17
      i32.load
      local.set 18
      local.get 4
      i32.load
      local.set 19
      local.get 19
      local.get 18
      i32.store offset=8
      local.get 4
      i32.load offset=8
      local.set 20
      local.get 20
      i32.load
      local.set 21
      i32.const 0
      local.set 22
      local.get 21
      local.get 22
      i32.eq
      local.set 23
      i32.const 1
      local.set 24
      local.get 23
      local.get 24
      i32.and
      local.set 25
      block  ;; label = @2
        block  ;; label = @3
          local.get 25
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load
          local.set 26
          local.get 4
          i32.load offset=8
          local.set 27
          local.get 27
          local.get 26
          i32.store
          local.get 4
          i32.load
          local.set 28
          local.get 4
          i32.load offset=8
          local.set 29
          local.get 29
          local.get 28
          i32.store offset=4
          br 1 (;@2;)
        end
        local.get 4
        i32.load
        local.set 30
        local.get 4
        i32.load offset=8
        local.set 31
        local.get 31
        i32.load
        local.set 32
        local.get 32
        local.get 30
        i32.store offset=4
        local.get 4
        i32.load
        local.set 33
        local.get 4
        i32.load offset=8
        local.set 34
        local.get 34
        local.get 33
        i32.store
      end
      i32.const 1
      local.set 35
      local.get 4
      local.get 35
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 36
    i32.const 16
    local.set 37
    local.get 4
    local.get 37
    i32.add
    local.set 38
    local.get 38
    global.set $__stack_pointer
    local.get 36
    return)"
queue_push_tail,"Queue *queue, QueueValue data","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",0 | 1,"
int queue_push_tail(Queue *queue, QueueValue data)
{
	QueueEntry *new_entry;

	/* Create the new entry and fill in the fields in the structure */
	new_entry = malloc(sizeof(QueueEntry));

	if (new_entry == NULL) {
		return 0;
	}

	new_entry->data = data;
	new_entry->prev = queue->tail;
	new_entry->next = NULL;

	/* Insert into the queue tail */
	if (queue->tail == NULL) {

		/* If the queue was previously empty, both the head and
		 * tail must be pointed at the new entry */
		queue->head = new_entry;
		queue->tail = new_entry;

	} else {

		/* The current entry at the tail must have next pointed to this
		 * new entry */
		queue->tail->next = new_entry;

		/* Only the tail must be pointed at the new entry */
		queue->tail = new_entry;
	}

	return 1;
}","(func $queue_push_tail (type 4) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 12
    local.set 5
    local.get 5
    call $malloc
    local.set 6
    local.get 4
    local.get 6
    i32.store
    local.get 4
    i32.load
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.eq
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 12
        local.get 4
        local.get 12
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=4
      local.set 13
      local.get 4
      i32.load
      local.set 14
      local.get 14
      local.get 13
      i32.store
      local.get 4
      i32.load offset=8
      local.set 15
      local.get 15
      i32.load offset=4
      local.set 16
      local.get 4
      i32.load
      local.set 17
      local.get 17
      local.get 16
      i32.store offset=4
      local.get 4
      i32.load
      local.set 18
      i32.const 0
      local.set 19
      local.get 18
      local.get 19
      i32.store offset=8
      local.get 4
      i32.load offset=8
      local.set 20
      local.get 20
      i32.load offset=4
      local.set 21
      i32.const 0
      local.set 22
      local.get 21
      local.get 22
      i32.eq
      local.set 23
      i32.const 1
      local.set 24
      local.get 23
      local.get 24
      i32.and
      local.set 25
      block  ;; label = @2
        block  ;; label = @3
          local.get 25
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load
          local.set 26
          local.get 4
          i32.load offset=8
          local.set 27
          local.get 27
          local.get 26
          i32.store
          local.get 4
          i32.load
          local.set 28
          local.get 4
          i32.load offset=8
          local.set 29
          local.get 29
          local.get 28
          i32.store offset=4
          br 1 (;@2;)
        end
        local.get 4
        i32.load
        local.set 30
        local.get 4
        i32.load offset=8
        local.set 31
        local.get 31
        i32.load offset=4
        local.set 32
        local.get 32
        local.get 30
        i32.store offset=8
        local.get 4
        i32.load
        local.set 33
        local.get 4
        i32.load offset=8
        local.set 34
        local.get 34
        local.get 33
        i32.store offset=4
      end
      i32.const 1
      local.set 35
      local.get 4
      local.get 35
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 36
    i32.const 16
    local.set 37
    local.get 4
    local.get 37
    i32.add
    local.set 38
    local.get 38
    global.set $__stack_pointer
    local.get 36
    return)"
queue_is_empty,Queue *queue,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",queue->head == NULL,"
int queue_is_empty(Queue *queue)
{
	return queue->head == NULL;
}","(func $queue_is_empty (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    local.get 9
    return)"
rb_tree_node_replace,"RBTree *tree, RBTreeNode *node1, RBTreeNode *node2","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",new_root | NULL | new_tree | node | rb_tree_null_value | node->value | 0 | 1 | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes,"static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1,
                                 RBTreeNode *node2)
{
	int side;

	/* Set the node's parent pointer. */
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}

	/* The root node? */
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = rb_tree_node_side(node1);
		node1->parent->children[side] = node2;
	}
}

/* Rotate a section of the tree.  'node' is the node at the top
 * of the section to be rotated.  'direction' is the direction in
 * which to rotate the tree: left or right, as shown in the following
 * diagram:
 *
 * Left rotation:              Right rotation:
 *
 *      B                             D
 *     / \                           / \
 *    A   D                         B   E
 *       / \                       / \
 *      C   E                     A   C

 * is rotated to:              is rotated to:
 *
 *        D                           B
 *       / \                         / \
 *      B   E                       A   D
 *     / \                             / \
 *    A   C                           C   E
 */
static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node,
                                  RBTreeNodeSide direction)
{
	RBTreeNode *new_root;

	/* The child of this node will take its place:
	   for a left rotation, it is the right child, and vice versa. */
	new_root = node->children[1 - direction];

	/* Make new_root the root, update parent pointers. */
	rb_tree_node_replace(tree, node, new_root);

	/* Rearrange pointers */
	node->children[1 - direction] = new_root->children[direction];
	new_root->children[direction] = node;

	/* Update parent references */
	node->parent = new_root;

	if (node->children[1 - direction] != NULL) {
		node->children[1 - direction]->parent = node;
	}

	return new_root;
}

RBTree *rb_tree_new(RBTreeCompareFunc compare_func)
{
	RBTree *new_tree;

	new_tree = malloc(sizeof(RBTree));

	if (new_tree == NULL) {
		return NULL;
	}

	new_tree->root_node = NULL;
	new_tree->num_nodes = 0;
	new_tree->compare_func = compare_func;

	return new_tree;
}

static void rb_tree_free_subtree(RBTreeNode *node)
{
	if (node != NULL) {
		/* Recurse to subnodes */
		rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);
		rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);

		/* Free this node */
		free(node);
	}
}

void rb_tree_free(RBTree *tree)
{
	/* Free all nodes in the tree */
	rb_tree_free_subtree(tree->root_node);

	/* Free back the main tree structure */
	free(tree);
}

static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node);

/* Insert case 1: If the new node is at the root of the tree, it must
 * be recolored black, as the root is always black. */
static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)
{
	if (node->parent == NULL) {

		/* The root node is black */
		node->color = RB_TREE_NODE_BLACK;

	} else {

		/* Not root */
		rb_tree_insert_case2(tree, node);
	}
}

/* Insert case 2: If the parent of the new node is red, this
 * conflicts with the red-black tree conditions, as both children
 * of every red node are black. */
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	/* Note that if this function is being called, we already know
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}

/* Insert case 3: If the parent and uncle are both red, repaint them
 * both black and repaint the grandparent red.  */
static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *grandparent;
	RBTreeNode *uncle;

	/* Note that the node must have a grandparent, as the parent
	 * is red, and the root node is always black. */
	grandparent = node->parent->parent;
	uncle = rb_tree_node_uncle(node);

	if (uncle != NULL && uncle->color == RB_TREE_NODE_RED) {

		node->parent->color = RB_TREE_NODE_BLACK;
		uncle->color = RB_TREE_NODE_BLACK;
		grandparent->color = RB_TREE_NODE_RED;

		/* Recurse to grandparent */
		rb_tree_insert_case1(tree, grandparent);

	} else {
		rb_tree_insert_case4(tree, node);
	}
}

/* Case 4: If the parent is red, but the uncle is black, we need to do
 * some rotations to keep the tree balanced and complying with the tree
 * conditions.  If the node is on the opposite side relative to its parent
 * as the parent is relative to its grandparent, rotate around the
 * parent.  Either way, we will continue to case 5.
 *
 * eg.
 *
 *         B                              B
 *        / \                            / \
 *       R   B          ->     node ->  R   B
 *        \                            /
 *         R  <- node                 R
 *
 */
void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *next_node;
	RBTreeNodeSide side;

	/* Note that at this point, by implication from case 3, we know
	 * that the parent is red, but the uncle is black.  We therefore
	 * only need to examine what side the node is on relative
	 * to its parent, and the side the parent is on relative to
	 * the grandparent. */
	side = rb_tree_node_side(node);

	if (side != rb_tree_node_side(node->parent)) {

		/* After the rotation, we will continue to case 5, but
		 * the parent node will be at the bottom. */
		next_node = node->parent;

		/* Rotate around the parent in the opposite direction
		 * to side. */
		rb_tree_rotate(tree, node->parent, 1 - side);
	} else {
		next_node = node;
	}

	rb_tree_insert_case5(tree, next_node);
}

/* Case 5: The node is on the same side relative to its parent as the
 * parent is relative to its grandparent.  The node and its parent are
 * red, but the uncle is black.
 *
 * Now, rotate at the grandparent and recolor the parent and grandparent
 * to black and red respectively.
 *
 *               G/B                 P/B
 *              /   \               /   \
 *           P/R     U/B    ->   N/R     G/R
 *          /   \                       /   \
 *       N/R      ?                   ?      U/B
 *
 */
void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *parent;
	RBTreeNode *grandparent;
	RBTreeNodeSide side;

	parent = node->parent;
	grandparent = parent->parent;

	/* What side are we, relative to the parent?  This will determine
	 * the direction that we rotate. */
	side = rb_tree_node_side(node);

	/* Rotate at the grandparent, in the opposite direction to side. */
	rb_tree_rotate(tree, grandparent, 1 - side);

	/* Recolor the (old) parent and grandparent. */
	parent->color = RB_TREE_NODE_BLACK;
	grandparent->color = RB_TREE_NODE_RED;
}

RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)
{
	RBTreeNode *node;
	RBTreeNode **rover;
	RBTreeNode *parent;
	RBTreeNodeSide side;

	/* Allocate a new node */
	node = malloc(sizeof(RBTreeNode));

	if (node == NULL) {
		return NULL;
	}

	/* Set up structure.  Initially, the node is red. */
	node->key = key;
	node->value = value;
	node->color = RB_TREE_NODE_RED;
	node->children[RB_TREE_NODE_LEFT] = NULL;
	node->children[RB_TREE_NODE_RIGHT] = NULL;

	/* First, perform a normal binary tree-style insert. */
	parent = NULL;
	rover = &tree->root_node;

	while (*rover != NULL) {

		/* Update parent */
		parent = *rover;

		/* Choose which path to go down, left or right child */
		if (tree->compare_func(key, (*rover)->key) < 0) {
			side = RB_TREE_NODE_LEFT;
		} else {
			side = RB_TREE_NODE_RIGHT;
		}

		rover = &(*rover)->children[side];
	}

	/* Insert at the position we have reached */
	*rover = node;
	node->parent = parent;

	/* Possibly reorder the tree. */
	rb_tree_insert_case1(tree, node);

	/* Update the node count */
	++tree->num_nodes;

	return node;
}

RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;
	RBTreeNodeSide side;
	int diff;

	node = tree->root_node;

	/* Search down the tree. */
	while (node != NULL) {
		diff = tree->compare_func(key, node->key);

		if (diff == 0) {
			return node;
		} else if (diff < 0) {
			side = RB_TREE_NODE_LEFT;
		} else {
			side = RB_TREE_NODE_RIGHT;
		}

		node = node->children[side];
	}

	/* Not found. */
	return NULL;
}

RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node for this key. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return rb_tree_null_value;
	} else {
		return node->value;
	}
}

void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)
{ /* TODO */
}

int rb_tree_remove(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node to remove. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return 0;
	}

	rb_tree_remove_node(tree, node);

	return 1;
}

RBTreeNode *rb_tree_root_node(RBTree *tree)
{
	return tree->root_node;
}

RBTreeKey rb_tree_node_key(RBTreeNode *node)
{
	return node->key;
}

RBTreeValue rb_tree_node_value(RBTreeNode *node)
{
	return node->value;
}

RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)
{
	if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

RBTreeNode *rb_tree_node_parent(RBTreeNode *node)
{
	return node->parent;
}

RBTreeKey *rb_tree_to_array(RBTree *tree)
{
	/* TODO */
	return NULL;
}

int rb_tree_num_entries(RBTree *tree)
{
	return tree->num_nodes;
}","(func $rb_tree_node_replace (type 6) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 16
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=12
    local.get 5
    local.get 1
    i32.store offset=8
    local.get 5
    local.get 2
    i32.store offset=4
    local.get 5
    i32.load offset=4
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.ne
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      i32.eqz
      br_if 0 (;@1;)
      local.get 5
      i32.load offset=8
      local.set 11
      local.get 11
      i32.load offset=12
      local.set 12
      local.get 5
      i32.load offset=4
      local.set 13
      local.get 13
      local.get 12
      i32.store offset=12
    end
    local.get 5
    i32.load offset=8
    local.set 14
    local.get 14
    i32.load offset=12
    local.set 15
    i32.const 0
    local.set 16
    local.get 15
    local.get 16
    i32.eq
    local.set 17
    i32.const 1
    local.set 18
    local.get 17
    local.get 18
    i32.and
    local.set 19
    block  ;; label = @1
      block  ;; label = @2
        local.get 19
        i32.eqz
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=4
        local.set 20
        local.get 5
        i32.load offset=12
        local.set 21
        local.get 21
        local.get 20
        i32.store
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=8
      local.set 22
      local.get 22
      call $rb_tree_node_side
      local.set 23
      local.get 5
      local.get 23
      i32.store
      local.get 5
      i32.load offset=4
      local.set 24
      local.get 5
      i32.load offset=8
      local.set 25
      local.get 25
      i32.load offset=12
      local.set 26
      i32.const 16
      local.set 27
      local.get 26
      local.get 27
      i32.add
      local.set 28
      local.get 5
      i32.load
      local.set 29
      i32.const 2
      local.set 30
      local.get 29
      local.get 30
      i32.shl
      local.set 31
      local.get 28
      local.get 31
      i32.add
      local.set 32
      local.get 32
      local.get 24
      i32.store
    end
    i32.const 16
    local.set 33
    local.get 5
    local.get 33
    i32.add
    local.set 34
    local.get 34
    global.set $__stack_pointer
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""rb_tree_node_uncle"" (func $rb_tree_node_uncle))
  (export ""rb_tree_new"" (func $rb_tree_new))
  (export ""rb_tree_free"" (func $rb_tree_free))
  (export ""rb_tree_insert"" (func $rb_tree_insert))
  (export ""__indirect_function_table"" (table 0))
  (export ""rb_tree_lookup_node"" (func $rb_tree_lookup_node))
  (export ""rb_tree_lookup"" (func $rb_tree_lookup))
  (export ""rb_tree_remove_node"" (func $rb_tree_remove_node))
  (export ""rb_tree_remove"" (func $rb_tree_remove))
  (export ""rb_tree_root_node"" (func $rb_tree_root_node))
  (export ""rb_tree_node_key"" (func $rb_tree_node_key))
  (export ""rb_tree_node_value"" (func $rb_tree_node_value))
  (export ""rb_tree_node_child"" (func $rb_tree_node_child))
  (export ""rb_tree_node_parent"" (func $rb_tree_node_parent))
  (export ""rb_tree_to_array"" (func $rb_tree_to_array))
  (export ""rb_tree_num_entries"" (func $rb_tree_num_entries))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
rb_tree_insert_case1,"RBTree *tree, RBTreeNode *node","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)
{
	if (node->parent == NULL) {

		/* The root node is black */
		node->color = RB_TREE_NODE_BLACK;

	} else {

		/* Not root */
		rb_tree_insert_case2(tree, node);
	}
}","(func $rb_tree_insert_case1 (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    i32.load offset=12
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.eq
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      block  ;; label = @2
        local.get 10
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=8
        local.set 11
        i32.const 1
        local.set 12
        local.get 11
        local.get 12
        i32.store
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=12
      local.set 13
      local.get 4
      i32.load offset=8
      local.set 14
      local.get 13
      local.get 14
      call $rb_tree_insert_case2
    end
    i32.const 16
    local.set 15
    local.get 4
    local.get 15
    i32.add
    local.set 16
    local.get 16
    global.set $__stack_pointer
    return)"
rb_tree_insert_case2,"RBTree *tree, RBTreeNode *node","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	/* Note that if this function is being called, we already know
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}","(func $rb_tree_insert_case2 (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    i32.load offset=12
    local.set 6
    local.get 6
    i32.load
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.ne
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      local.get 11
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=12
      local.set 12
      local.get 4
      i32.load offset=8
      local.set 13
      local.get 12
      local.get 13
      call $rb_tree_insert_case3
    end
    i32.const 16
    local.set 14
    local.get 4
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    return)"
rb_tree_insert_case3,"RBTree *tree, RBTreeNode *node","Insert case 2: If the parent of the new node is red, this
conflicts with the red-black tree conditions, as both children
of every red node are black.",null,"static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *grandparent;
	RBTreeNode *uncle;

	/* Note that the node must have a grandparent, as the parent
	 * is red, and the root node is always black. */
	grandparent = node->parent->parent;
	uncle = rb_tree_node_uncle(node);

	if (uncle != NULL && uncle->color == RB_TREE_NODE_RED) {

		node->parent->color = RB_TREE_NODE_BLACK;
		uncle->color = RB_TREE_NODE_BLACK;
		grandparent->color = RB_TREE_NODE_RED;

		/* Recurse to grandparent */
		rb_tree_insert_case1(tree, grandparent);

	} else {
		rb_tree_insert_case4(tree, node);
	}
}","(func $rb_tree_insert_case3 (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    i32.load offset=12
    local.set 6
    local.get 6
    i32.load offset=12
    local.set 7
    local.get 4
    local.get 7
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 8
    local.get 8
    call $rb_tree_node_uncle
    local.set 9
    local.get 4
    local.get 9
    i32.store
    local.get 4
    i32.load
    local.set 10
    i32.const 0
    local.set 11
    local.get 10
    local.get 11
    i32.ne
    local.set 12
    i32.const 1
    local.set 13
    local.get 12
    local.get 13
    i32.and
    local.set 14
    block  ;; label = @1
      block  ;; label = @2
        local.get 14
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load
        local.set 15
        local.get 15
        i32.load
        local.set 16
        local.get 16
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=8
        local.set 17
        local.get 17
        i32.load offset=12
        local.set 18
        i32.const 1
        local.set 19
        local.get 18
        local.get 19
        i32.store
        local.get 4
        i32.load
        local.set 20
        i32.const 1
        local.set 21
        local.get 20
        local.get 21
        i32.store
        local.get 4
        i32.load offset=4
        local.set 22
        i32.const 0
        local.set 23
        local.get 22
        local.get 23
        i32.store
        local.get 4
        i32.load offset=12
        local.set 24
        local.get 4
        i32.load offset=4
        local.set 25
        local.get 24
        local.get 25
        call $rb_tree_insert_case1
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=12
      local.set 26
      local.get 4
      i32.load offset=8
      local.set 27
      local.get 26
      local.get 27
      call $rb_tree_insert_case4
    end
    i32.const 16
    local.set 28
    local.get 4
    local.get 28
    i32.add
    local.set 29
    local.get 29
    global.set $__stack_pointer
    return)"
rb_tree_insert_case4,"RBTree *tree, RBTreeNode *node","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *next_node;
	RBTreeNodeSide side;

	/* Note that at this point, by implication from case 3, we know
	 * that the parent is red, but the uncle is black.  We therefore
	 * only need to examine what side the node is on relative
	 * to its parent, and the side the parent is on relative to
	 * the grandparent. */
	side = rb_tree_node_side(node);

	if (side != rb_tree_node_side(node->parent)) {

		/* After the rotation, we will continue to case 5, but
		 * the parent node will be at the bottom. */
		next_node = node->parent;

		/* Rotate around the parent in the opposite direction
		 * to side. */
		rb_tree_rotate(tree, node->parent, 1 - side);
	} else {
		next_node = node;
	}

	rb_tree_insert_case5(tree, next_node);
}","(func $rb_tree_insert_case4 (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    call $rb_tree_node_side
    local.set 6
    local.get 4
    local.get 6
    i32.store
    local.get 4
    i32.load
    local.set 7
    local.get 4
    i32.load offset=8
    local.set 8
    local.get 8
    i32.load offset=12
    local.set 9
    local.get 9
    call $rb_tree_node_side
    local.set 10
    local.get 7
    local.get 10
    i32.ne
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.and
    local.set 13
    block  ;; label = @1
      block  ;; label = @2
        local.get 13
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=8
        local.set 14
        local.get 14
        i32.load offset=12
        local.set 15
        local.get 4
        local.get 15
        i32.store offset=4
        local.get 4
        i32.load offset=12
        local.set 16
        local.get 4
        i32.load offset=8
        local.set 17
        local.get 17
        i32.load offset=12
        local.set 18
        local.get 4
        i32.load
        local.set 19
        i32.const 1
        local.set 20
        local.get 20
        local.get 19
        i32.sub
        local.set 21
        local.get 16
        local.get 18
        local.get 21
        call $rb_tree_rotate
        drop
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=8
      local.set 22
      local.get 4
      local.get 22
      i32.store offset=4
    end
    local.get 4
    i32.load offset=12
    local.set 23
    local.get 4
    i32.load offset=4
    local.set 24
    local.get 23
    local.get 24
    call $rb_tree_insert_case5
    i32.const 16
    local.set 25
    local.get 4
    local.get 25
    i32.add
    local.set 26
    local.get 26
    global.set $__stack_pointer
    return)"
rb_tree_insert_case5,"RBTree *tree, RBTreeNode *node","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *parent;
	RBTreeNode *grandparent;
	RBTreeNodeSide side;

	parent = node->parent;
	grandparent = parent->parent;

	/* What side are we, relative to the parent?  This will determine
	 * the direction that we rotate. */
	side = rb_tree_node_side(node);

	/* Rotate at the grandparent, in the opposite direction to side. */
	rb_tree_rotate(tree, grandparent, 1 - side);

	/* Recolor the (old) parent and grandparent. */
	parent->color = RB_TREE_NODE_BLACK;
	grandparent->color = RB_TREE_NODE_RED;
}","(func $rb_tree_insert_case5 (type 5) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=28
    local.get 4
    local.get 1
    i32.store offset=24
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 5
    i32.load offset=12
    local.set 6
    local.get 4
    local.get 6
    i32.store offset=20
    local.get 4
    i32.load offset=20
    local.set 7
    local.get 7
    i32.load offset=12
    local.set 8
    local.get 4
    local.get 8
    i32.store offset=16
    local.get 4
    i32.load offset=24
    local.set 9
    local.get 9
    call $rb_tree_node_side
    local.set 10
    local.get 4
    local.get 10
    i32.store offset=12
    local.get 4
    i32.load offset=28
    local.set 11
    local.get 4
    i32.load offset=16
    local.set 12
    local.get 4
    i32.load offset=12
    local.set 13
    i32.const 1
    local.set 14
    local.get 14
    local.get 13
    i32.sub
    local.set 15
    local.get 11
    local.get 12
    local.get 15
    call $rb_tree_rotate
    drop
    local.get 4
    i32.load offset=20
    local.set 16
    i32.const 1
    local.set 17
    local.get 16
    local.get 17
    i32.store
    local.get 4
    i32.load offset=16
    local.set 18
    i32.const 0
    local.set 19
    local.get 18
    local.get 19
    i32.store
    i32.const 32
    local.set 20
    local.get 4
    local.get 20
    i32.add
    local.set 21
    local.get 21
    global.set $__stack_pointer
    return)"
rb_tree_remove_node,"RBTree *tree, RBTreeNode *node","Removes an element or a range of elements from a collection.
Shifts remaining elements and decrements the length counter.",null,"
void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)
{ /* TODO */
}","(func $rb_tree_remove_node (type 5) (param i32 i32)
    (local i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    return)"
rb_tree_remove,"RBTree *tree, RBTreeKey key",TODO,0 | 1,"
int rb_tree_remove(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node to remove. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return 0;
	}

	rb_tree_remove_node(tree, node);

	return 1;
}","(func $rb_tree_remove (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    i32.load offset=4
    local.set 6
    local.get 5
    local.get 6
    call $rb_tree_lookup_node
    local.set 7
    local.get 4
    local.get 7
    i32.store
    local.get 4
    i32.load
    local.set 8
    i32.const 0
    local.set 9
    local.get 8
    local.get 9
    i32.eq
    local.set 10
    i32.const 1
    local.set 11
    local.get 10
    local.get 11
    i32.and
    local.set 12
    block  ;; label = @1
      block  ;; label = @2
        local.get 12
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 13
        local.get 4
        local.get 13
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=8
      local.set 14
      local.get 4
      i32.load
      local.set 15
      local.get 14
      local.get 15
      call $rb_tree_remove_node
      i32.const 1
      local.set 16
      local.get 4
      local.get 16
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 17
    i32.const 16
    local.set 18
    local.get 4
    local.get 18
    i32.add
    local.set 19
    local.get 19
    global.set $__stack_pointer
    local.get 17
    return)"
rb_tree_num_entries,RBTree *tree,TODO,tree->num_nodes,"
int rb_tree_num_entries(RBTree *tree)
{
	return tree->num_nodes;
}","(func $rb_tree_num_entries (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    return)"
set_allocate_table,Set *set,Null value that can be returned without creating a local variable,set->table != NULL,"
static int set_allocate_table(Set *set)
{
	/* Determine the table size based on the current prime index.
	 * An attempt is made here to ensure sensible behavior if the
	 * maximum prime is exceeded, but in practice other things are
	 * likely to break long before that happens. */
	if (set->prime_index < set_num_primes) {
		set->table_size = set_primes[set->prime_index];
	} else {
		set->table_size = set->entries * 10;
	}

	/* Allocate the table and initialise to NULL */
	set->table = calloc(set->table_size, sizeof(SetEntry *));

	return set->table != NULL;
}","(func $set_allocate_table (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=12
    local.set 5
    i32.const 24
    local.set 6
    local.get 5
    local.get 6
    i32.lt_u
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        local.get 9
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=12
        local.set 10
        local.get 10
        i32.load offset=12
        local.set 11
        i32.const 1024
        local.set 12
        i32.const 2
        local.set 13
        local.get 11
        local.get 13
        i32.shl
        local.set 14
        local.get 12
        local.get 14
        i32.add
        local.set 15
        local.get 15
        i32.load
        local.set 16
        local.get 3
        i32.load offset=12
        local.set 17
        local.get 17
        local.get 16
        i32.store offset=8
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 18
      local.get 18
      i32.load offset=4
      local.set 19
      i32.const 10
      local.set 20
      local.get 19
      local.get 20
      i32.mul
      local.set 21
      local.get 3
      i32.load offset=12
      local.set 22
      local.get 22
      local.get 21
      i32.store offset=8
    end
    local.get 3
    i32.load offset=12
    local.set 23
    local.get 23
    i32.load offset=8
    local.set 24
    i32.const 4
    local.set 25
    local.get 24
    local.get 25
    call $calloc
    local.set 26
    local.get 3
    i32.load offset=12
    local.set 27
    local.get 27
    local.get 26
    i32.store
    local.get 3
    i32.load offset=12
    local.set 28
    local.get 28
    i32.load
    local.set 29
    i32.const 0
    local.set 30
    local.get 29
    local.get 30
    i32.ne
    local.set 31
    i32.const 1
    local.set 32
    local.get 31
    local.get 32
    i32.and
    local.set 33
    i32.const 16
    local.set 34
    local.get 3
    local.get 34
    i32.add
    local.set 35
    local.get 35
    global.set $__stack_pointer
    local.get 33
    return)"
set_free_entry,"Set *set, SetEntry *entry","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
static void set_free_entry(Set *set, SetEntry *entry)
{
	/* If there is a free function registered, call it to free the
	 * data for this entry first */
	if (set->free_func != NULL) {
		set->free_func(entry->data);
	}

	/* Free the entry structure */
	free(entry);
}","(func $set_free_entry (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 5
    i32.load offset=24
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.ne
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=12
      local.set 11
      local.get 11
      i32.load offset=24
      local.set 12
      local.get 4
      i32.load offset=8
      local.set 13
      local.get 13
      i32.load
      local.set 14
      local.get 14
      local.get 12
      call_indirect (type 0)
    end
    local.get 4
    i32.load offset=8
    local.set 15
    local.get 15
    call $free
    i32.const 16
    local.set 16
    local.get 4
    local.get 16
    i32.add
    local.set 17
    local.get 17
    global.set $__stack_pointer
    return)"
set_free,Set *set,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void set_free(Set *set)
{
	SetEntry *rover;
	SetEntry *next;
	unsigned int i;

	/* Free all entries in all chains */
	for (i = 0; i < set->table_size; ++i) {
		rover = set->table[i];

		while (rover != NULL) {
			next = rover->next;

			/* Free this entry */
			set_free_entry(set, rover);

			/* Advance to the next entry in the chain */
			rover = next;
		}
	}

	/* Free the table */
	free(set->table);

	/* Free the set structure */
	free(set);
}","(func $set_free (type 0) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const 0
    local.set 4
    local.get 3
    local.get 4
    i32.store
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load
        local.set 5
        local.get 3
        i32.load offset=12
        local.set 6
        local.get 6
        i32.load offset=8
        local.set 7
        local.get 5
        local.get 7
        i32.lt_u
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=12
        local.set 11
        local.get 11
        i32.load
        local.set 12
        local.get 3
        i32.load
        local.set 13
        i32.const 2
        local.set 14
        local.get 13
        local.get 14
        i32.shl
        local.set 15
        local.get 12
        local.get 15
        i32.add
        local.set 16
        local.get 16
        i32.load
        local.set 17
        local.get 3
        local.get 17
        i32.store offset=8
        block  ;; label = @3
          loop  ;; label = @4
            local.get 3
            i32.load offset=8
            local.set 18
            i32.const 0
            local.set 19
            local.get 18
            local.get 19
            i32.ne
            local.set 20
            i32.const 1
            local.set 21
            local.get 20
            local.get 21
            i32.and
            local.set 22
            local.get 22
            i32.eqz
            br_if 1 (;@3;)
            local.get 3
            i32.load offset=8
            local.set 23
            local.get 23
            i32.load offset=4
            local.set 24
            local.get 3
            local.get 24
            i32.store offset=4
            local.get 3
            i32.load offset=12
            local.set 25
            local.get 3
            i32.load offset=8
            local.set 26
            local.get 25
            local.get 26
            call $set_free_entry
            local.get 3
            i32.load offset=4
            local.set 27
            local.get 3
            local.get 27
            i32.store offset=8
            br 0 (;@4;)
          end
        end
        local.get 3
        i32.load
        local.set 28
        i32.const 1
        local.set 29
        local.get 28
        local.get 29
        i32.add
        local.set 30
        local.get 3
        local.get 30
        i32.store
        br 0 (;@2;)
      end
    end
    local.get 3
    i32.load offset=12
    local.set 31
    local.get 31
    i32.load
    local.set 32
    local.get 32
    call $free
    local.get 3
    i32.load offset=12
    local.set 33
    local.get 33
    call $free
    i32.const 16
    local.set 34
    local.get 3
    local.get 34
    i32.add
    local.set 35
    local.get 35
    global.set $__stack_pointer
    return)"
set_register_free_function,"Set *set, SetFreeFunc free_func",Free the set structure,null,"
void set_register_free_function(Set *set, SetFreeFunc free_func)
{
	set->free_func = free_func;
}","(func $set_register_free_function (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 4
    i32.load offset=12
    local.set 6
    local.get 6
    local.get 5
    i32.store offset=24
    return)"
set_enlarge,Set *set,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",0 | 1,"
static int set_enlarge(Set *set)
{
	SetEntry *rover;
	SetEntry *next;
	SetEntry **old_table;
	unsigned int old_table_size;
	unsigned int old_prime_index;
	unsigned int index;
	unsigned int i;

	/* Store the old table */
	old_table = set->table;
	old_table_size = set->table_size;
	old_prime_index = set->prime_index;

	/* Use the next table size from the prime number array */
	++set->prime_index;

	/* Allocate the new table */
	if (!set_allocate_table(set)) {
		set->table = old_table;
		set->table_size = old_table_size;
		set->prime_index = old_prime_index;

		return 0;
	}

	/* Iterate through all entries in the old table and add them
	 * to the new one */
	for (i = 0; i < old_table_size; ++i) {

		/* Walk along this chain */
		rover = old_table[i];

		while (rover != NULL) {

			next = rover->next;

			/* Hook this entry into the new table */
			index = set->hash_func(rover->data) % set->table_size;
			rover->next = set->table[index];
			set->table[index] = rover;

			/* Advance to the next entry in the chain */
			rover = next;
		}
	}

	/* Free back the old table */
	free(old_table);

	/* Resized successfully */
	return 1;
}","(func $set_enlarge (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 48
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=40
    local.get 3
    i32.load offset=40
    local.set 4
    local.get 4
    i32.load
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=28
    local.get 3
    i32.load offset=40
    local.set 6
    local.get 6
    i32.load offset=8
    local.set 7
    local.get 3
    local.get 7
    i32.store offset=24
    local.get 3
    i32.load offset=40
    local.set 8
    local.get 8
    i32.load offset=12
    local.set 9
    local.get 3
    local.get 9
    i32.store offset=20
    local.get 3
    i32.load offset=40
    local.set 10
    local.get 10
    i32.load offset=12
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.add
    local.set 13
    local.get 10
    local.get 13
    i32.store offset=12
    local.get 3
    i32.load offset=40
    local.set 14
    local.get 14
    call $set_allocate_table
    local.set 15
    block  ;; label = @1
      block  ;; label = @2
        local.get 15
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=28
        local.set 16
        local.get 3
        i32.load offset=40
        local.set 17
        local.get 17
        local.get 16
        i32.store
        local.get 3
        i32.load offset=24
        local.set 18
        local.get 3
        i32.load offset=40
        local.set 19
        local.get 19
        local.get 18
        i32.store offset=8
        local.get 3
        i32.load offset=20
        local.set 20
        local.get 3
        i32.load offset=40
        local.set 21
        local.get 21
        local.get 20
        i32.store offset=12
        i32.const 0
        local.set 22
        local.get 3
        local.get 22
        i32.store offset=44
        br 1 (;@1;)
      end
      i32.const 0
      local.set 23
      local.get 3
      local.get 23
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 3
          i32.load offset=12
          local.set 24
          local.get 3
          i32.load offset=24
          local.set 25
          local.get 24
          local.get 25
          i32.lt_u
          local.set 26
          i32.const 1
          local.set 27
          local.get 26
          local.get 27
          i32.and
          local.set 28
          local.get 28
          i32.eqz
          br_if 1 (;@2;)
          local.get 3
          i32.load offset=28
          local.set 29
          local.get 3
          i32.load offset=12
          local.set 30
          i32.const 2
          local.set 31
          local.get 30
          local.get 31
          i32.shl
          local.set 32
          local.get 29
          local.get 32
          i32.add
          local.set 33
          local.get 33
          i32.load
          local.set 34
          local.get 3
          local.get 34
          i32.store offset=36
          block  ;; label = @4
            loop  ;; label = @5
              local.get 3
              i32.load offset=36
              local.set 35
              i32.const 0
              local.set 36
              local.get 35
              local.get 36
              i32.ne
              local.set 37
              i32.const 1
              local.set 38
              local.get 37
              local.get 38
              i32.and
              local.set 39
              local.get 39
              i32.eqz
              br_if 1 (;@4;)
              local.get 3
              i32.load offset=36
              local.set 40
              local.get 40
              i32.load offset=4
              local.set 41
              local.get 3
              local.get 41
              i32.store offset=32
              local.get 3
              i32.load offset=40
              local.set 42
              local.get 42
              i32.load offset=16
              local.set 43
              local.get 3
              i32.load offset=36
              local.set 44
              local.get 44
              i32.load
              local.set 45
              local.get 45
              local.get 43
              call_indirect (type 1)
              local.set 46
              local.get 3
              i32.load offset=40
              local.set 47
              local.get 47
              i32.load offset=8
              local.set 48
              local.get 46
              local.get 48
              i32.rem_u
              local.set 49
              local.get 3
              local.get 49
              i32.store offset=16
              local.get 3
              i32.load offset=40
              local.set 50
              local.get 50
              i32.load
              local.set 51
              local.get 3
              i32.load offset=16
              local.set 52
              i32.const 2
              local.set 53
              local.get 52
              local.get 53
              i32.shl
              local.set 54
              local.get 51
              local.get 54
              i32.add
              local.set 55
              local.get 55
              i32.load
              local.set 56
              local.get 3
              i32.load offset=36
              local.set 57
              local.get 57
              local.get 56
              i32.store offset=4
              local.get 3
              i32.load offset=36
              local.set 58
              local.get 3
              i32.load offset=40
              local.set 59
              local.get 59
              i32.load
              local.set 60
              local.get 3
              i32.load offset=16
              local.set 61
              i32.const 2
              local.set 62
              local.get 61
              local.get 62
              i32.shl
              local.set 63
              local.get 60
              local.get 63
              i32.add
              local.set 64
              local.get 64
              local.get 58
              i32.store
              local.get 3
              i32.load offset=32
              local.set 65
              local.get 3
              local.get 65
              i32.store offset=36
              br 0 (;@5;)
            end
          end
          local.get 3
          i32.load offset=12
          local.set 66
          i32.const 1
          local.set 67
          local.get 66
          local.get 67
          i32.add
          local.set 68
          local.get 3
          local.get 68
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      local.get 3
      i32.load offset=28
      local.set 69
      local.get 69
      call $free
      i32.const 1
      local.set 70
      local.get 3
      local.get 70
      i32.store offset=44
    end
    local.get 3
    i32.load offset=44
    local.set 71
    i32.const 48
    local.set 72
    local.get 3
    local.get 72
    i32.add
    local.set 73
    local.get 73
    global.set $__stack_pointer
    local.get 71
    return)"
set_insert,"Set *set, SetValue data",Resized successfully,0 | 1,"
int set_insert(Set *set, SetValue data)
{
	SetEntry *newentry;
	SetEntry *rover;
	unsigned int index;

	/* The hash table becomes less efficient as the number of entries
	 * increases. Check if the percentage used becomes large. */
	if ((set->entries * 3) / set->table_size > 0) {

		/* The table is more than 1/3 full and must be increased
		 * in size */
		if (!set_enlarge(set)) {
			return 0;
		}
	}

	/* Use the hash of the data to determine an index to insert into the
	 * table at. */
	index = set->hash_func(data) % set->table_size;

	/* Walk along this chain and attempt to determine if this data has
	 * already been added to the table */
	rover = set->table[index];

	while (rover != NULL) {

		if (set->equal_func(data, rover->data) != 0) {

			/* This data is already in the set */
			return 0;
		}

		rover = rover->next;
	}

	/* Not in the set.  We must add a new entry. */
	/* Make a new entry for this data */
	newentry = (SetEntry *) malloc(sizeof(SetEntry));

	if (newentry == NULL) {
		return 0;
	}

	newentry->data = data;

	/* Link into chain */
	newentry->next = set->table[index];
	set->table[index] = newentry;

	/* Keep track of the number of entries in the set */
	++set->entries;

	/* Added successfully */
	return 1;
}","(func $set_insert (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 5
    i32.load offset=4
    local.set 6
    i32.const 3
    local.set 7
    local.get 6
    local.get 7
    i32.mul
    local.set 8
    local.get 4
    i32.load offset=24
    local.set 9
    local.get 9
    i32.load offset=8
    local.set 10
    local.get 8
    local.get 10
    i32.div_u
    local.set 11
    i32.const 0
    local.set 12
    local.get 11
    local.get 12
    i32.gt_u
    local.set 13
    i32.const 1
    local.set 14
    local.get 13
    local.get 14
    i32.and
    local.set 15
    block  ;; label = @1
      block  ;; label = @2
        local.get 15
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=24
        local.set 16
        local.get 16
        call $set_enlarge
        local.set 17
        block  ;; label = @3
          local.get 17
          br_if 0 (;@3;)
          i32.const 0
          local.set 18
          local.get 4
          local.get 18
          i32.store offset=28
          br 2 (;@1;)
        end
      end
      local.get 4
      i32.load offset=24
      local.set 19
      local.get 19
      i32.load offset=16
      local.set 20
      local.get 4
      i32.load offset=20
      local.set 21
      local.get 21
      local.get 20
      call_indirect (type 1)
      local.set 22
      local.get 4
      i32.load offset=24
      local.set 23
      local.get 23
      i32.load offset=8
      local.set 24
      local.get 22
      local.get 24
      i32.rem_u
      local.set 25
      local.get 4
      local.get 25
      i32.store offset=8
      local.get 4
      i32.load offset=24
      local.set 26
      local.get 26
      i32.load
      local.set 27
      local.get 4
      i32.load offset=8
      local.set 28
      i32.const 2
      local.set 29
      local.get 28
      local.get 29
      i32.shl
      local.set 30
      local.get 27
      local.get 30
      i32.add
      local.set 31
      local.get 31
      i32.load
      local.set 32
      local.get 4
      local.get 32
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=12
          local.set 33
          i32.const 0
          local.set 34
          local.get 33
          local.get 34
          i32.ne
          local.set 35
          i32.const 1
          local.set 36
          local.get 35
          local.get 36
          i32.and
          local.set 37
          local.get 37
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=24
          local.set 38
          local.get 38
          i32.load offset=20
          local.set 39
          local.get 4
          i32.load offset=20
          local.set 40
          local.get 4
          i32.load offset=12
          local.set 41
          local.get 41
          i32.load
          local.set 42
          local.get 40
          local.get 42
          local.get 39
          call_indirect (type 2)
          local.set 43
          block  ;; label = @4
            local.get 43
            i32.eqz
            br_if 0 (;@4;)
            i32.const 0
            local.set 44
            local.get 4
            local.get 44
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 4
          i32.load offset=12
          local.set 45
          local.get 45
          i32.load offset=4
          local.set 46
          local.get 4
          local.get 46
          i32.store offset=12
          br 0 (;@3;)
        end
      end
      i32.const 8
      local.set 47
      local.get 47
      call $malloc
      local.set 48
      local.get 4
      local.get 48
      i32.store offset=16
      local.get 4
      i32.load offset=16
      local.set 49
      i32.const 0
      local.set 50
      local.get 49
      local.get 50
      i32.eq
      local.set 51
      i32.const 1
      local.set 52
      local.get 51
      local.get 52
      i32.and
      local.set 53
      block  ;; label = @2
        local.get 53
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 54
        local.get 4
        local.get 54
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=20
      local.set 55
      local.get 4
      i32.load offset=16
      local.set 56
      local.get 56
      local.get 55
      i32.store
      local.get 4
      i32.load offset=24
      local.set 57
      local.get 57
      i32.load
      local.set 58
      local.get 4
      i32.load offset=8
      local.set 59
      i32.const 2
      local.set 60
      local.get 59
      local.get 60
      i32.shl
      local.set 61
      local.get 58
      local.get 61
      i32.add
      local.set 62
      local.get 62
      i32.load
      local.set 63
      local.get 4
      i32.load offset=16
      local.set 64
      local.get 64
      local.get 63
      i32.store offset=4
      local.get 4
      i32.load offset=16
      local.set 65
      local.get 4
      i32.load offset=24
      local.set 66
      local.get 66
      i32.load
      local.set 67
      local.get 4
      i32.load offset=8
      local.set 68
      i32.const 2
      local.set 69
      local.get 68
      local.get 69
      i32.shl
      local.set 70
      local.get 67
      local.get 70
      i32.add
      local.set 71
      local.get 71
      local.get 65
      i32.store
      local.get 4
      i32.load offset=24
      local.set 72
      local.get 72
      i32.load offset=4
      local.set 73
      i32.const 1
      local.set 74
      local.get 73
      local.get 74
      i32.add
      local.set 75
      local.get 72
      local.get 75
      i32.store offset=4
      i32.const 1
      local.set 76
      local.get 4
      local.get 76
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 77
    i32.const 32
    local.set 78
    local.get 4
    local.get 78
    i32.add
    local.set 79
    local.get 79
    global.set $__stack_pointer
    local.get 77
    return)"
set_remove,"Set *set, SetValue data",Added successfully,"*/
			set_free_entry(set, entry) | 1 | 0","
int set_remove(Set *set, SetValue data)
{
	SetEntry **rover;
	SetEntry *entry;
	unsigned int index;

	/* Look up the data by its hash key */
	index = set->hash_func(data) % set->table_size;

	/* Search this chain, until the corresponding entry is found */
	rover = &set->table[index];

	while (*rover != NULL) {
		if (set->equal_func(data, (*rover)->data) != 0) {

			/* Found the entry */
			entry = *rover;

			/* Unlink from the linked list */
			*rover = entry->next;

			/* Update counter */
			--set->entries;

			/* Free the entry and return */
			set_free_entry(set, entry);

			return 1;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	/* Not found in set */
	return 0;
}","(func $set_remove (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 5
    i32.load offset=16
    local.set 6
    local.get 4
    i32.load offset=20
    local.set 7
    local.get 7
    local.get 6
    call_indirect (type 1)
    local.set 8
    local.get 4
    i32.load offset=24
    local.set 9
    local.get 9
    i32.load offset=8
    local.set 10
    local.get 8
    local.get 10
    i32.rem_u
    local.set 11
    local.get 4
    local.get 11
    i32.store offset=8
    local.get 4
    i32.load offset=24
    local.set 12
    local.get 12
    i32.load
    local.set 13
    local.get 4
    i32.load offset=8
    local.set 14
    i32.const 2
    local.set 15
    local.get 14
    local.get 15
    i32.shl
    local.set 16
    local.get 13
    local.get 16
    i32.add
    local.set 17
    local.get 4
    local.get 17
    i32.store offset=16
    block  ;; label = @1
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=16
          local.set 18
          local.get 18
          i32.load
          local.set 19
          i32.const 0
          local.set 20
          local.get 19
          local.get 20
          i32.ne
          local.set 21
          i32.const 1
          local.set 22
          local.get 21
          local.get 22
          i32.and
          local.set 23
          local.get 23
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=24
          local.set 24
          local.get 24
          i32.load offset=20
          local.set 25
          local.get 4
          i32.load offset=20
          local.set 26
          local.get 4
          i32.load offset=16
          local.set 27
          local.get 27
          i32.load
          local.set 28
          local.get 28
          i32.load
          local.set 29
          local.get 26
          local.get 29
          local.get 25
          call_indirect (type 2)
          local.set 30
          block  ;; label = @4
            local.get 30
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=16
            local.set 31
            local.get 31
            i32.load
            local.set 32
            local.get 4
            local.get 32
            i32.store offset=12
            local.get 4
            i32.load offset=12
            local.set 33
            local.get 33
            i32.load offset=4
            local.set 34
            local.get 4
            i32.load offset=16
            local.set 35
            local.get 35
            local.get 34
            i32.store
            local.get 4
            i32.load offset=24
            local.set 36
            local.get 36
            i32.load offset=4
            local.set 37
            i32.const -1
            local.set 38
            local.get 37
            local.get 38
            i32.add
            local.set 39
            local.get 36
            local.get 39
            i32.store offset=4
            local.get 4
            i32.load offset=24
            local.set 40
            local.get 4
            i32.load offset=12
            local.set 41
            local.get 40
            local.get 41
            call $set_free_entry
            i32.const 1
            local.set 42
            local.get 4
            local.get 42
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 4
          i32.load offset=16
          local.set 43
          local.get 43
          i32.load
          local.set 44
          i32.const 4
          local.set 45
          local.get 44
          local.get 45
          i32.add
          local.set 46
          local.get 4
          local.get 46
          i32.store offset=16
          br 0 (;@3;)
        end
      end
      i32.const 0
      local.set 47
      local.get 4
      local.get 47
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 48
    i32.const 32
    local.set 49
    local.get 4
    local.get 49
    i32.add
    local.set 50
    local.get 50
    global.set $__stack_pointer
    local.get 48
    return)"
set_query,"Set *set, SetValue data",Not found in set,1 | 0,"
int set_query(Set *set, SetValue data)
{
	SetEntry *rover;
	unsigned int index;

	/* Look up the data by its hash key */
	index = set->hash_func(data) % set->table_size;

	/* Search this chain, until the corresponding entry is found */
	rover = set->table[index];

	while (rover != NULL) {
		if (set->equal_func(data, rover->data) != 0) {

			/* Found the entry */
			return 1;
		}

		/* Advance to the next entry in the chain */
		rover = rover->next;
	}

	/* Not found */
	return 0;
}","(func $set_query (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 5
    i32.load offset=16
    local.set 6
    local.get 4
    i32.load offset=20
    local.set 7
    local.get 7
    local.get 6
    call_indirect (type 1)
    local.set 8
    local.get 4
    i32.load offset=24
    local.set 9
    local.get 9
    i32.load offset=8
    local.set 10
    local.get 8
    local.get 10
    i32.rem_u
    local.set 11
    local.get 4
    local.get 11
    i32.store offset=12
    local.get 4
    i32.load offset=24
    local.set 12
    local.get 12
    i32.load
    local.set 13
    local.get 4
    i32.load offset=12
    local.set 14
    i32.const 2
    local.set 15
    local.get 14
    local.get 15
    i32.shl
    local.set 16
    local.get 13
    local.get 16
    i32.add
    local.set 17
    local.get 17
    i32.load
    local.set 18
    local.get 4
    local.get 18
    i32.store offset=16
    block  ;; label = @1
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=16
          local.set 19
          i32.const 0
          local.set 20
          local.get 19
          local.get 20
          i32.ne
          local.set 21
          i32.const 1
          local.set 22
          local.get 21
          local.get 22
          i32.and
          local.set 23
          local.get 23
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=24
          local.set 24
          local.get 24
          i32.load offset=20
          local.set 25
          local.get 4
          i32.load offset=20
          local.set 26
          local.get 4
          i32.load offset=16
          local.set 27
          local.get 27
          i32.load
          local.set 28
          local.get 26
          local.get 28
          local.get 25
          call_indirect (type 2)
          local.set 29
          block  ;; label = @4
            local.get 29
            i32.eqz
            br_if 0 (;@4;)
            i32.const 1
            local.set 30
            local.get 4
            local.get 30
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 4
          i32.load offset=16
          local.set 31
          local.get 31
          i32.load offset=4
          local.set 32
          local.get 4
          local.get 32
          i32.store offset=16
          br 0 (;@3;)
        end
      end
      i32.const 0
      local.set 33
      local.get 4
      local.get 33
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 34
    i32.const 32
    local.set 35
    local.get 4
    local.get 35
    i32.add
    local.set 36
    local.get 36
    global.set $__stack_pointer
    local.get 34
    return)"
set_iterate,"Set *set, SetIterator *iter","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void set_iterate(Set *set, SetIterator *iter)
{
	unsigned int chain;

	iter->set = set;
	iter->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < set->table_size; ++chain) {

		/* There is a value at the start of this chain */
		if (set->table[chain] != NULL) {
			iter->next_entry = set->table[chain];
			break;
		}
	}

	iter->next_chain = chain;
}","(func $set_iterate (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 6
    local.get 5
    i32.store
    local.get 4
    i32.load offset=8
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.store offset=4
    i32.const 0
    local.set 9
    local.get 4
    local.get 9
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=4
        local.set 10
        local.get 4
        i32.load offset=12
        local.set 11
        local.get 11
        i32.load offset=8
        local.set 12
        local.get 10
        local.get 12
        i32.lt_u
        local.set 13
        i32.const 1
        local.set 14
        local.get 13
        local.get 14
        i32.and
        local.set 15
        local.get 15
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=12
        local.set 16
        local.get 16
        i32.load
        local.set 17
        local.get 4
        i32.load offset=4
        local.set 18
        i32.const 2
        local.set 19
        local.get 18
        local.get 19
        i32.shl
        local.set 20
        local.get 17
        local.get 20
        i32.add
        local.set 21
        local.get 21
        i32.load
        local.set 22
        i32.const 0
        local.set 23
        local.get 22
        local.get 23
        i32.ne
        local.set 24
        i32.const 1
        local.set 25
        local.get 24
        local.get 25
        i32.and
        local.set 26
        block  ;; label = @3
          local.get 26
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=12
          local.set 27
          local.get 27
          i32.load
          local.set 28
          local.get 4
          i32.load offset=4
          local.set 29
          i32.const 2
          local.set 30
          local.get 29
          local.get 30
          i32.shl
          local.set 31
          local.get 28
          local.get 31
          i32.add
          local.set 32
          local.get 32
          i32.load
          local.set 33
          local.get 4
          i32.load offset=8
          local.set 34
          local.get 34
          local.get 33
          i32.store offset=4
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=4
        local.set 35
        i32.const 1
        local.set 36
        local.get 35
        local.get 36
        i32.add
        local.set 37
        local.get 4
        local.get 37
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    local.get 4
    i32.load offset=4
    local.set 38
    local.get 4
    i32.load offset=8
    local.set 39
    local.get 39
    local.get 38
    i32.store offset=8
    return)"
set_iter_has_more,SetIterator *iterator,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",iterator->next_entry != NULL,"
int set_iter_has_more(SetIterator *iterator)
{
	return iterator->next_entry != NULL;
}","(func $set_iter_has_more (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.ne
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    local.get 9
    return)"
slist_free,SListEntry *list,Null value that can be returned without creating a local variable,null,"
void slist_free(SListEntry *list)
{
	SListEntry *entry;

	/* Iterate over each entry, freeing each list entry, until the
	 * end is reached */
	entry = list;

	while (entry != NULL) {
		SListEntry *next;

		next = entry->next;

		free(entry);

		entry = next;
	}
}","(func $slist_free (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 3
    local.get 4
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load offset=8
        local.set 5
        i32.const 0
        local.set 6
        local.get 5
        local.get 6
        i32.ne
        local.set 7
        i32.const 1
        local.set 8
        local.get 7
        local.get 8
        i32.and
        local.set 9
        local.get 9
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load offset=8
        local.set 10
        local.get 10
        i32.load offset=4
        local.set 11
        local.get 3
        local.get 11
        i32.store offset=4
        local.get 3
        i32.load offset=8
        local.set 12
        local.get 12
        call $free
        local.get 3
        i32.load offset=4
        local.set 13
        local.get 3
        local.get 13
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 14
    local.get 3
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    return)"
slist_set_data,"SListEntry *listentry, SListValue data","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void slist_set_data(SListEntry *listentry, SListValue data)
{
	if (listentry != NULL) {
		listentry->data = data;
	}
}","(func $slist_set_data (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.ne
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      local.get 9
      i32.eqz
      br_if 0 (;@1;)
      local.get 4
      i32.load offset=8
      local.set 10
      local.get 4
      i32.load offset=12
      local.set 11
      local.get 11
      local.get 10
      i32.store
    end
    return)"
slist_remove_entry,"SListEntry **list, SListEntry *entry","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",0 | 1,"
int slist_remove_entry(SListEntry **list, SListEntry *entry)
{
	SListEntry *rover;

	/* If the list is empty, or entry is NULL, always fail */
	if (*list == NULL || entry == NULL) {
		return 0;
	}

	/* Action to take is different if the entry is the first in the list */
	if (*list == entry) {

		/* Unlink the first entry and update the starting pointer */
		*list = entry->next;

	} else {

		/* Search through the list to find the preceding entry */
		rover = *list;

		while (rover != NULL && rover->next != entry) {
			rover = rover->next;
		}

		if (rover == NULL) {

			/* Not found in list */
			return 0;

		} else {

			/* rover->next now points at entry, so rover is the
			 * preceding entry. Unlink the entry from the list. */
			rover->next = entry->next;
		}
	}

	/* Free the list entry */
	free(entry);

	/* Operation successful */
	return 1;
}","(func $slist_remove_entry (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    local.get 4
    i32.load offset=8
    local.set 5
    local.get 5
    i32.load
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.eq
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 10
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=4
          local.set 11
          i32.const 0
          local.set 12
          local.get 11
          local.get 12
          i32.eq
          local.set 13
          i32.const 1
          local.set 14
          local.get 13
          local.get 14
          i32.and
          local.set 15
          local.get 15
          i32.eqz
          br_if 1 (;@2;)
        end
        i32.const 0
        local.set 16
        local.get 4
        local.get 16
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=8
      local.set 17
      local.get 17
      i32.load
      local.set 18
      local.get 4
      i32.load offset=4
      local.set 19
      local.get 18
      local.get 19
      i32.eq
      local.set 20
      i32.const 1
      local.set 21
      local.get 20
      local.get 21
      i32.and
      local.set 22
      block  ;; label = @2
        block  ;; label = @3
          local.get 22
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=4
          local.set 23
          local.get 23
          i32.load offset=4
          local.set 24
          local.get 4
          i32.load offset=8
          local.set 25
          local.get 25
          local.get 24
          i32.store
          br 1 (;@2;)
        end
        local.get 4
        i32.load offset=8
        local.set 26
        local.get 26
        i32.load
        local.set 27
        local.get 4
        local.get 27
        i32.store
        loop  ;; label = @3
          local.get 4
          i32.load
          local.set 28
          i32.const 0
          local.set 29
          local.get 28
          local.get 29
          i32.ne
          local.set 30
          i32.const 0
          local.set 31
          i32.const 1
          local.set 32
          local.get 30
          local.get 32
          i32.and
          local.set 33
          local.get 31
          local.set 34
          block  ;; label = @4
            local.get 33
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load
            local.set 35
            local.get 35
            i32.load offset=4
            local.set 36
            local.get 4
            i32.load offset=4
            local.set 37
            local.get 36
            local.get 37
            i32.ne
            local.set 38
            local.get 38
            local.set 34
          end
          local.get 34
          local.set 39
          i32.const 1
          local.set 40
          local.get 39
          local.get 40
          i32.and
          local.set 41
          block  ;; label = @4
            local.get 41
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load
            local.set 42
            local.get 42
            i32.load offset=4
            local.set 43
            local.get 4
            local.get 43
            i32.store
            br 1 (;@3;)
          end
        end
        local.get 4
        i32.load
        local.set 44
        i32.const 0
        local.set 45
        local.get 44
        local.get 45
        i32.eq
        local.set 46
        i32.const 1
        local.set 47
        local.get 46
        local.get 47
        i32.and
        local.set 48
        block  ;; label = @3
          local.get 48
          i32.eqz
          br_if 0 (;@3;)
          i32.const 0
          local.set 49
          local.get 4
          local.get 49
          i32.store offset=12
          br 2 (;@1;)
        end
        local.get 4
        i32.load offset=4
        local.set 50
        local.get 50
        i32.load offset=4
        local.set 51
        local.get 4
        i32.load
        local.set 52
        local.get 52
        local.get 51
        i32.store offset=4
      end
      local.get 4
      i32.load offset=4
      local.set 53
      local.get 53
      call $free
      i32.const 1
      local.set 54
      local.get 4
      local.get 54
      i32.store offset=12
    end
    local.get 4
    i32.load offset=12
    local.set 55
    i32.const 16
    local.set 56
    local.get 4
    local.get 56
    i32.add
    local.set 57
    local.get 57
    global.set $__stack_pointer
    local.get 55
    return)"
slist_sort,"SListEntry **list, SListCompareFunc compare_func","Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",null,"
void slist_sort(SListEntry **list, SListCompareFunc compare_func)
{
	slist_sort_internal(list, compare_func);
}","(func $slist_sort (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 5
    local.get 6
    call $slist_sort_internal
    drop
    i32.const 16
    local.set 7
    local.get 4
    local.get 7
    i32.add
    local.set 8
    local.get 8
    global.set $__stack_pointer
    return)"
slist_iterate,"SListEntry **list, SListIterator *iter",Not found,null,"
void slist_iterate(SListEntry **list, SListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}","(func $slist_iterate (type 4) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    local.get 0
    i32.store offset=12
    local.get 4
    local.get 1
    i32.store offset=8
    local.get 4
    i32.load offset=12
    local.set 5
    local.get 4
    i32.load offset=8
    local.set 6
    local.get 6
    local.get 5
    i32.store
    local.get 4
    i32.load offset=8
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.store offset=4
    return)"
slist_iter_has_more,SListIterator *iter,We have not yet read the first item.,*iter->prev_next != NULL | iter->current->next != NULL,"
int slist_iter_has_more(SListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {

		/* The current entry has not been deleted.  There
		 * is a next entry if current->next is not NULL. */
		return iter->current->next != NULL;
	}
}","(func $slist_iter_has_more (type 2) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 9
          br_if 0 (;@3;)
          local.get 3
          i32.load offset=8
          local.set 10
          local.get 10
          i32.load offset=4
          local.set 11
          local.get 3
          i32.load offset=8
          local.set 12
          local.get 12
          i32.load
          local.set 13
          local.get 13
          i32.load
          local.set 14
          local.get 11
          local.get 14
          i32.ne
          local.set 15
          i32.const 1
          local.set 16
          local.get 15
          local.get 16
          i32.and
          local.set 17
          local.get 17
          i32.eqz
          br_if 1 (;@2;)
        end
        local.get 3
        i32.load offset=8
        local.set 18
        local.get 18
        i32.load
        local.set 19
        local.get 19
        i32.load
        local.set 20
        i32.const 0
        local.set 21
        local.get 20
        local.get 21
        i32.ne
        local.set 22
        i32.const 1
        local.set 23
        local.get 22
        local.get 23
        i32.and
        local.set 24
        local.get 3
        local.get 24
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=8
      local.set 25
      local.get 25
      i32.load offset=4
      local.set 26
      local.get 26
      i32.load offset=4
      local.set 27
      i32.const 0
      local.set 28
      local.get 27
      local.get 28
      i32.ne
      local.set 29
      i32.const 1
      local.set 30
      local.get 29
      local.get 30
      i32.and
      local.set 31
      local.get 3
      local.get 31
      i32.store offset=12
    end
    local.get 3
    i32.load offset=12
    local.set 32
    local.get 32
    return)"
slist_iter_remove,SListIterator *iter,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"
void slist_iter_remove(SListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;
		free(iter->current);
		iter->current = NULL;
	}
}","(func $slist_iter_remove (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load offset=4
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 9
          br_if 0 (;@3;)
          local.get 3
          i32.load offset=12
          local.set 10
          local.get 10
          i32.load offset=4
          local.set 11
          local.get 3
          i32.load offset=12
          local.set 12
          local.get 12
          i32.load
          local.set 13
          local.get 13
          i32.load
          local.set 14
          local.get 11
          local.get 14
          i32.ne
          local.set 15
          i32.const 1
          local.set 16
          local.get 15
          local.get 16
          i32.and
          local.set 17
          local.get 17
          i32.eqz
          br_if 1 (;@2;)
        end
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 18
      local.get 18
      i32.load offset=4
      local.set 19
      local.get 19
      i32.load offset=4
      local.set 20
      local.get 3
      i32.load offset=12
      local.set 21
      local.get 21
      i32.load
      local.set 22
      local.get 22
      local.get 20
      i32.store
      local.get 3
      i32.load offset=12
      local.set 23
      local.get 23
      i32.load offset=4
      local.set 24
      local.get 24
      call $free
      local.get 3
      i32.load offset=12
      local.set 25
      i32.const 0
      local.set 26
      local.get 25
      local.get 26
      i32.store offset=4
    end
    i32.const 16
    local.set 27
    local.get 3
    local.get 27
    i32.add
    local.set 28
    local.get 28
    global.set $__stack_pointer
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""slist_free"" (func $slist_free))
  (export ""slist_prepend"" (func $slist_prepend))
  (export ""slist_append"" (func $slist_append))
  (export ""slist_data"" (func $slist_data))
  (export ""slist_set_data"" (func $slist_set_data))
  (export ""slist_next"" (func $slist_next))
  (export ""slist_nth_entry"" (func $slist_nth_entry))
  (export ""slist_nth_data"" (func $slist_nth_data))
  (export ""slist_length"" (func $slist_length))
  (export ""slist_to_array"" (func $slist_to_array))
  (export ""slist_remove_entry"" (func $slist_remove_entry))
  (export ""slist_remove_data"" (func $slist_remove_data))
  (export ""__indirect_function_table"" (table 0))
  (export ""slist_sort"" (func $slist_sort))
  (export ""slist_find_data"" (func $slist_find_data))
  (export ""slist_iterate"" (func $slist_iterate))
  (export ""slist_iter_has_more"" (func $slist_iter_has_more))
  (export ""slist_iter_next"" (func $slist_iter_next))
  (export ""slist_iter_remove"" (func $slist_iter_remove))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
sortedarray_index_of,"SortedArray *sortedarray, SortedArrayValue data","Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",-1 | (int) index,"int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)
{
	unsigned int left, right, index;
	int order;

	if (sortedarray == NULL) {
		return -1;
	}

	left = 0;
	right = sortedarray->length;
	index = 0;

	/* safe subtract 1 of right without going negative */
	right = (right > 1) ? right : 0;

	while (left != right) {
		index = (left + right) / 2;
		order = sortedarray->cmp_func(data, sortedarray->data[index]);

		if (order < 0) {
			/* value should be left */
			right = index;
		} else if (order > 0) {
			/* value should be right */
			left = index + 1;
		} else {
			return (int) index;
		}
	}

	return -1;
}","(func $sortedarray_index_of (type 0) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        local.get 9
        i32.eqz
        br_if 0 (;@2;)
        i32.const -1
        local.set 10
        local.get 4
        local.get 10
        i32.store offset=28
        br 1 (;@1;)
      end
      i32.const 0
      local.set 11
      local.get 4
      local.get 11
      i32.store offset=16
      local.get 4
      i32.load offset=24
      local.set 12
      local.get 12
      i32.load offset=4
      local.set 13
      local.get 4
      local.get 13
      i32.store offset=12
      i32.const 0
      local.set 14
      local.get 4
      local.get 14
      i32.store offset=8
      local.get 4
      i32.load offset=12
      local.set 15
      i32.const 1
      local.set 16
      local.get 15
      local.get 16
      i32.gt_u
      local.set 17
      i32.const 1
      local.set 18
      local.get 17
      local.get 18
      i32.and
      local.set 19
      block  ;; label = @2
        block  ;; label = @3
          local.get 19
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=12
          local.set 20
          local.get 20
          local.set 21
          br 1 (;@2;)
        end
        i32.const 0
        local.set 22
        local.get 22
        local.set 21
      end
      local.get 21
      local.set 23
      local.get 4
      local.get 23
      i32.store offset=12
      block  ;; label = @2
        loop  ;; label = @3
          local.get 4
          i32.load offset=16
          local.set 24
          local.get 4
          i32.load offset=12
          local.set 25
          local.get 24
          local.get 25
          i32.ne
          local.set 26
          i32.const 1
          local.set 27
          local.get 26
          local.get 27
          i32.and
          local.set 28
          local.get 28
          i32.eqz
          br_if 1 (;@2;)
          local.get 4
          i32.load offset=16
          local.set 29
          local.get 4
          i32.load offset=12
          local.set 30
          local.get 29
          local.get 30
          i32.add
          local.set 31
          i32.const 1
          local.set 32
          local.get 31
          local.get 32
          i32.shr_u
          local.set 33
          local.get 4
          local.get 33
          i32.store offset=8
          local.get 4
          i32.load offset=24
          local.set 34
          local.get 34
          i32.load offset=12
          local.set 35
          local.get 4
          i32.load offset=20
          local.set 36
          local.get 4
          i32.load offset=24
          local.set 37
          local.get 37
          i32.load
          local.set 38
          local.get 4
          i32.load offset=8
          local.set 39
          i32.const 2
          local.set 40
          local.get 39
          local.get 40
          i32.shl
          local.set 41
          local.get 38
          local.get 41
          i32.add
          local.set 42
          local.get 42
          i32.load
          local.set 43
          local.get 36
          local.get 43
          local.get 35
          call_indirect (type 0)
          local.set 44
          local.get 4
          local.get 44
          i32.store offset=4
          local.get 4
          i32.load offset=4
          local.set 45
          i32.const 0
          local.set 46
          local.get 45
          local.get 46
          i32.lt_s
          local.set 47
          i32.const 1
          local.set 48
          local.get 47
          local.get 48
          i32.and
          local.set 49
          block  ;; label = @4
            block  ;; label = @5
              local.get 49
              i32.eqz
              br_if 0 (;@5;)
              local.get 4
              i32.load offset=8
              local.set 50
              local.get 4
              local.get 50
              i32.store offset=12
              br 1 (;@4;)
            end
            local.get 4
            i32.load offset=4
            local.set 51
            i32.const 0
            local.set 52
            local.get 51
            local.get 52
            i32.gt_s
            local.set 53
            i32.const 1
            local.set 54
            local.get 53
            local.get 54
            i32.and
            local.set 55
            block  ;; label = @5
              block  ;; label = @6
                local.get 55
                i32.eqz
                br_if 0 (;@6;)
                local.get 4
                i32.load offset=8
                local.set 56
                i32.const 1
                local.set 57
                local.get 56
                local.get 57
                i32.add
                local.set 58
                local.get 4
                local.get 58
                i32.store offset=16
                br 1 (;@5;)
              end
              local.get 4
              i32.load offset=8
              local.set 59
              local.get 4
              local.get 59
              i32.store offset=28
              br 4 (;@1;)
            end
          end
          br 0 (;@3;)
        end
      end
      i32.const -1
      local.set 60
      local.get 4
      local.get 60
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 61
    i32.const 32
    local.set 62
    local.get 4
    local.get 62
    i32.add
    local.set 63
    local.get 63
    global.set $__stack_pointer
    local.get 61
    return)"
sortedarray_clear,SortedArray *sortedarray,"Sorts a collection of elements using the provided comparison function.
Performs recursive or iterative ordering and updates the container in-place.",null,"
void sortedarray_clear(SortedArray *sortedarray)
{
	/* set length to 0 */
	sortedarray->length = 0;
}","(func $sortedarray_clear (type 2) (param i32)
    (local i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=4
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1024))
  (global (;4;) i32 (i32.const 66560))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66560))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""sortedarray_get"" (func $sortedarray_get))
  (export ""sortedarray_length"" (func $sortedarray_length))
  (export ""sortedarray_new"" (func $sortedarray_new))
  (export ""sortedarray_free"" (func $sortedarray_free))
  (export ""sortedarray_remove"" (func $sortedarray_remove))
  (export ""sortedarray_remove_range"" (func $sortedarray_remove_range))
  (export ""sortedarray_insert"" (func $sortedarray_insert))
  (export ""__indirect_function_table"" (table 0))
  (export ""sortedarray_index_of"" (func $sortedarray_index_of))
  (export ""sortedarray_clear"" (func $sortedarray_clear))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9)))"
trie_insert_rollback,"Trie *trie, unsigned char *key","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"static void trie_insert_rollback(Trie *trie, unsigned char *key)
{
	TrieNode *node;
	TrieNode **prev_ptr;
	TrieNode *next_node;
	TrieNode **next_prev_ptr;
	unsigned char *p;

	/* Follow the chain along.  We know that we will never reach the
	 * end of the string because trie_insert never got that far.  As a
	 * result, it is not necessary to check for the end of string
	 * delimiter (NUL) */
	node = trie->root_node;
	prev_ptr = &trie->root_node;
	p = key;

	while (node != NULL) {

		/* Find the next node now. We might free this node. */
		next_prev_ptr = &node->next[(unsigned char) *p];
		next_node = *next_prev_ptr;
		++p;

		/* Decrease the use count and free the node if it
		 * reaches zero. */
		--node->use_count;

		if (node->use_count == 0) {
			free(node);

			if (prev_ptr != NULL) {
				*prev_ptr = NULL;
			}

			next_prev_ptr = NULL;
		}

		/* Update pointers */
		node = next_node;
		prev_ptr = next_prev_ptr;
	}
}","(func $trie_insert_rollback (type 6) (param i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=28
    local.get 4
    local.get 1
    i32.store offset=24
    local.get 4
    i32.load offset=28
    local.set 5
    local.get 5
    i32.load
    local.set 6
    local.get 4
    local.get 6
    i32.store offset=20
    local.get 4
    i32.load offset=28
    local.set 7
    local.get 4
    local.get 7
    i32.store offset=16
    local.get 4
    i32.load offset=24
    local.set 8
    local.get 4
    local.get 8
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 4
        i32.load offset=20
        local.set 9
        i32.const 0
        local.set 10
        local.get 9
        local.get 10
        i32.ne
        local.set 11
        i32.const 1
        local.set 12
        local.get 11
        local.get 12
        i32.and
        local.set 13
        local.get 13
        i32.eqz
        br_if 1 (;@1;)
        local.get 4
        i32.load offset=20
        local.set 14
        i32.const 8
        local.set 15
        local.get 14
        local.get 15
        i32.add
        local.set 16
        local.get 4
        i32.load offset=4
        local.set 17
        local.get 17
        i32.load8_u
        local.set 18
        i32.const 255
        local.set 19
        local.get 18
        local.get 19
        i32.and
        local.set 20
        i32.const 2
        local.set 21
        local.get 20
        local.get 21
        i32.shl
        local.set 22
        local.get 16
        local.get 22
        i32.add
        local.set 23
        local.get 4
        local.get 23
        i32.store offset=8
        local.get 4
        i32.load offset=8
        local.set 24
        local.get 24
        i32.load
        local.set 25
        local.get 4
        local.get 25
        i32.store offset=12
        local.get 4
        i32.load offset=4
        local.set 26
        i32.const 1
        local.set 27
        local.get 26
        local.get 27
        i32.add
        local.set 28
        local.get 4
        local.get 28
        i32.store offset=4
        local.get 4
        i32.load offset=20
        local.set 29
        local.get 29
        i32.load offset=4
        local.set 30
        i32.const -1
        local.set 31
        local.get 30
        local.get 31
        i32.add
        local.set 32
        local.get 29
        local.get 32
        i32.store offset=4
        local.get 4
        i32.load offset=20
        local.set 33
        local.get 33
        i32.load offset=4
        local.set 34
        block  ;; label = @3
          local.get 34
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=20
          local.set 35
          local.get 35
          call $free
          local.get 4
          i32.load offset=16
          local.set 36
          i32.const 0
          local.set 37
          local.get 36
          local.get 37
          i32.ne
          local.set 38
          i32.const 1
          local.set 39
          local.get 38
          local.get 39
          i32.and
          local.set 40
          block  ;; label = @4
            local.get 40
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=16
            local.set 41
            i32.const 0
            local.set 42
            local.get 41
            local.get 42
            i32.store
          end
          i32.const 0
          local.set 43
          local.get 4
          local.get 43
          i32.store offset=8
        end
        local.get 4
        i32.load offset=12
        local.set 44
        local.get 4
        local.get 44
        i32.store offset=20
        local.get 4
        i32.load offset=8
        local.set 45
        local.get 4
        local.get 45
        i32.store offset=16
        br 0 (;@2;)
      end
    end
    i32.const 32
    local.set 46
    local.get 4
    local.get 46
    i32.add
    local.set 47
    local.get 47
    global.set $__stack_pointer
    return)"
trie_value_is_null,TrieValue *v,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.","!memcmp(v, &trie_null_value, sizeof(TrieValue))","
static int trie_value_is_null(TrieValue *v)
{
	return !memcmp(v, &trie_null_value, sizeof(TrieValue));
}","(func $trie_value_is_null (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    i32.load align=1
    local.set 5
    i32.const 0
    local.set 6
    local.get 5
    local.get 6
    i32.ne
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.ne
    local.set 9
    i32.const -1
    local.set 10
    local.get 9
    local.get 10
    i32.xor
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.and
    local.set 13
    local.get 13
    return)"
trie_insert,"Trie *trie, char *key, TrieValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.","0 | success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value | 1","
int trie_insert(Trie *trie, char *key, TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	char *p;
	int c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end(trie, key);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = key;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie,
				                     (unsigned char *) key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) *p;

		/* Reached the end of string?  If so, we're finished. */
		if (c == '\0') {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}

int trie_insert_binary(Trie *trie, unsigned char *key, int key_length,
                       TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	int p, c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end_binary(trie, key, key_length);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = 0;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie, key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) key[p];

		/* Reached the end of string?  If so, we're finished. */
		if (p == key_length) {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}","(func $trie_insert (type 5) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 32
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=24
    local.get 5
    local.get 1
    i32.store offset=20
    local.get 5
    local.get 2
    i32.store offset=16
    i32.const 16
    local.set 6
    local.get 5
    local.get 6
    i32.add
    local.set 7
    local.get 7
    local.set 8
    local.get 8
    call $trie_value_is_null
    local.set 9
    block  ;; label = @1
      block  ;; label = @2
        local.get 9
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 10
        local.get 5
        local.get 10
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=24
      local.set 11
      local.get 5
      i32.load offset=20
      local.set 12
      local.get 11
      local.get 12
      call $trie_find_end
      local.set 13
      local.get 5
      local.get 13
      i32.store offset=8
      local.get 5
      i32.load offset=8
      local.set 14
      i32.const 0
      local.set 15
      local.get 14
      local.get 15
      i32.ne
      local.set 16
      i32.const 1
      local.set 17
      local.get 16
      local.get 17
      i32.and
      local.set 18
      block  ;; label = @2
        local.get 18
        i32.eqz
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=8
        local.set 19
        local.get 19
        call $trie_value_is_null
        local.set 20
        local.get 20
        br_if 0 (;@2;)
        local.get 5
        i32.load offset=16
        local.set 21
        local.get 5
        i32.load offset=8
        local.set 22
        local.get 22
        local.get 21
        i32.store
        i32.const 1
        local.set 23
        local.get 5
        local.get 23
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=24
      local.set 24
      local.get 5
      local.get 24
      i32.store offset=12
      local.get 5
      i32.load offset=20
      local.set 25
      local.get 5
      local.get 25
      i32.store offset=4
      loop  ;; label = @2
        local.get 5
        i32.load offset=12
        local.set 26
        local.get 26
        i32.load
        local.set 27
        local.get 5
        local.get 27
        i32.store offset=8
        local.get 5
        i32.load offset=8
        local.set 28
        i32.const 0
        local.set 29
        local.get 28
        local.get 29
        i32.eq
        local.set 30
        i32.const 1
        local.set 31
        local.get 30
        local.get 31
        i32.and
        local.set 32
        block  ;; label = @3
          local.get 32
          i32.eqz
          br_if 0 (;@3;)
          i32.const 1
          local.set 33
          i32.const 1032
          local.set 34
          local.get 33
          local.get 34
          call $calloc
          local.set 35
          local.get 5
          local.get 35
          i32.store offset=8
          local.get 5
          i32.load offset=8
          local.set 36
          i32.const 0
          local.set 37
          local.get 36
          local.get 37
          i32.eq
          local.set 38
          i32.const 1
          local.set 39
          local.get 38
          local.get 39
          i32.and
          local.set 40
          block  ;; label = @4
            local.get 40
            i32.eqz
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=24
            local.set 41
            local.get 5
            i32.load offset=20
            local.set 42
            local.get 41
            local.get 42
            call $trie_insert_rollback
            i32.const 0
            local.set 43
            local.get 5
            local.get 43
            i32.store offset=28
            br 3 (;@1;)
          end
          local.get 5
          i32.load offset=8
          local.set 44
          i32.const 0
          local.set 45
          local.get 44
          local.get 45
          i32.store
          local.get 5
          i32.load offset=8
          local.set 46
          local.get 5
          i32.load offset=12
          local.set 47
          local.get 47
          local.get 46
          i32.store
        end
        local.get 5
        i32.load offset=8
        local.set 48
        local.get 48
        i32.load offset=4
        local.set 49
        i32.const 1
        local.set 50
        local.get 49
        local.get 50
        i32.add
        local.set 51
        local.get 48
        local.get 51
        i32.store offset=4
        local.get 5
        i32.load offset=4
        local.set 52
        local.get 52
        i32.load8_u
        local.set 53
        i32.const 255
        local.set 54
        local.get 53
        local.get 54
        i32.and
        local.set 55
        local.get 5
        local.get 55
        i32.store
        local.get 5
        i32.load
        local.set 56
        block  ;; label = @3
          block  ;; label = @4
            local.get 56
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=16
            local.set 57
            local.get 5
            i32.load offset=8
            local.set 58
            local.get 58
            local.get 57
            i32.store
            br 1 (;@3;)
          end
          local.get 5
          i32.load offset=8
          local.set 59
          i32.const 8
          local.set 60
          local.get 59
          local.get 60
          i32.add
          local.set 61
          local.get 5
          i32.load
          local.set 62
          i32.const 2
          local.set 63
          local.get 62
          local.get 63
          i32.shl
          local.set 64
          local.get 61
          local.get 64
          i32.add
          local.set 65
          local.get 5
          local.get 65
          i32.store offset=12
          local.get 5
          i32.load offset=4
          local.set 66
          i32.const 1
          local.set 67
          local.get 66
          local.get 67
          i32.add
          local.set 68
          local.get 5
          local.get 68
          i32.store offset=4
          br 1 (;@2;)
        end
      end
      i32.const 1
      local.set 69
      local.get 5
      local.get 69
      i32.store offset=28
    end
    local.get 5
    i32.load offset=28
    local.set 70
    i32.const 32
    local.set 71
    local.get 5
    local.get 71
    i32.add
    local.set 72
    local.get 72
    global.set $__stack_pointer
    local.get 70
    return)"
trie_insert_binary,"Trie *trie, unsigned char *key, int key_length, TrieValue value","Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.","0 | success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value | 1","
int trie_insert_binary(Trie *trie, unsigned char *key, int key_length,
                       TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	int p, c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end_binary(trie, key, key_length);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = 0;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie, key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) key[p];

		/* Reached the end of string?  If so, we're finished. */
		if (p == key_length) {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}

int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	int p, c;

	/* Find the end node and remove the value */
	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = 0;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) key[p];
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (p == key_length) {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}","(func $trie_insert_binary (type 7) (param i32 i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 4
    i32.const 48
    local.set 5
    local.get 4
    local.get 5
    i32.sub
    local.set 6
    local.get 6
    global.set $__stack_pointer
    local.get 6
    local.get 0
    i32.store offset=40
    local.get 6
    local.get 1
    i32.store offset=36
    local.get 6
    local.get 2
    i32.store offset=32
    local.get 6
    local.get 3
    i32.store offset=28
    i32.const 28
    local.set 7
    local.get 6
    local.get 7
    i32.add
    local.set 8
    local.get 8
    local.set 9
    local.get 9
    call $trie_value_is_null
    local.set 10
    block  ;; label = @1
      block  ;; label = @2
        local.get 10
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 11
        local.get 6
        local.get 11
        i32.store offset=44
        br 1 (;@1;)
      end
      local.get 6
      i32.load offset=40
      local.set 12
      local.get 6
      i32.load offset=36
      local.set 13
      local.get 6
      i32.load offset=32
      local.set 14
      local.get 12
      local.get 13
      local.get 14
      call $trie_find_end_binary
      local.set 15
      local.get 6
      local.get 15
      i32.store offset=20
      local.get 6
      i32.load offset=20
      local.set 16
      i32.const 0
      local.set 17
      local.get 16
      local.get 17
      i32.ne
      local.set 18
      i32.const 1
      local.set 19
      local.get 18
      local.get 19
      i32.and
      local.set 20
      block  ;; label = @2
        local.get 20
        i32.eqz
        br_if 0 (;@2;)
        local.get 6
        i32.load offset=20
        local.set 21
        local.get 21
        call $trie_value_is_null
        local.set 22
        local.get 22
        br_if 0 (;@2;)
        local.get 6
        i32.load offset=28
        local.set 23
        local.get 6
        i32.load offset=20
        local.set 24
        local.get 24
        local.get 23
        i32.store
        i32.const 1
        local.set 25
        local.get 6
        local.get 25
        i32.store offset=44
        br 1 (;@1;)
      end
      local.get 6
      i32.load offset=40
      local.set 26
      local.get 6
      local.get 26
      i32.store offset=24
      i32.const 0
      local.set 27
      local.get 6
      local.get 27
      i32.store offset=16
      loop  ;; label = @2
        local.get 6
        i32.load offset=24
        local.set 28
        local.get 28
        i32.load
        local.set 29
        local.get 6
        local.get 29
        i32.store offset=20
        local.get 6
        i32.load offset=20
        local.set 30
        i32.const 0
        local.set 31
        local.get 30
        local.get 31
        i32.eq
        local.set 32
        i32.const 1
        local.set 33
        local.get 32
        local.get 33
        i32.and
        local.set 34
        block  ;; label = @3
          local.get 34
          i32.eqz
          br_if 0 (;@3;)
          i32.const 1
          local.set 35
          i32.const 1032
          local.set 36
          local.get 35
          local.get 36
          call $calloc
          local.set 37
          local.get 6
          local.get 37
          i32.store offset=20
          local.get 6
          i32.load offset=20
          local.set 38
          i32.const 0
          local.set 39
          local.get 38
          local.get 39
          i32.eq
          local.set 40
          i32.const 1
          local.set 41
          local.get 40
          local.get 41
          i32.and
          local.set 42
          block  ;; label = @4
            local.get 42
            i32.eqz
            br_if 0 (;@4;)
            local.get 6
            i32.load offset=40
            local.set 43
            local.get 6
            i32.load offset=36
            local.set 44
            local.get 43
            local.get 44
            call $trie_insert_rollback
            i32.const 0
            local.set 45
            local.get 6
            local.get 45
            i32.store offset=44
            br 3 (;@1;)
          end
          local.get 6
          i32.load offset=20
          local.set 46
          i32.const 0
          local.set 47
          local.get 46
          local.get 47
          i32.store
          local.get 6
          i32.load offset=20
          local.set 48
          local.get 6
          i32.load offset=24
          local.set 49
          local.get 49
          local.get 48
          i32.store
        end
        local.get 6
        i32.load offset=20
        local.set 50
        local.get 50
        i32.load offset=4
        local.set 51
        i32.const 1
        local.set 52
        local.get 51
        local.get 52
        i32.add
        local.set 53
        local.get 50
        local.get 53
        i32.store offset=4
        local.get 6
        i32.load offset=36
        local.set 54
        local.get 6
        i32.load offset=16
        local.set 55
        local.get 54
        local.get 55
        i32.add
        local.set 56
        local.get 56
        i32.load8_u
        local.set 57
        i32.const 255
        local.set 58
        local.get 57
        local.get 58
        i32.and
        local.set 59
        local.get 6
        local.get 59
        i32.store offset=12
        local.get 6
        i32.load offset=16
        local.set 60
        local.get 6
        i32.load offset=32
        local.set 61
        local.get 60
        local.get 61
        i32.eq
        local.set 62
        i32.const 1
        local.set 63
        local.get 62
        local.get 63
        i32.and
        local.set 64
        block  ;; label = @3
          block  ;; label = @4
            local.get 64
            i32.eqz
            br_if 0 (;@4;)
            local.get 6
            i32.load offset=28
            local.set 65
            local.get 6
            i32.load offset=20
            local.set 66
            local.get 66
            local.get 65
            i32.store
            br 1 (;@3;)
          end
          local.get 6
          i32.load offset=20
          local.set 67
          i32.const 8
          local.set 68
          local.get 67
          local.get 68
          i32.add
          local.set 69
          local.get 6
          i32.load offset=12
          local.set 70
          i32.const 2
          local.set 71
          local.get 70
          local.get 71
          i32.shl
          local.set 72
          local.get 69
          local.get 72
          i32.add
          local.set 73
          local.get 6
          local.get 73
          i32.store offset=24
          local.get 6
          i32.load offset=16
          local.set 74
          i32.const 1
          local.set 75
          local.get 74
          local.get 75
          i32.add
          local.set 76
          local.get 6
          local.get 76
          i32.store offset=16
          br 1 (;@2;)
        end
      end
      i32.const 1
      local.set 77
      local.get 6
      local.get 77
      i32.store offset=44
    end
    local.get 6
    i32.load offset=44
    local.set 78
    i32.const 48
    local.set 79
    local.get 6
    local.get 79
    i32.add
    local.set 80
    local.get 80
    global.set $__stack_pointer
    local.get 78
    return)"
trie_remove_binary,"Trie *trie, unsigned char *key, int key_length","Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",0 | 1,"
int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	int p, c;

	/* Find the end node and remove the value */
	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = 0;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) key[p];
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (p == key_length) {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}

int trie_remove(Trie *trie, char *key)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	char *p;
	int c;

	/* Find the end node and remove the value */
	node = trie_find_end(trie, key);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = key;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) *p;
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (c == '\0') {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}","(func $trie_remove_binary (type 5) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 48
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    global.set $__stack_pointer
    local.get 5
    local.get 0
    i32.store offset=40
    local.get 5
    local.get 1
    i32.store offset=36
    local.get 5
    local.get 2
    i32.store offset=32
    local.get 5
    i32.load offset=40
    local.set 6
    local.get 5
    i32.load offset=36
    local.set 7
    local.get 5
    i32.load offset=32
    local.set 8
    local.get 6
    local.get 7
    local.get 8
    call $trie_find_end_binary
    local.set 9
    local.get 5
    local.get 9
    i32.store offset=28
    local.get 5
    i32.load offset=28
    local.set 10
    i32.const 0
    local.set 11
    local.get 10
    local.get 11
    i32.ne
    local.set 12
    i32.const 1
    local.set 13
    local.get 12
    local.get 13
    i32.and
    local.set 14
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 14
          i32.eqz
          br_if 0 (;@3;)
          local.get 5
          i32.load offset=28
          local.set 15
          local.get 15
          call $trie_value_is_null
          local.set 16
          local.get 16
          br_if 0 (;@3;)
          local.get 5
          i32.load offset=28
          local.set 17
          i32.const 0
          local.set 18
          local.get 17
          local.get 18
          i32.store
          br 1 (;@2;)
        end
        i32.const 0
        local.set 19
        local.get 5
        local.get 19
        i32.store offset=44
        br 1 (;@1;)
      end
      local.get 5
      i32.load offset=40
      local.set 20
      local.get 20
      i32.load
      local.set 21
      local.get 5
      local.get 21
      i32.store offset=28
      local.get 5
      i32.load offset=40
      local.set 22
      local.get 5
      local.get 22
      i32.store offset=20
      i32.const 0
      local.set 23
      local.get 5
      local.get 23
      i32.store offset=16
      loop  ;; label = @2
        local.get 5
        i32.load offset=36
        local.set 24
        local.get 5
        i32.load offset=16
        local.set 25
        local.get 24
        local.get 25
        i32.add
        local.set 26
        local.get 26
        i32.load8_u
        local.set 27
        i32.const 255
        local.set 28
        local.get 27
        local.get 28
        i32.and
        local.set 29
        local.get 5
        local.get 29
        i32.store offset=12
        local.get 5
        i32.load offset=28
        local.set 30
        i32.const 8
        local.set 31
        local.get 30
        local.get 31
        i32.add
        local.set 32
        local.get 5
        i32.load offset=12
        local.set 33
        i32.const 2
        local.set 34
        local.get 33
        local.get 34
        i32.shl
        local.set 35
        local.get 32
        local.get 35
        i32.add
        local.set 36
        local.get 36
        i32.load
        local.set 37
        local.get 5
        local.get 37
        i32.store offset=24
        local.get 5
        i32.load offset=28
        local.set 38
        local.get 38
        i32.load offset=4
        local.set 39
        i32.const -1
        local.set 40
        local.get 39
        local.get 40
        i32.add
        local.set 41
        local.get 38
        local.get 41
        i32.store offset=4
        local.get 5
        i32.load offset=28
        local.set 42
        local.get 42
        i32.load offset=4
        local.set 43
        i32.const 0
        local.set 44
        local.get 43
        local.get 44
        i32.le_u
        local.set 45
        i32.const 1
        local.set 46
        local.get 45
        local.get 46
        i32.and
        local.set 47
        block  ;; label = @3
          local.get 47
          i32.eqz
          br_if 0 (;@3;)
          local.get 5
          i32.load offset=28
          local.set 48
          local.get 48
          call $free
          local.get 5
          i32.load offset=20
          local.set 49
          i32.const 0
          local.set 50
          local.get 49
          local.get 50
          i32.ne
          local.set 51
          i32.const 1
          local.set 52
          local.get 51
          local.get 52
          i32.and
          local.set 53
          block  ;; label = @4
            local.get 53
            i32.eqz
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=20
            local.set 54
            i32.const 0
            local.set 55
            local.get 54
            local.get 55
            i32.store
            i32.const 0
            local.set 56
            local.get 5
            local.get 56
            i32.store offset=20
          end
        end
        local.get 5
        i32.load offset=16
        local.set 57
        local.get 5
        i32.load offset=32
        local.set 58
        local.get 57
        local.get 58
        i32.eq
        local.set 59
        i32.const 1
        local.set 60
        local.get 59
        local.get 60
        i32.and
        local.set 61
        block  ;; label = @3
          block  ;; label = @4
            local.get 61
            i32.eqz
            br_if 0 (;@4;)
            br 1 (;@3;)
          end
          local.get 5
          i32.load offset=16
          local.set 62
          i32.const 1
          local.set 63
          local.get 62
          local.get 63
          i32.add
          local.set 64
          local.get 5
          local.get 64
          i32.store offset=16
          local.get 5
          i32.load offset=20
          local.set 65
          i32.const 0
          local.set 66
          local.get 65
          local.get 66
          i32.ne
          local.set 67
          i32.const 1
          local.set 68
          local.get 67
          local.get 68
          i32.and
          local.set 69
          block  ;; label = @4
            local.get 69
            i32.eqz
            br_if 0 (;@4;)
            local.get 5
            i32.load offset=28
            local.set 70
            i32.const 8
            local.set 71
            local.get 70
            local.get 71
            i32.add
            local.set 72
            local.get 5
            i32.load offset=12
            local.set 73
            i32.const 2
            local.set 74
            local.get 73
            local.get 74
            i32.shl
            local.set 75
            local.get 72
            local.get 75
            i32.add
            local.set 76
            local.get 5
            local.get 76
            i32.store offset=20
          end
          local.get 5
          i32.load offset=24
          local.set 77
          local.get 5
          local.get 77
          i32.store offset=28
          br 1 (;@2;)
        end
      end
      i32.const 1
      local.set 78
      local.get 5
      local.get 78
      i32.store offset=44
    end
    local.get 5
    i32.load offset=44
    local.set 79
    i32.const 48
    local.set 80
    local.get 5
    local.get 80
    i32.add
    local.set 81
    local.get 81
    global.set $__stack_pointer
    local.get 79
    return)"
trie_remove,"Trie *trie, char *key",Removed successfully,0 | 1 | node->data | trie_null_value | trie->root_node->use_count,"
int trie_remove(Trie *trie, char *key)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	char *p;
	int c;

	/* Find the end node and remove the value */
	node = trie_find_end(trie, key);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = key;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) *p;
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (c == '\0') {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}

TrieValue trie_lookup(Trie *trie, char *key)
{
	TrieNode *node;

	node = trie_find_end(trie, key);

	if (node != NULL) {
		return node->data;
	} else {
		return trie_null_value;
	}
}

TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;

	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL) {
		return node->data;
	} else {
		return trie_null_value;
	}
}

unsigned int trie_num_entries(Trie *trie)
{
	/* To find the number of entries, simply look at the use count
	 * of the root node. */
	if (trie->root_node == NULL) {
		return 0;
	} else {
		return trie->root_node->use_count;
	}
}
","(func $trie_remove (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 4
    i32.load offset=20
    local.set 6
    local.get 5
    local.get 6
    call $trie_find_end
    local.set 7
    local.get 4
    local.get 7
    i32.store offset=16
    local.get 4
    i32.load offset=16
    local.set 8
    i32.const 0
    local.set 9
    local.get 8
    local.get 9
    i32.ne
    local.set 10
    i32.const 1
    local.set 11
    local.get 10
    local.get 11
    i32.and
    local.set 12
    block  ;; label = @1
      block  ;; label = @2
        block  ;; label = @3
          local.get 12
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=16
          local.set 13
          local.get 13
          call $trie_value_is_null
          local.set 14
          local.get 14
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=16
          local.set 15
          i32.const 0
          local.set 16
          local.get 15
          local.get 16
          i32.store
          br 1 (;@2;)
        end
        i32.const 0
        local.set 17
        local.get 4
        local.get 17
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=24
      local.set 18
      local.get 18
      i32.load
      local.set 19
      local.get 4
      local.get 19
      i32.store offset=16
      local.get 4
      i32.load offset=24
      local.set 20
      local.get 4
      local.get 20
      i32.store offset=8
      local.get 4
      i32.load offset=20
      local.set 21
      local.get 4
      local.get 21
      i32.store offset=4
      loop  ;; label = @2
        local.get 4
        i32.load offset=4
        local.set 22
        local.get 22
        i32.load8_u
        local.set 23
        i32.const 255
        local.set 24
        local.get 23
        local.get 24
        i32.and
        local.set 25
        local.get 4
        local.get 25
        i32.store
        local.get 4
        i32.load offset=16
        local.set 26
        i32.const 8
        local.set 27
        local.get 26
        local.get 27
        i32.add
        local.set 28
        local.get 4
        i32.load
        local.set 29
        i32.const 2
        local.set 30
        local.get 29
        local.get 30
        i32.shl
        local.set 31
        local.get 28
        local.get 31
        i32.add
        local.set 32
        local.get 32
        i32.load
        local.set 33
        local.get 4
        local.get 33
        i32.store offset=12
        local.get 4
        i32.load offset=16
        local.set 34
        local.get 34
        i32.load offset=4
        local.set 35
        i32.const -1
        local.set 36
        local.get 35
        local.get 36
        i32.add
        local.set 37
        local.get 34
        local.get 37
        i32.store offset=4
        local.get 4
        i32.load offset=16
        local.set 38
        local.get 38
        i32.load offset=4
        local.set 39
        i32.const 0
        local.set 40
        local.get 39
        local.get 40
        i32.le_u
        local.set 41
        i32.const 1
        local.set 42
        local.get 41
        local.get 42
        i32.and
        local.set 43
        block  ;; label = @3
          local.get 43
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=16
          local.set 44
          local.get 44
          call $free
          local.get 4
          i32.load offset=8
          local.set 45
          i32.const 0
          local.set 46
          local.get 45
          local.get 46
          i32.ne
          local.set 47
          i32.const 1
          local.set 48
          local.get 47
          local.get 48
          i32.and
          local.set 49
          block  ;; label = @4
            local.get 49
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=8
            local.set 50
            i32.const 0
            local.set 51
            local.get 50
            local.get 51
            i32.store
            i32.const 0
            local.set 52
            local.get 4
            local.get 52
            i32.store offset=8
          end
        end
        local.get 4
        i32.load
        local.set 53
        block  ;; label = @3
          block  ;; label = @4
            local.get 53
            br_if 0 (;@4;)
            br 1 (;@3;)
          end
          local.get 4
          i32.load offset=4
          local.set 54
          i32.const 1
          local.set 55
          local.get 54
          local.get 55
          i32.add
          local.set 56
          local.get 4
          local.get 56
          i32.store offset=4
          local.get 4
          i32.load offset=8
          local.set 57
          i32.const 0
          local.set 58
          local.get 57
          local.get 58
          i32.ne
          local.set 59
          i32.const 1
          local.set 60
          local.get 59
          local.get 60
          i32.and
          local.set 61
          block  ;; label = @4
            local.get 61
            i32.eqz
            br_if 0 (;@4;)
            local.get 4
            i32.load offset=16
            local.set 62
            i32.const 8
            local.set 63
            local.get 62
            local.get 63
            i32.add
            local.set 64
            local.get 4
            i32.load
            local.set 65
            i32.const 2
            local.set 66
            local.get 65
            local.get 66
            i32.shl
            local.set 67
            local.get 64
            local.get 67
            i32.add
            local.set 68
            local.get 4
            local.get 68
            i32.store offset=8
          end
          local.get 4
          i32.load offset=12
          local.set 69
          local.get 4
          local.get 69
          i32.store offset=16
          br 1 (;@2;)
        end
      end
      i32.const 1
      local.set 70
      local.get 4
      local.get 70
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 71
    i32.const 32
    local.set 72
    local.get 4
    local.get 72
    i32.add
    local.set 73
    local.get 73
    global.set $__stack_pointer
    local.get 71
    return)"
alloc_test_overwrite,"void *ptr, size_t length, unsigned int pattern","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"static void alloc_test_overwrite(void *ptr, size_t length, unsigned int pattern)
{
	unsigned char *byte_ptr;
	int pattern_seq;
	unsigned char b;
	size_t i;

	byte_ptr = ptr;

	for (i = 0; i < length; ++i) {
		pattern_seq = (int) (i & 3);
		b = (unsigned char) ((pattern >> (8 * pattern_seq)) & 0xff);
		byte_ptr[i] = b;
	}
}","(func $alloc_test_overwrite (type 5) (param i32 i32 i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 3
    i32.const 32
    local.set 4
    local.get 3
    local.get 4
    i32.sub
    local.set 5
    local.get 5
    local.get 0
    i32.store offset=28
    local.get 5
    local.get 1
    i32.store offset=24
    local.get 5
    local.get 2
    i32.store offset=20
    local.get 5
    i32.load offset=28
    local.set 6
    local.get 5
    local.get 6
    i32.store offset=16
    i32.const 0
    local.set 7
    local.get 5
    local.get 7
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 5
        i32.load offset=4
        local.set 8
        local.get 5
        i32.load offset=24
        local.set 9
        local.get 8
        local.get 9
        i32.lt_u
        local.set 10
        i32.const 1
        local.set 11
        local.get 10
        local.get 11
        i32.and
        local.set 12
        local.get 12
        i32.eqz
        br_if 1 (;@1;)
        local.get 5
        i32.load offset=4
        local.set 13
        i32.const 3
        local.set 14
        local.get 13
        local.get 14
        i32.and
        local.set 15
        local.get 5
        local.get 15
        i32.store offset=12
        local.get 5
        i32.load offset=20
        local.set 16
        local.get 5
        i32.load offset=12
        local.set 17
        i32.const 3
        local.set 18
        local.get 17
        local.get 18
        i32.shl
        local.set 19
        local.get 16
        local.get 19
        i32.shr_u
        local.set 20
        i32.const 255
        local.set 21
        local.get 20
        local.get 21
        i32.and
        local.set 22
        local.get 5
        local.get 22
        i32.store8 offset=11
        local.get 5
        i32.load8_u offset=11
        local.set 23
        local.get 5
        i32.load offset=16
        local.set 24
        local.get 5
        i32.load offset=4
        local.set 25
        local.get 24
        local.get 25
        i32.add
        local.set 26
        local.get 26
        local.get 23
        i32.store8
        local.get 5
        i32.load offset=4
        local.set 27
        i32.const 1
        local.set 28
        local.get 27
        local.get 28
        i32.add
        local.set 29
        local.get 5
        local.get 29
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    return)"
alloc_test_malloc,size_t bytes,"Allocates heap memory for a new data structure or buffer.
Returns NULL on allocation failure; the caller must handle errors.","NULL | the block itself */
	return header + 1","void *alloc_test_malloc(size_t bytes)
{
	BlockHeader *header;
	void *ptr;

	/* Check if we have reached the allocation limit. */
	if (allocation_limit == 0) {
		return NULL;
	}

	/* Allocate the requested block with enough room for the block header
	 * as well. */
	header = malloc(sizeof(BlockHeader) + bytes);

	if (header == NULL) {
		return NULL;
	}

	header->magic_number = ALLOC_TEST_MAGIC;
	header->bytes = bytes;

	/* Fill memory with MALLOC_PATTERN, to ensure that code under test
	 * does not rely on memory being initialised to zero. */
	ptr = header + 1;
	alloc_test_overwrite(ptr, bytes, MALLOC_PATTERN);

	/* Update counter */
	allocated_bytes += bytes;

	/* Decrease the allocation limit */
	if (allocation_limit > 0) {
		--allocation_limit;
	}

	/* Skip past the header and return the block itself */
	return header + 1;
}","(func $alloc_test_malloc (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=8
    i32.const 0
    local.set 4
    local.get 4
    i32.load offset=1164
    local.set 5
    block  ;; label = @1
      block  ;; label = @2
        local.get 5
        br_if 0 (;@2;)
        i32.const 0
        local.set 6
        local.get 3
        local.get 6
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=8
      local.set 7
      i32.const 8
      local.set 8
      local.get 7
      local.get 8
      i32.add
      local.set 9
      local.get 9
      call $malloc
      local.set 10
      local.get 3
      local.get 10
      i32.store offset=4
      local.get 3
      i32.load offset=4
      local.set 11
      i32.const 0
      local.set 12
      local.get 11
      local.get 12
      i32.eq
      local.set 13
      i32.const 1
      local.set 14
      local.get 13
      local.get 14
      i32.and
      local.set 15
      block  ;; label = @2
        local.get 15
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 16
        local.get 3
        local.get 16
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=4
      local.set 17
      i32.const 1928102610
      local.set 18
      local.get 17
      local.get 18
      i32.store
      local.get 3
      i32.load offset=8
      local.set 19
      local.get 3
      i32.load offset=4
      local.set 20
      local.get 20
      local.get 19
      i32.store offset=4
      local.get 3
      i32.load offset=4
      local.set 21
      i32.const 8
      local.set 22
      local.get 21
      local.get 22
      i32.add
      local.set 23
      local.get 3
      local.get 23
      i32.store
      local.get 3
      i32.load
      local.set 24
      local.get 3
      i32.load offset=8
      local.set 25
      i32.const -1163005939
      local.set 26
      local.get 24
      local.get 25
      local.get 26
      call $alloc_test_overwrite
      local.get 3
      i32.load offset=8
      local.set 27
      i32.const 0
      local.set 28
      local.get 28
      i32.load offset=1168
      local.set 29
      local.get 29
      local.get 27
      i32.add
      local.set 30
      i32.const 0
      local.set 31
      local.get 31
      local.get 30
      i32.store offset=1168
      i32.const 0
      local.set 32
      local.get 32
      i32.load offset=1164
      local.set 33
      i32.const 0
      local.set 34
      local.get 33
      local.get 34
      i32.gt_s
      local.set 35
      i32.const 1
      local.set 36
      local.get 35
      local.get 36
      i32.and
      local.set 37
      block  ;; label = @2
        local.get 37
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 38
        local.get 38
        i32.load offset=1164
        local.set 39
        i32.const -1
        local.set 40
        local.get 39
        local.get 40
        i32.add
        local.set 41
        i32.const 0
        local.set 42
        local.get 42
        local.get 41
        i32.store offset=1164
      end
      local.get 3
      i32.load offset=4
      local.set 43
      i32.const 8
      local.set 44
      local.get 43
      local.get 44
      i32.add
      local.set 45
      local.get 3
      local.get 45
      i32.store offset=12
    end
    local.get 3
    i32.load offset=12
    local.set 46
    i32.const 16
    local.set 47
    local.get 3
    local.get 47
    i32.add
    local.set 48
    local.get 48
    global.set $__stack_pointer
    local.get 46
    return)"
alloc_test_free,void *ptr,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void alloc_test_free(void *ptr)
{
	BlockHeader *header;
	size_t block_size;

	/* Must accept NULL as a valid pointer to free. */
	if (ptr == NULL) {
		return;
	}

	/* Get the block header and do a sanity check */
	header = alloc_test_get_header(ptr);
	block_size = header->bytes;
	assert(allocated_bytes >= block_size);

	/* Trash the allocated block to foil any code that relies on memory
	 * that has been freed. */
	alloc_test_overwrite(ptr, header->bytes, FREE_PATTERN);

	/* Trash the magic number in the block header to stop the same block
	 * from being freed again. */
	header->magic_number = 0;

	/* Free the allocated memory. */
	free(header);

	/* Update counter */
	allocated_bytes -= block_size;
}","(func $alloc_test_free (type 2) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.eq
    local.set 6
    i32.const 1
    local.set 7
    local.get 6
    local.get 7
    i32.and
    local.set 8
    block  ;; label = @1
      block  ;; label = @2
        local.get 8
        i32.eqz
        br_if 0 (;@2;)
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=12
      local.set 9
      local.get 9
      call $alloc_test_get_header
      local.set 10
      local.get 3
      local.get 10
      i32.store offset=8
      local.get 3
      i32.load offset=8
      local.set 11
      local.get 11
      i32.load offset=4
      local.set 12
      local.get 3
      local.get 12
      i32.store offset=4
      i32.const 0
      local.set 13
      local.get 13
      i32.load offset=1168
      local.set 14
      local.get 3
      i32.load offset=4
      local.set 15
      local.get 14
      local.get 15
      i32.ge_u
      local.set 16
      i32.const 1
      local.set 17
      local.get 16
      local.get 17
      i32.and
      local.set 18
      block  ;; label = @2
        local.get 18
        br_if 0 (;@2;)
        i32.const 1046
        local.set 19
        i32.const 1092
        local.set 20
        i32.const 145
        local.set 21
        i32.const 1076
        local.set 22
        local.get 19
        local.get 20
        local.get 21
        local.get 22
        call $__assert_fail
        unreachable
      end
      local.get 3
      i32.load offset=12
      local.set 23
      local.get 3
      i32.load offset=8
      local.set 24
      local.get 24
      i32.load offset=4
      local.set 25
      i32.const -559038737
      local.set 26
      local.get 23
      local.get 25
      local.get 26
      call $alloc_test_overwrite
      local.get 3
      i32.load offset=8
      local.set 27
      i32.const 0
      local.set 28
      local.get 27
      local.get 28
      i32.store
      local.get 3
      i32.load offset=8
      local.set 29
      local.get 29
      call $free
      local.get 3
      i32.load offset=4
      local.set 30
      i32.const 0
      local.set 31
      local.get 31
      i32.load offset=1168
      local.set 32
      local.get 32
      local.get 30
      i32.sub
      local.set 33
      i32.const 0
      local.set 34
      local.get 34
      local.get 33
      i32.store offset=1168
    end
    i32.const 16
    local.set 35
    local.get 3
    local.get 35
    i32.add
    local.set 36
    local.get 36
    global.set $__stack_pointer
    return)"
alloc_test_realloc,"void *ptr, size_t bytes",Update counter,NULL | new_ptr,"
void *alloc_test_realloc(void *ptr, size_t bytes)
{
	BlockHeader *header;
	void *new_ptr;
	size_t bytes_to_copy;

	/* Allocate the new block */
	new_ptr = alloc_test_malloc(bytes);

	if (new_ptr == NULL) {
		return NULL;
	}

	/* Copy over the old data and free the old block, if there was any. */
	if (ptr != NULL) {
		header = alloc_test_get_header(ptr);

		bytes_to_copy = header->bytes;

		if (bytes_to_copy > bytes) {
			bytes_to_copy = bytes;
		}

		memcpy(new_ptr, ptr, bytes_to_copy);

		alloc_test_free(ptr);
	}

	return new_ptr;
}","(func $alloc_test_realloc (type 3) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=20
    local.set 5
    local.get 5
    call $alloc_test_malloc
    local.set 6
    local.get 4
    local.get 6
    i32.store offset=12
    local.get 4
    i32.load offset=12
    local.set 7
    i32.const 0
    local.set 8
    local.get 7
    local.get 8
    i32.eq
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.and
    local.set 11
    block  ;; label = @1
      block  ;; label = @2
        local.get 11
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 12
        local.get 4
        local.get 12
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=24
      local.set 13
      i32.const 0
      local.set 14
      local.get 13
      local.get 14
      i32.ne
      local.set 15
      i32.const 1
      local.set 16
      local.get 15
      local.get 16
      i32.and
      local.set 17
      block  ;; label = @2
        local.get 17
        i32.eqz
        br_if 0 (;@2;)
        local.get 4
        i32.load offset=24
        local.set 18
        local.get 18
        call $alloc_test_get_header
        local.set 19
        local.get 4
        local.get 19
        i32.store offset=16
        local.get 4
        i32.load offset=16
        local.set 20
        local.get 20
        i32.load offset=4
        local.set 21
        local.get 4
        local.get 21
        i32.store offset=8
        local.get 4
        i32.load offset=8
        local.set 22
        local.get 4
        i32.load offset=20
        local.set 23
        local.get 22
        local.get 23
        i32.gt_u
        local.set 24
        i32.const 1
        local.set 25
        local.get 24
        local.get 25
        i32.and
        local.set 26
        block  ;; label = @3
          local.get 26
          i32.eqz
          br_if 0 (;@3;)
          local.get 4
          i32.load offset=20
          local.set 27
          local.get 4
          local.get 27
          i32.store offset=8
        end
        local.get 4
        i32.load offset=12
        local.set 28
        local.get 4
        i32.load offset=24
        local.set 29
        local.get 4
        i32.load offset=8
        local.set 30
        local.get 30
        i32.eqz
        local.set 31
        block  ;; label = @3
          local.get 31
          br_if 0 (;@3;)
          local.get 28
          local.get 29
          local.get 30
          memory.copy
        end
        local.get 4
        i32.load offset=24
        local.set 32
        local.get 32
        call $alloc_test_free
      end
      local.get 4
      i32.load offset=12
      local.set 33
      local.get 4
      local.get 33
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 34
    i32.const 32
    local.set 35
    local.get 4
    local.get 35
    i32.add
    local.set 36
    local.get 36
    global.set $__stack_pointer
    local.get 34
    return)"
alloc_test_calloc,"size_t nmemb, size_t bytes","Allocates heap memory for a new data structure or buffer.
Returns NULL on allocation failure; the caller must handle errors.",NULL | result,"
void *alloc_test_calloc(size_t nmemb, size_t bytes)
{
	void *result;
	size_t total_bytes = nmemb * bytes;

	/* Allocate the block. */
	result = alloc_test_malloc(total_bytes);

	if (result == NULL) {
		return NULL;
	}

	/* Initialise to zero. */
	memset(result, 0, total_bytes);

	return result;
}","(func $alloc_test_calloc (type 3) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 32
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    local.get 4
    local.get 0
    i32.store offset=24
    local.get 4
    local.get 1
    i32.store offset=20
    local.get 4
    i32.load offset=24
    local.set 5
    local.get 4
    i32.load offset=20
    local.set 6
    local.get 5
    local.get 6
    i32.mul
    local.set 7
    local.get 4
    local.get 7
    i32.store offset=12
    local.get 4
    i32.load offset=12
    local.set 8
    local.get 8
    call $alloc_test_malloc
    local.set 9
    local.get 4
    local.get 9
    i32.store offset=16
    local.get 4
    i32.load offset=16
    local.set 10
    i32.const 0
    local.set 11
    local.get 10
    local.get 11
    i32.eq
    local.set 12
    i32.const 1
    local.set 13
    local.get 12
    local.get 13
    i32.and
    local.set 14
    block  ;; label = @1
      block  ;; label = @2
        local.get 14
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 15
        local.get 4
        local.get 15
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 4
      i32.load offset=16
      local.set 16
      local.get 4
      i32.load offset=12
      local.set 17
      i32.const 0
      local.set 18
      local.get 17
      i32.eqz
      local.set 19
      block  ;; label = @2
        local.get 19
        br_if 0 (;@2;)
        local.get 16
        local.get 18
        local.get 17
        memory.fill
      end
      local.get 4
      i32.load offset=16
      local.set 20
      local.get 4
      local.get 20
      i32.store offset=28
    end
    local.get 4
    i32.load offset=28
    local.set 21
    i32.const 32
    local.set 22
    local.get 4
    local.get 22
    i32.add
    local.set 23
    local.get 23
    global.set $__stack_pointer
    local.get 21
    return)"
alloc_test_strdup,const char *string,"Allocates heap memory for a new data structure or buffer.
Returns NULL on allocation failure; the caller must handle errors.",NULL | result,"
char *alloc_test_strdup(const char *string)
{
	char *result;

	result = alloc_test_malloc(strlen(string) + 1);

	if (result == NULL) {
		return NULL;
	}

	strcpy(result, string);

	return result;
}","(func $alloc_test_strdup (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 4
    local.get 4
    call $strlen
    local.set 5
    i32.const 1
    local.set 6
    local.get 5
    local.get 6
    i32.add
    local.set 7
    local.get 7
    call $alloc_test_malloc
    local.set 8
    local.get 3
    local.get 8
    i32.store offset=4
    local.get 3
    i32.load offset=4
    local.set 9
    i32.const 0
    local.set 10
    local.get 9
    local.get 10
    i32.eq
    local.set 11
    i32.const 1
    local.set 12
    local.get 11
    local.get 12
    i32.and
    local.set 13
    block  ;; label = @1
      block  ;; label = @2
        local.get 13
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 14
        local.get 3
        local.get 14
        i32.store offset=12
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=4
      local.set 15
      local.get 3
      i32.load offset=8
      local.set 16
      local.get 15
      local.get 16
      call $strcpy
      drop
      local.get 3
      i32.load offset=4
      local.set 17
      local.get 3
      local.get 17
      i32.store offset=12
    end
    local.get 3
    i32.load offset=12
    local.set 18
    i32.const 16
    local.set 19
    local.get 3
    local.get 19
    i32.add
    local.set 20
    local.get 20
    global.set $__stack_pointer
    local.get 18
    return)"
alloc_test_set_limit,signed int alloc_count,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void alloc_test_set_limit(signed int alloc_count)
{
	allocation_limit = alloc_count;
}","(func $alloc_test_set_limit (type 1)))
  (import ""env"" ""alloc_test_get_allocated"" (func $alloc_test_get_allocated (type 2)))
  (import ""env"" ""__assert_fail"" (func $__assert_fail (type 3)))"
alloc_test_get_allocated,,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",allocated_bytes,"
size_t alloc_test_get_allocated(void)
{
	return allocated_bytes;
}","(func $alloc_test_get_allocated (type 6) (result i32)
    (local i32 i32)
    i32.const 0
    local.set 0
    local.get 0
    i32.load offset=1168
    local.set 1
    local.get 1
    return)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66720))
  (global (;1;) i32 (i32.const 1164))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 1172))
  (global (;4;) i32 (i32.const 1184))
  (global (;5;) i32 (i32.const 66720))
  (global (;6;) i32 (i32.const 1024))
  (global (;7;) i32 (i32.const 66720))
  (global (;8;) i32 (i32.const 131072))
  (global (;9;) i32 (i32.const 0))
  (global (;10;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""alloc_test_malloc"" (func $alloc_test_malloc))
  (export ""allocation_limit"" (global 1))
  (export ""alloc_test_free"" (func $alloc_test_free))
  (export ""alloc_test_realloc"" (func $alloc_test_realloc))
  (export ""alloc_test_calloc"" (func $alloc_test_calloc))
  (export ""alloc_test_strdup"" (func $alloc_test_strdup))
  (export ""alloc_test_set_limit"" (func $alloc_test_set_limit))
  (export ""alloc_test_get_allocated"" (func $alloc_test_get_allocated))
  (export ""__dso_handle"" (global 2))
  (export ""__data_end"" (global 3))
  (export ""__stack_low"" (global 4))
  (export ""__stack_high"" (global 5))
  (export ""__global_base"" (global 6))
  (export ""__heap_base"" (global 7))
  (export ""__heap_end"" (global 8))
  (export ""__memory_base"" (global 9))
  (export ""__table_base"" (global 10))
  (data $.rodata (i32.const 1024) ""alloc_test_get_header\00allocated_bytes >= block_size\00alloc_test_free\00../files/src/alloc-testing.c\00result->magic_number == ALLOC_TEST_MAGIC\00"")
  (data $.data (i32.const 1164) ""\ff\ff\ff\ff""))"
run_test,UnitTestFunction test,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"static void run_test(UnitTestFunction test)
{
	/* Turn off any allocation limits that may have been set
	 * by a previous test. */
	alloc_test_set_limit(-1);

	/* Run the test */
	test();

	/* Check that all memory was correctly freed back during
	 * the test. */
	assert(alloc_test_get_allocated() == 0);
}","(func $run_test (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const -1
    local.set 4
    local.get 4
    call $alloc_test_set_limit
    local.get 3
    i32.load offset=12
    local.set 5
    local.get 5
    call_indirect (type 0)
    call $alloc_test_get_allocated
    local.set 6
    block  ;; label = @1
      local.get 6
      i32.eqz
      br_if 0 (;@1;)
      i32.const 1058
      local.set 7
      i32.const 1033
      local.set 8
      i32.const 41
      local.set 9
      i32.const 1024
      local.set 10
      local.get 7
      local.get 8
      local.get 9
      local.get 10
      call $__assert_fail
      unreachable
    end
    i32.const 16
    local.set 11
    local.get 3
    local.get 11
    i32.add
    local.set 12
    local.get 12
    global.set $__stack_pointer
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66640))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 1090))
  (global (;3;) i32 (i32.const 1104))
  (global (;4;) i32 (i32.const 66640))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 66640))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""run_tests"" (func $run_tests))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (data $.rodata (i32.const 1024) ""run_test\00../files/src/framework.c\00alloc_test_get_allocated() == 0\00""))"
run_tests,UnitTestFunction *tests,"Check that all memory was correctly freed back during
the test.",null,"
void run_tests(UnitTestFunction *tests)
{
	int i;

	for (i = 0; tests[i] != NULL; ++i) {
		run_test(tests[i]);
	}
}","(func $run_tests (type 0)))
  (import ""env"" ""alloc_test_get_allocated"" (func $alloc_test_get_allocated (type 1)))
  (import ""env"" ""__assert_fail"" (func $__assert_fail (type 2)))
  (import ""env"" ""alloc_test_malloc"" (func $alloc_test_malloc (type 3)))
  (import ""env"" ""alloc_test_free"" (func $alloc_test_free (type 0)))
  (import ""env"" ""alloc_test_set_limit"" (func $alloc_test_set_limit (type 0)))
  (import ""env"" ""alloc_test_realloc"" (func $alloc_test_realloc (type 4)))
  (import ""env"" ""alloc_test_calloc"" (func $alloc_test_calloc (type 4)))
  (import ""env"" ""alloc_test_strdup"" (func $alloc_test_strdup (type 3)))
  (import ""env"" ""strcmp"" (func $strcmp (type 4)))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
print_tree,"AVLTreeNode *node, int depth","Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",null,"static void print_tree(AVLTreeNode *node, int depth)
{
	int *value;
	int i;

	if (node == NULL) {
		return;
	}

	print_tree(avl_tree_node_child(node, AVL_TREE_NODE_LEFT), depth + 1);

	for (i=0; i<depth*6; ++i) {
		printf("" "");
	}

	value = avl_tree_node_key(node);
	printf(""%i\n"", *value);

	print_tree(avl_tree_node_child(node, AVL_TREE_NODE_RIGHT), depth + 1);
}",
find_subtree_height,AVLTreeNode *node,"Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",0 | left_height + 1 | right_height + 1,"
int find_subtree_height(AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	int left_height, right_height;

	if (node == NULL) {
		return 0;
	}

	left_subtree = avl_tree_node_child(node, AVL_TREE_NODE_LEFT);
	right_subtree = avl_tree_node_child(node, AVL_TREE_NODE_RIGHT);
	left_height = find_subtree_height(left_subtree);
	right_height = find_subtree_height(right_subtree);

	if (left_height > right_height) {
		return left_height + 1;
	} else {
		return right_height + 1;
	}
}","(func $find_subtree_height (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 32
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=24
    local.get 3
    i32.load offset=24
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.eq
    local.set 6
    i32.const 1
    local.set 7
    local.get 6
    local.get 7
    i32.and
    local.set 8
    block  ;; label = @1
      block  ;; label = @2
        local.get 8
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 9
        local.get 3
        local.get 9
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=24
      local.set 10
      i32.const 0
      local.set 11
      local.get 10
      local.get 11
      call $avl_tree_node_child
      local.set 12
      local.get 3
      local.get 12
      i32.store offset=20
      local.get 3
      i32.load offset=24
      local.set 13
      i32.const 1
      local.set 14
      local.get 13
      local.get 14
      call $avl_tree_node_child
      local.set 15
      local.get 3
      local.get 15
      i32.store offset=16
      local.get 3
      i32.load offset=20
      local.set 16
      local.get 16
      call $find_subtree_height
      local.set 17
      local.get 3
      local.get 17
      i32.store offset=12
      local.get 3
      i32.load offset=16
      local.set 18
      local.get 18
      call $find_subtree_height
      local.set 19
      local.get 3
      local.get 19
      i32.store offset=8
      local.get 3
      i32.load offset=12
      local.set 20
      local.get 3
      i32.load offset=8
      local.set 21
      local.get 20
      local.get 21
      i32.gt_s
      local.set 22
      i32.const 1
      local.set 23
      local.get 22
      local.get 23
      i32.and
      local.set 24
      block  ;; label = @2
        local.get 24
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=12
        local.set 25
        i32.const 1
        local.set 26
        local.get 25
        local.get 26
        i32.add
        local.set 27
        local.get 3
        local.get 27
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=8
      local.set 28
      i32.const 1
      local.set 29
      local.get 28
      local.get 29
      i32.add
      local.set 30
      local.get 3
      local.get 30
      i32.store offset=28
    end
    local.get 3
    i32.load offset=28
    local.set 31
    i32.const 32
    local.set 32
    local.get 3
    local.get 32
    i32.add
    local.set 33
    local.get 33
    global.set $__stack_pointer
    local.get 31
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);
	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_out_of_memory,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_out_of_memory(void)
{
	BinaryHeap *heap;
	int *value;
	int values[] = {
	    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
	};
	int i;

	/* Allocate a heap and fill to the default limit */
	heap = binary_heap_new(BINARY_HEAP_TYPE_MIN, int_compare);

	alloc_test_set_limit(0);

	for (i = 0; i < 16; ++i) {
		assert(binary_heap_insert(heap, &values[i]) != 0);
	}

	assert(binary_heap_num_entries(heap) == 16);

	/* Check that we cannot add new values */
	for (i = 0; i < 16; ++i) {
		assert(binary_heap_insert(heap, &values[i]) == 0);
		assert(binary_heap_num_entries(heap) == 16);
	}

	/* Check that we can read the values back out again and they
	 * are in the right order. */
	for (i = 0; i < 16; ++i) {
		value = binary_heap_pop(heap);
		assert(*value == i);
	}

	assert(binary_heap_num_entries(heap) == 0);

	binary_heap_free(heap);
}","(func $test_out_of_memory (type 5)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    call $create_tree
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=12
    i32.const 0
    local.set 4
    local.get 4
    call $alloc_test_set_limit
    i32.const 10000
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=4
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=4
        local.set 6
        i32.const 20000
        local.set 7
        local.get 6
        local.get 7
        i32.lt_s
        local.set 8
        i32.const 1
        local.set 9
        local.get 8
        local.get 9
        i32.and
        local.set 10
        local.get 10
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=12
        local.set 11
        i32.const 4
        local.set 12
        local.get 2
        local.get 12
        i32.add
        local.set 13
        local.get 13
        local.set 14
        local.get 11
        local.get 14
        local.get 14
        call $avl_tree_insert
        local.set 15
        local.get 2
        local.get 15
        i32.store offset=8
        local.get 2
        i32.load offset=8
        local.set 16
        i32.const 0
        local.set 17
        local.get 16
        local.get 17
        i32.eq
        local.set 18
        i32.const 1
        local.set 19
        local.get 18
        local.get 19
        i32.and
        local.set 20
        block  ;; label = @3
          local.get 20
          br_if 0 (;@3;)
          i32.const 1646
          local.set 21
          i32.const 1567
          local.set 22
          i32.const 277
          local.set 23
          i32.const 1024
          local.set 24
          local.get 21
          local.get 22
          local.get 23
          local.get 24
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=12
        local.set 25
        local.get 25
        call $validate_tree
        local.get 2
        i32.load offset=4
        local.set 26
        i32.const 1
        local.set 27
        local.get 26
        local.get 27
        i32.add
        local.set 28
        local.get 2
        local.get 28
        i32.store offset=4
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=12
    local.set 29
    local.get 29
    call $avl_tree_free
    i32.const 16
    local.set 30
    local.get 2
    local.get 30
    i32.add
    local.set 31
    local.get 31
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
verify_heap,BinomialHeap *heap,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"static void verify_heap(BinomialHeap *heap)
{
	unsigned int num_vals;
	int *val;
	int i;

	num_vals = binomial_heap_num_entries(heap);
	assert(num_vals == NUM_TEST_VALUES - 1);

	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		if (i == TEST_VALUE) {
			continue;
		}

		/* Pop off the next value and check it */
		val = binomial_heap_pop(heap);
		assert(*val == i);

		/* Decrement num values counter */
		--num_vals;
		assert(binomial_heap_num_entries(heap) == num_vals);
	}
}","(func $verify_heap (type 1) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    call $binomial_heap_num_entries
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 6
    i32.const 9999
    local.set 7
    local.get 6
    local.get 7
    i32.eq
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      br_if 0 (;@1;)
      i32.const 1441
      local.set 11
      i32.const 1235
      local.set 12
      i32.const 159
      local.set 13
      i32.const 1143
      local.set 14
      local.get 11
      local.get 12
      local.get 13
      local.get 14
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 15
    local.get 3
    local.get 15
    i32.store
    block  ;; label = @1
      loop  ;; label = @2
        local.get 3
        i32.load
        local.set 16
        i32.const 10000
        local.set 17
        local.get 16
        local.get 17
        i32.lt_s
        local.set 18
        i32.const 1
        local.set 19
        local.get 18
        local.get 19
        i32.and
        local.set 20
        local.get 20
        i32.eqz
        br_if 1 (;@1;)
        local.get 3
        i32.load
        local.set 21
        i32.const 5000
        local.set 22
        local.get 21
        local.get 22
        i32.eq
        local.set 23
        i32.const 1
        local.set 24
        local.get 23
        local.get 24
        i32.and
        local.set 25
        block  ;; label = @3
          block  ;; label = @4
            local.get 25
            i32.eqz
            br_if 0 (;@4;)
            br 1 (;@3;)
          end
          local.get 3
          i32.load offset=12
          local.set 26
          local.get 26
          call $binomial_heap_pop
          local.set 27
          local.get 3
          local.get 27
          i32.store offset=4
          local.get 3
          i32.load offset=4
          local.set 28
          local.get 28
          i32.load
          local.set 29
          local.get 3
          i32.load
          local.set 30
          local.get 29
          local.get 30
          i32.eq
          local.set 31
          i32.const 1
          local.set 32
          local.get 31
          local.get 32
          i32.and
          local.set 33
          block  ;; label = @4
            local.get 33
            br_if 0 (;@4;)
            i32.const 1197
            local.set 34
            i32.const 1235
            local.set 35
            i32.const 168
            local.set 36
            i32.const 1143
            local.set 37
            local.get 34
            local.get 35
            local.get 36
            local.get 37
            call $__assert_fail
            unreachable
          end
          local.get 3
          i32.load offset=8
          local.set 38
          i32.const -1
          local.set 39
          local.get 38
          local.get 39
          i32.add
          local.set 40
          local.get 3
          local.get 40
          i32.store offset=8
          local.get 3
          i32.load offset=12
          local.set 41
          local.get 41
          call $binomial_heap_num_entries
          local.set 42
          local.get 3
          i32.load offset=8
          local.set 43
          local.get 42
          local.get 43
          i32.eq
          local.set 44
          i32.const 1
          local.set 45
          local.get 44
          local.get 45
          i32.and
          local.set 46
          block  ;; label = @4
            local.get 46
            br_if 0 (;@4;)
            i32.const 1099
            local.set 47
            i32.const 1235
            local.set 48
            i32.const 172
            local.set 49
            i32.const 1143
            local.set 50
            local.get 47
            local.get 48
            local.get 49
            local.get 50
            call $__assert_fail
            unreachable
          end
        end
        local.get 3
        i32.load
        local.set 51
        i32.const 1
        local.set 52
        local.get 51
        local.get 52
        i32.add
        local.set 53
        local.get 3
        local.get 53
        i32.store
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 54
    local.get 3
    local.get 54
    i32.add
    local.set 55
    local.get 55
    global.set $__stack_pointer
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 107200))
  (global (;1;) i32 (i32.const 1664))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 41664))
  (global (;4;) i32 (i32.const 41664))
  (global (;5;) i32 (i32.const 107200))
  (global (;6;) i32 (i32.const 1024))
  (global (;7;) i32 (i32.const 107200))
  (global (;8;) i32 (i32.const 131072))
  (global (;9;) i32 (i32.const 0))
  (global (;10;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""test_binomial_heap_new_free"" (func $test_binomial_heap_new_free))
  (export ""test_binomial_heap_insert"" (func $test_binomial_heap_insert))
  (export ""test_array"" (global 1))
  (export ""test_min_heap"" (func $test_min_heap))
  (export ""test_max_heap"" (func $test_max_heap))
  (export ""test_pop_out_of_memory"" (func $test_pop_out_of_memory))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 2))
  (export ""__data_end"" (global 3))
  (export ""__stack_low"" (global 4))
  (export ""__stack_high"" (global 5))
  (export ""__global_base"" (global 6))
  (export ""__heap_base"" (global 7))
  (export ""__heap_end"" (global 8))
  (export ""__memory_base"" (global 9))
  (export ""__table_base"" (global 10))
  (elem (;0;) (i32.const 1) func $int_compare $test_binomial_heap_new_free $test_binomial_heap_insert $test_min_heap $test_max_heap $test_insert_out_of_memory $test_pop_out_of_memory)
  (data $.rodata (i32.const 1024) ""test_insert_out_of_memory\00test_pop_out_of_memory\00test_binomial_heap_insert\00binomial_heap_num_entries(heap) == num_vals\00verify_heap\00test_max_heap\00test_min_heap\00generate_heap\00*val == i\00test_binomial_heap_new_free\00../files/src/test-binomial-heap.c\00binomial_heap_num_entries(heap) == NUM_TEST_VALUES\00val == NULL\00binomial_heap_pop(heap) == NULL\00binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, int_compare) == NULL\00*val == i - 1\00num_vals == NUM_TEST_VALUES - 1\00*val == i + 1\00binomial_heap_insert(heap, &i) == 0\00binomial_heap_insert(heap, &test_array[TEST_VALUE]) == 0\00binomial_heap_insert(heap, &test_array[i]) != 0\00"")
  (data $.data (i32.const 1632) ""\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_insert_out_of_memory,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"static void test_insert_out_of_memory(void)
{
	BinomialHeap *heap;
	int i;

	/* There are various memory allocations performed during the insert;
	 * probe at different limit levels to catch them all. */
	for (i = 0; i < 6; ++i) {
		heap = generate_heap();

		/* Insert should fail */
		alloc_test_set_limit(i);
		test_array[TEST_VALUE] = TEST_VALUE;
		assert(binomial_heap_insert(heap, &test_array[TEST_VALUE]) ==
		       0);
		alloc_test_set_limit(-1);

		/* Check that the heap is unharmed */
		verify_heap(heap);

		binomial_heap_free(heap);
	}
}","(func $test_insert_out_of_memory (type 4)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 0
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=8
        local.set 4
        i32.const 6
        local.set 5
        local.get 4
        local.get 5
        i32.lt_s
        local.set 6
        i32.const 1
        local.set 7
        local.get 6
        local.get 7
        i32.and
        local.set 8
        local.get 8
        i32.eqz
        br_if 1 (;@1;)
        call $generate_heap
        local.set 9
        local.get 2
        local.get 9
        i32.store offset=12
        local.get 2
        i32.load offset=8
        local.set 10
        local.get 10
        call $alloc_test_set_limit
        i32.const 5000
        local.set 11
        i32.const 0
        local.set 12
        local.get 12
        local.get 11
        i32.store offset=21664
        local.get 2
        i32.load offset=12
        local.set 13
        i32.const 1664
        local.set 14
        i32.const 20000
        local.set 15
        local.get 14
        local.get 15
        i32.add
        local.set 16
        local.get 13
        local.get 16
        call $binomial_heap_insert
        local.set 17
        block  ;; label = @3
          local.get 17
          i32.eqz
          br_if 0 (;@3;)
          i32.const 1523
          local.set 18
          i32.const 1235
          local.set 19
          i32.const 191
          local.set 20
          i32.const 1024
          local.set 21
          local.get 18
          local.get 19
          local.get 20
          local.get 21
          call $__assert_fail
          unreachable
        end
        i32.const -1
        local.set 22
        local.get 22
        call $alloc_test_set_limit
        local.get 2
        i32.load offset=12
        local.set 23
        local.get 23
        call $verify_heap
        local.get 2
        i32.load offset=12
        local.set 24
        local.get 24
        call $binomial_heap_free
        local.get 2
        i32.load offset=8
        local.set 25
        i32.const 1
        local.set 26
        local.get 25
        local.get 26
        i32.add
        local.set 27
        local.get 2
        local.get 27
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 28
    local.get 2
    local.get 28
    i32.add
    local.set 29
    local.get 29
    global.set $__stack_pointer
    return)"
test_pop_out_of_memory,,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void test_pop_out_of_memory(void)
{
	BinomialHeap *heap;
	int i;

	/* There are various memory allocations performed as part of the merge
	 * done during the pop.  Probe at different limit levels to catch them
	 * all. */
	for (i = 0; i < 6; ++i) {
		heap = generate_heap();

		/* Pop should fail */
		alloc_test_set_limit(i);
		assert(binomial_heap_pop(heap) == NULL);
		alloc_test_set_limit(-1);

		/* Check the heap is unharmed */
		binomial_heap_free(heap);
	}
}","(func $test_pop_out_of_memory (type 4)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 0
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=8
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=8
        local.set 4
        i32.const 6
        local.set 5
        local.get 4
        local.get 5
        i32.lt_s
        local.set 6
        i32.const 1
        local.set 7
        local.get 6
        local.get 7
        i32.and
        local.set 8
        local.get 8
        i32.eqz
        br_if 1 (;@1;)
        call $generate_heap
        local.set 9
        local.get 2
        local.get 9
        i32.store offset=12
        local.get 2
        i32.load offset=8
        local.set 10
        local.get 10
        call $alloc_test_set_limit
        local.get 2
        i32.load offset=12
        local.set 11
        local.get 11
        call $binomial_heap_pop
        local.set 12
        i32.const 0
        local.set 13
        local.get 12
        local.get 13
        i32.eq
        local.set 14
        i32.const 1
        local.set 15
        local.get 14
        local.get 15
        i32.and
        local.set 16
        block  ;; label = @3
          local.get 16
          br_if 0 (;@3;)
          i32.const 1332
          local.set 17
          i32.const 1235
          local.set 18
          i32.const 215
          local.set 19
          i32.const 1050
          local.set 20
          local.get 17
          local.get 18
          local.get 19
          local.get 20
          call $__assert_fail
          unreachable
        end
        i32.const -1
        local.set 21
        local.get 21
        call $alloc_test_set_limit
        local.get 2
        i32.load offset=12
        local.set 22
        local.get 22
        call $binomial_heap_free
        local.get 2
        i32.load offset=8
        local.set 23
        i32.const 1
        local.set 24
        local.get 23
        local.get 24
        i32.add
        local.set 25
        local.get 2
        local.get 25
        i32.store offset=8
        br 0 (;@2;)
      end
    end
    i32.const 16
    local.set 26
    local.get 2
    local.get 26
    i32.add
    local.set 27
    local.get 27
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_bloom_filter_mismatch,,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void test_bloom_filter_mismatch(void)
{
	BloomFilter *filter1;
	BloomFilter *filter2;

	/* Create one filter with both values set */
	filter1 = bloom_filter_new(128, string_hash, 4);

	/* Different buffer size. */
	filter2 = bloom_filter_new(64, string_hash, 4);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	/* Different hash function */
	filter2 = bloom_filter_new(128, string_nocase_hash, 4);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	/* Different number of salts */
	filter2 = bloom_filter_new(128, string_hash, 32);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	bloom_filter_free(filter1);
}","(func $test_bloom_filter_mismatch (type 6)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 128
    local.set 3
    i32.const 1
    local.set 4
    i32.const 4
    local.set 5
    local.get 3
    local.get 4
    local.get 5
    call $bloom_filter_new
    local.set 6
    local.get 2
    local.get 6
    i32.store offset=12
    i32.const 64
    local.set 7
    i32.const 1
    local.set 8
    i32.const 4
    local.set 9
    local.get 7
    local.get 8
    local.get 9
    call $bloom_filter_new
    local.set 10
    local.get 2
    local.get 10
    i32.store offset=8
    local.get 2
    i32.load offset=12
    local.set 11
    local.get 2
    i32.load offset=8
    local.set 12
    local.get 11
    local.get 12
    call $bloom_filter_intersection
    local.set 13
    i32.const 0
    local.set 14
    local.get 13
    local.get 14
    i32.eq
    local.set 15
    i32.const 1
    local.set 16
    local.get 15
    local.get 16
    i32.and
    local.set 17
    block  ;; label = @1
      local.get 17
      br_if 0 (;@1;)
      i32.const 1255
      local.set 18
      i32.const 1192
      local.set 19
      i32.const 205
      local.set 20
      i32.const 1110
      local.set 21
      local.get 18
      local.get 19
      local.get 20
      local.get 21
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 22
    local.get 2
    i32.load offset=8
    local.set 23
    local.get 22
    local.get 23
    call $bloom_filter_union
    local.set 24
    i32.const 0
    local.set 25
    local.get 24
    local.get 25
    i32.eq
    local.set 26
    i32.const 1
    local.set 27
    local.get 26
    local.get 27
    i32.and
    local.set 28
    block  ;; label = @1
      local.get 28
      br_if 0 (;@1;)
      i32.const 1307
      local.set 29
      i32.const 1192
      local.set 30
      i32.const 206
      local.set 31
      i32.const 1110
      local.set 32
      local.get 29
      local.get 30
      local.get 31
      local.get 32
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=8
    local.set 33
    local.get 33
    call $bloom_filter_free
    i32.const 128
    local.set 34
    i32.const 2
    local.set 35
    i32.const 4
    local.set 36
    local.get 34
    local.get 35
    local.get 36
    call $bloom_filter_new
    local.set 37
    local.get 2
    local.get 37
    i32.store offset=8
    local.get 2
    i32.load offset=12
    local.set 38
    local.get 2
    i32.load offset=8
    local.set 39
    local.get 38
    local.get 39
    call $bloom_filter_intersection
    local.set 40
    i32.const 0
    local.set 41
    local.get 40
    local.get 41
    i32.eq
    local.set 42
    i32.const 1
    local.set 43
    local.get 42
    local.get 43
    i32.and
    local.set 44
    block  ;; label = @1
      local.get 44
      br_if 0 (;@1;)
      i32.const 1255
      local.set 45
      i32.const 1192
      local.set 46
      i32.const 211
      local.set 47
      i32.const 1110
      local.set 48
      local.get 45
      local.get 46
      local.get 47
      local.get 48
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 49
    local.get 2
    i32.load offset=8
    local.set 50
    local.get 49
    local.get 50
    call $bloom_filter_union
    local.set 51
    i32.const 0
    local.set 52
    local.get 51
    local.get 52
    i32.eq
    local.set 53
    i32.const 1
    local.set 54
    local.get 53
    local.get 54
    i32.and
    local.set 55
    block  ;; label = @1
      local.get 55
      br_if 0 (;@1;)
      i32.const 1307
      local.set 56
      i32.const 1192
      local.set 57
      i32.const 212
      local.set 58
      i32.const 1110
      local.set 59
      local.get 56
      local.get 57
      local.get 58
      local.get 59
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=8
    local.set 60
    local.get 60
    call $bloom_filter_free
    i32.const 128
    local.set 61
    i32.const 1
    local.set 62
    i32.const 32
    local.set 63
    local.get 61
    local.get 62
    local.get 63
    call $bloom_filter_new
    local.set 64
    local.get 2
    local.get 64
    i32.store offset=8
    local.get 2
    i32.load offset=12
    local.set 65
    local.get 2
    i32.load offset=8
    local.set 66
    local.get 65
    local.get 66
    call $bloom_filter_intersection
    local.set 67
    i32.const 0
    local.set 68
    local.get 67
    local.get 68
    i32.eq
    local.set 69
    i32.const 1
    local.set 70
    local.get 69
    local.get 70
    i32.and
    local.set 71
    block  ;; label = @1
      local.get 71
      br_if 0 (;@1;)
      i32.const 1255
      local.set 72
      i32.const 1192
      local.set 73
      i32.const 217
      local.set 74
      i32.const 1110
      local.set 75
      local.get 72
      local.get 73
      local.get 74
      local.get 75
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 76
    local.get 2
    i32.load offset=8
    local.set 77
    local.get 76
    local.get 77
    call $bloom_filter_union
    local.set 78
    i32.const 0
    local.set 79
    local.get 78
    local.get 79
    i32.eq
    local.set 80
    i32.const 1
    local.set 81
    local.get 80
    local.get 81
    i32.and
    local.set 82
    block  ;; label = @1
      local.get 82
      br_if 0 (;@1;)
      i32.const 1307
      local.set 83
      i32.const 1192
      local.set 84
      i32.const 218
      local.set 85
      i32.const 1110
      local.set 86
      local.get 83
      local.get 84
      local.get 85
      local.get 86
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=8
    local.set 87
    local.get 87
    call $bloom_filter_free
    local.get 2
    i32.load offset=12
    local.set 88
    local.get 88
    call $bloom_filter_free
    i32.const 16
    local.set 89
    local.get 2
    local.get 89
    i32.add
    local.set 90
    local.get 90
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_hash_table_new_free,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_hash_table_new_free(void)
{
	HashTable *hash_table;

	hash_table = hash_table_new(int_hash, int_equal);

	assert(hash_table != NULL);

	/* Add some values */
	hash_table_insert(hash_table, &value1, &value1);
	hash_table_insert(hash_table, &value2, &value2);
	hash_table_insert(hash_table, &value3, &value3);
	hash_table_insert(hash_table, &value4, &value4);

	/* Free the hash table */
	hash_table_free(hash_table);

	/* Test out of memory scenario */
	alloc_test_set_limit(0);
	hash_table = hash_table_new(int_hash, int_equal);
	assert(hash_table == NULL);
	assert(alloc_test_get_allocated() == 0);

	alloc_test_set_limit(1);
	hash_table = hash_table_new(int_hash, int_equal);
	assert(hash_table == NULL);
	assert(alloc_test_get_allocated() == 0);
}","(func $test_hash_table_new_free (type 8)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 4
    local.set 3
    i32.const 5
    local.set 4
    local.get 3
    local.get 4
    call $hash_table_new
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=12
    local.get 2
    i32.load offset=12
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.ne
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      br_if 0 (;@1;)
      i32.const 1614
      local.set 11
      i32.const 1342
      local.set 12
      i32.const 77
      local.set 13
      i32.const 1241
      local.set 14
      local.get 11
      local.get 12
      local.get 13
      local.get 14
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 15
    i32.const 2304
    local.set 16
    local.get 15
    local.get 16
    local.get 16
    call $hash_table_insert
    drop
    local.get 2
    i32.load offset=12
    local.set 17
    i32.const 2308
    local.set 18
    local.get 17
    local.get 18
    local.get 18
    call $hash_table_insert
    drop
    local.get 2
    i32.load offset=12
    local.set 19
    i32.const 2312
    local.set 20
    local.get 19
    local.get 20
    local.get 20
    call $hash_table_insert
    drop
    local.get 2
    i32.load offset=12
    local.set 21
    i32.const 2316
    local.set 22
    local.get 21
    local.get 22
    local.get 22
    call $hash_table_insert
    drop
    local.get 2
    i32.load offset=12
    local.set 23
    local.get 23
    call $hash_table_free
    i32.const 0
    local.set 24
    local.get 24
    call $alloc_test_set_limit
    i32.const 4
    local.set 25
    i32.const 5
    local.set 26
    local.get 25
    local.get 26
    call $hash_table_new
    local.set 27
    local.get 2
    local.get 27
    i32.store offset=12
    local.get 2
    i32.load offset=12
    local.set 28
    i32.const 0
    local.set 29
    local.get 28
    local.get 29
    i32.eq
    local.set 30
    i32.const 1
    local.set 31
    local.get 30
    local.get 31
    i32.and
    local.set 32
    block  ;; label = @1
      local.get 32
      br_if 0 (;@1;)
      i32.const 1552
      local.set 33
      i32.const 1342
      local.set 34
      i32.const 91
      local.set 35
      i32.const 1241
      local.set 36
      local.get 33
      local.get 34
      local.get 35
      local.get 36
      call $__assert_fail
      unreachable
    end
    call $alloc_test_get_allocated
    local.set 37
    block  ;; label = @1
      local.get 37
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2164
      local.set 38
      i32.const 1342
      local.set 39
      i32.const 92
      local.set 40
      i32.const 1241
      local.set 41
      local.get 38
      local.get 39
      local.get 40
      local.get 41
      call $__assert_fail
      unreachable
    end
    i32.const 1
    local.set 42
    local.get 42
    call $alloc_test_set_limit
    i32.const 4
    local.set 43
    i32.const 5
    local.set 44
    local.get 43
    local.get 44
    call $hash_table_new
    local.set 45
    local.get 2
    local.get 45
    i32.store offset=12
    local.get 2
    i32.load offset=12
    local.set 46
    i32.const 0
    local.set 47
    local.get 46
    local.get 47
    i32.eq
    local.set 48
    i32.const 1
    local.set 49
    local.get 48
    local.get 49
    i32.and
    local.set 50
    block  ;; label = @1
      local.get 50
      br_if 0 (;@1;)
      i32.const 1552
      local.set 51
      i32.const 1342
      local.set 52
      i32.const 96
      local.set 53
      i32.const 1241
      local.set 54
      local.get 51
      local.get 52
      local.get 53
      local.get 54
      call $__assert_fail
      unreachable
    end
    call $alloc_test_get_allocated
    local.set 55
    block  ;; label = @1
      local.get 55
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2164
      local.set 56
      i32.const 1342
      local.set 57
      i32.const 97
      local.set 58
      i32.const 1241
      local.set 59
      local.get 56
      local.get 57
      local.get 58
      local.get 59
      call $__assert_fail
      unreachable
    end
    i32.const 16
    local.set 60
    local.get 2
    local.get 60
    i32.add
    local.set 61
    local.get 61
    global.set $__stack_pointer
    return)"
test_hash_table_insert_lookup,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_hash_table_insert_lookup(void)
{
	HashTable *hash_table;
	char buf[10];
	char *value;
	int i;

	/* Generate a hash table */
	hash_table = generate_hash_table();

	assert(hash_table_num_entries(hash_table) == NUM_TEST_VALUES);

	/* Check all values */
	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		sprintf(buf, ""%i"", i);
		value = hash_table_lookup(hash_table, buf);

		assert(strcmp(value, buf) == 0);
	}

	/* Lookup on invalid values returns NULL */
	sprintf(buf, ""%i"", -1);
	assert(hash_table_lookup(hash_table, buf) == NULL);
	sprintf(buf, ""%i"", NUM_TEST_VALUES);
	assert(hash_table_lookup(hash_table, buf) == NULL);

	/* Insert overwrites existing entries with the same key */
	sprintf(buf, ""%i"", 12345);
	hash_table_insert(hash_table, buf, strdup(""hello world""));
	value = hash_table_lookup(hash_table, buf);
	assert(strcmp(value, ""hello world"") == 0);

	hash_table_free(hash_table);
}","(func $test_hash_table_insert_lookup (type 8)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 80
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    call $generate_hash_table
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=76
    local.get 2
    i32.load offset=76
    local.set 4
    local.get 4
    call $hash_table_num_entries
    local.set 5
    i32.const 10000
    local.set 6
    local.get 5
    local.get 6
    i32.eq
    local.set 7
    i32.const 1
    local.set 8
    local.get 7
    local.get 8
    i32.and
    local.set 9
    block  ;; label = @1
      local.get 9
      br_if 0 (;@1;)
      i32.const 1468
      local.set 10
      i32.const 1342
      local.set 11
      i32.const 111
      local.set 12
      i32.const 1113
      local.set 13
      local.get 10
      local.get 11
      local.get 12
      local.get 13
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 14
    local.get 2
    local.get 14
    i32.store offset=56
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=56
        local.set 15
        i32.const 10000
        local.set 16
        local.get 15
        local.get 16
        i32.lt_s
        local.set 17
        i32.const 1
        local.set 18
        local.get 17
        local.get 18
        i32.and
        local.set 19
        local.get 19
        i32.eqz
        br_if 1 (;@1;)
        i32.const 66
        local.set 20
        local.get 2
        local.get 20
        i32.add
        local.set 21
        local.get 21
        local.set 22
        local.get 2
        i32.load offset=56
        local.set 23
        local.get 2
        local.get 23
        i32.store
        i32.const 1156
        local.set 24
        local.get 22
        local.get 24
        local.get 2
        call $sprintf
        drop
        local.get 2
        i32.load offset=76
        local.set 25
        i32.const 66
        local.set 26
        local.get 2
        local.get 26
        i32.add
        local.set 27
        local.get 27
        local.set 28
        local.get 25
        local.get 28
        call $hash_table_lookup
        local.set 29
        local.get 2
        local.get 29
        i32.store offset=60
        local.get 2
        i32.load offset=60
        local.set 30
        i32.const 66
        local.set 31
        local.get 2
        local.get 31
        i32.add
        local.set 32
        local.get 32
        local.set 33
        local.get 30
        local.get 33
        call $strcmp
        local.set 34
        block  ;; label = @3
          local.get 34
          i32.eqz
          br_if 0 (;@3;)
          i32.const 1980
          local.set 35
          i32.const 1342
          local.set 36
          i32.const 118
          local.set 37
          i32.const 1113
          local.set 38
          local.get 35
          local.get 36
          local.get 37
          local.get 38
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=56
        local.set 39
        i32.const 1
        local.set 40
        local.get 39
        local.get 40
        i32.add
        local.set 41
        local.get 2
        local.get 41
        i32.store offset=56
        br 0 (;@2;)
      end
    end
    i32.const 66
    local.set 42
    local.get 2
    local.get 42
    i32.add
    local.set 43
    local.get 43
    local.set 44
    i32.const -1
    local.set 45
    local.get 2
    local.get 45
    i32.store offset=48
    i32.const 1156
    local.set 46
    i32.const 48
    local.set 47
    local.get 2
    local.get 47
    i32.add
    local.set 48
    local.get 44
    local.get 46
    local.get 48
    call $sprintf
    drop
    local.get 2
    i32.load offset=76
    local.set 49
    i32.const 66
    local.set 50
    local.get 2
    local.get 50
    i32.add
    local.set 51
    local.get 51
    local.set 52
    local.get 49
    local.get 52
    call $hash_table_lookup
    local.set 53
    i32.const 0
    local.set 54
    local.get 53
    local.get 54
    i32.eq
    local.set 55
    i32.const 1
    local.set 56
    local.get 55
    local.get 56
    i32.and
    local.set 57
    block  ;; label = @1
      local.get 57
      br_if 0 (;@1;)
      i32.const 1571
      local.set 58
      i32.const 1342
      local.set 59
      i32.const 123
      local.set 60
      i32.const 1113
      local.set 61
      local.get 58
      local.get 59
      local.get 60
      local.get 61
      call $__assert_fail
      unreachable
    end
    i32.const 66
    local.set 62
    local.get 2
    local.get 62
    i32.add
    local.set 63
    local.get 63
    local.set 64
    i32.const 10000
    local.set 65
    local.get 2
    local.get 65
    i32.store offset=32
    i32.const 1156
    local.set 66
    i32.const 32
    local.set 67
    local.get 2
    local.get 67
    i32.add
    local.set 68
    local.get 64
    local.get 66
    local.get 68
    call $sprintf
    drop
    local.get 2
    i32.load offset=76
    local.set 69
    i32.const 66
    local.set 70
    local.get 2
    local.get 70
    i32.add
    local.set 71
    local.get 71
    local.set 72
    local.get 69
    local.get 72
    call $hash_table_lookup
    local.set 73
    i32.const 0
    local.set 74
    local.get 73
    local.get 74
    i32.eq
    local.set 75
    i32.const 1
    local.set 76
    local.get 75
    local.get 76
    i32.and
    local.set 77
    block  ;; label = @1
      local.get 77
      br_if 0 (;@1;)
      i32.const 1571
      local.set 78
      i32.const 1342
      local.set 79
      i32.const 125
      local.set 80
      i32.const 1113
      local.set 81
      local.get 78
      local.get 79
      local.get 80
      local.get 81
      call $__assert_fail
      unreachable
    end
    i32.const 66
    local.set 82
    local.get 2
    local.get 82
    i32.add
    local.set 83
    local.get 83
    local.set 84
    i32.const 12345
    local.set 85
    local.get 2
    local.get 85
    i32.store offset=16
    i32.const 1156
    local.set 86
    i32.const 16
    local.set 87
    local.get 2
    local.get 87
    i32.add
    local.set 88
    local.get 84
    local.get 86
    local.get 88
    call $sprintf
    drop
    local.get 2
    i32.load offset=76
    local.set 89
    i32.const 66
    local.set 90
    local.get 2
    local.get 90
    i32.add
    local.set 91
    local.get 91
    local.set 92
    i32.const 1266
    local.set 93
    local.get 93
    call $alloc_test_strdup
    local.set 94
    local.get 89
    local.get 92
    local.get 94
    call $hash_table_insert
    drop
    local.get 2
    i32.load offset=76
    local.set 95
    i32.const 66
    local.set 96
    local.get 2
    local.get 96
    i32.add
    local.set 97
    local.get 97
    local.set 98
    local.get 95
    local.get 98
    call $hash_table_lookup
    local.set 99
    local.get 2
    local.get 99
    i32.store offset=60
    local.get 2
    i32.load offset=60
    local.set 100
    i32.const 1266
    local.set 101
    local.get 100
    local.get 101
    call $strcmp
    local.set 102
    block  ;; label = @1
      local.get 102
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2196
      local.set 103
      i32.const 1342
      local.set 104
      i32.const 131
      local.set 105
      i32.const 1113
      local.set 106
      local.get 103
      local.get 104
      local.get 105
      local.get 106
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=76
    local.set 107
    local.get 107
    call $hash_table_free
    i32.const 80
    local.set 108
    local.get 2
    local.get 108
    i32.add
    local.set 109
    local.get 109
    global.set $__stack_pointer
    return)"
test_hash_table_iterating_remove,,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void test_hash_table_iterating_remove(void)
{
	HashTable *hash_table;
	HashTableIterator iterator;
	char buf[10];
	char *val;
	HashTablePair pair;
	int count;
	unsigned int removed;
	int i;

	hash_table = generate_hash_table();

	/* Iterate over all values in the table */
	count = 0;
	removed = 0;

	hash_table_iterate(hash_table, &iterator);

	while (hash_table_iter_has_more(&iterator)) {

		/* Read the next value */
		pair = hash_table_iter_next(&iterator);
		val = pair.value;

		/* Remove every hundredth entry */
		if ((atoi(val) % 100) == 0) {
			hash_table_remove(hash_table, val);
			++removed;
		}

		++count;
	}

	/* Check counts */
	assert(removed == 100);
	assert(count == NUM_TEST_VALUES);

	assert(hash_table_num_entries(hash_table) == NUM_TEST_VALUES - removed);

	/* Check all entries divisible by 100 were really removed */
	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		sprintf(buf, ""%i"", i);

		if (i % 100 == 0) {
			assert(hash_table_lookup(hash_table, buf) == NULL);
		} else {
			assert(hash_table_lookup(hash_table, buf) != NULL);
		}
	}

	hash_table_free(hash_table);
}","(func $test_hash_table_iterating_remove (type 8)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 64
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    call $generate_hash_table
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=60
    i32.const 0
    local.set 4
    local.get 2
    local.get 4
    i32.store offset=20
    i32.const 0
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=16
    local.get 2
    i32.load offset=60
    local.set 6
    i32.const 48
    local.set 7
    local.get 2
    local.get 7
    i32.add
    local.set 8
    local.get 8
    local.set 9
    local.get 6
    local.get 9
    call $hash_table_iterate
    block  ;; label = @1
      loop  ;; label = @2
        i32.const 48
        local.set 10
        local.get 2
        local.get 10
        i32.add
        local.set 11
        local.get 11
        local.set 12
        local.get 12
        call $hash_table_iter_has_more
        local.set 13
        local.get 13
        i32.eqz
        br_if 1 (;@1;)
        i32.const 4
        local.set 14
        local.get 2
        local.get 14
        i32.add
        local.set 15
        local.get 15
        local.set 16
        i32.const 48
        local.set 17
        local.get 2
        local.get 17
        i32.add
        local.set 18
        local.get 18
        local.set 19
        local.get 16
        local.get 19
        call $hash_table_iter_next
        local.get 2
        i64.load offset=4 align=4
        local.set 20
        local.get 2
        local.get 20
        i64.store offset=24
        local.get 2
        i32.load offset=28
        local.set 21
        local.get 2
        local.get 21
        i32.store offset=32
        local.get 2
        i32.load offset=32
        local.set 22
        local.get 22
        call $atoi
        local.set 23
        i32.const 100
        local.set 24
        local.get 23
        local.get 24
        i32.rem_s
        local.set 25
        block  ;; label = @3
          local.get 25
          br_if 0 (;@3;)
          local.get 2
          i32.load offset=60
          local.set 26
          local.get 2
          i32.load offset=32
          local.set 27
          local.get 26
          local.get 27
          call $hash_table_remove
          drop
          local.get 2
          i32.load offset=16
          local.set 28
          i32.const 1
          local.set 29
          local.get 28
          local.get 29
          i32.add
          local.set 30
          local.get 2
          local.get 30
          i32.store offset=16
        end
        local.get 2
        i32.load offset=20
        local.set 31
        i32.const 1
        local.set 32
        local.get 31
        local.get 32
        i32.add
        local.set 33
        local.get 2
        local.get 33
        i32.store offset=20
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=16
    local.set 34
    i32.const 100
    local.set 35
    local.get 34
    local.get 35
    i32.eq
    local.set 36
    i32.const 1
    local.set 37
    local.get 36
    local.get 37
    i32.and
    local.set 38
    block  ;; label = @1
      local.get 38
      br_if 0 (;@1;)
      i32.const 1882
      local.set 39
      i32.const 1342
      local.set 40
      i32.const 241
      local.set 41
      i32.const 1185
      local.set 42
      local.get 39
      local.get 40
      local.get 41
      local.get 42
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=20
    local.set 43
    i32.const 10000
    local.set 44
    local.get 43
    local.get 44
    i32.eq
    local.set 45
    i32.const 1
    local.set 46
    local.get 45
    local.get 46
    i32.and
    local.set 47
    block  ;; label = @1
      local.get 47
      br_if 0 (;@1;)
      i32.const 1373
      local.set 48
      i32.const 1342
      local.set 49
      i32.const 242
      local.set 50
      i32.const 1185
      local.set 51
      local.get 48
      local.get 49
      local.get 50
      local.get 51
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=60
    local.set 52
    local.get 52
    call $hash_table_num_entries
    local.set 53
    local.get 2
    i32.load offset=16
    local.set 54
    i32.const 10000
    local.set 55
    local.get 55
    local.get 54
    i32.sub
    local.set 56
    local.get 53
    local.get 56
    i32.eq
    local.set 57
    i32.const 1
    local.set 58
    local.get 57
    local.get 58
    i32.and
    local.set 59
    block  ;; label = @1
      local.get 59
      br_if 0 (;@1;)
      i32.const 1278
      local.set 60
      i32.const 1342
      local.set 61
      i32.const 244
      local.set 62
      i32.const 1185
      local.set 63
      local.get 60
      local.get 61
      local.get 62
      local.get 63
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 64
    local.get 2
    local.get 64
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 65
        i32.const 10000
        local.set 66
        local.get 65
        local.get 66
        i32.lt_s
        local.set 67
        i32.const 1
        local.set 68
        local.get 67
        local.get 68
        i32.and
        local.set 69
        local.get 69
        i32.eqz
        br_if 1 (;@1;)
        i32.const 38
        local.set 70
        local.get 2
        local.get 70
        i32.add
        local.set 71
        local.get 71
        local.set 72
        local.get 2
        i32.load offset=12
        local.set 73
        local.get 2
        local.get 73
        i32.store
        i32.const 1156
        local.set 74
        local.get 72
        local.get 74
        local.get 2
        call $sprintf
        drop
        local.get 2
        i32.load offset=12
        local.set 75
        i32.const 100
        local.set 76
        local.get 75
        local.get 76
        i32.rem_s
        local.set 77
        block  ;; label = @3
          block  ;; label = @4
            local.get 77
            br_if 0 (;@4;)
            local.get 2
            i32.load offset=60
            local.set 78
            i32.const 38
            local.set 79
            local.get 2
            local.get 79
            i32.add
            local.set 80
            local.get 80
            local.set 81
            local.get 78
            local.get 81
            call $hash_table_lookup
            local.set 82
            i32.const 0
            local.set 83
            local.get 82
            local.get 83
            i32.eq
            local.set 84
            i32.const 1
            local.set 85
            local.get 84
            local.get 85
            i32.and
            local.set 86
            block  ;; label = @5
              local.get 86
              br_if 0 (;@5;)
              i32.const 1571
              local.set 87
              i32.const 1342
              local.set 88
              i32.const 251
              local.set 89
              i32.const 1185
              local.set 90
              local.get 87
              local.get 88
              local.get 89
              local.get 90
              call $__assert_fail
              unreachable
            end
            br 1 (;@3;)
          end
          local.get 2
          i32.load offset=60
          local.set 91
          i32.const 38
          local.set 92
          local.get 2
          local.get 92
          i32.add
          local.set 93
          local.get 93
          local.set 94
          local.get 91
          local.get 94
          call $hash_table_lookup
          local.set 95
          i32.const 0
          local.set 96
          local.get 95
          local.get 96
          i32.ne
          local.set 97
          i32.const 1
          local.set 98
          local.get 97
          local.get 98
          i32.and
          local.set 99
          block  ;; label = @4
            local.get 99
            br_if 0 (;@4;)
            i32.const 1633
            local.set 100
            i32.const 1342
            local.set 101
            i32.const 253
            local.set 102
            i32.const 1185
            local.set 103
            local.get 100
            local.get 101
            local.get 102
            local.get 103
            call $__assert_fail
            unreachable
          end
        end
        local.get 2
        i32.load offset=12
        local.set 104
        i32.const 1
        local.set 105
        local.get 104
        local.get 105
        i32.add
        local.set 106
        local.get 2
        local.get 106
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=60
    local.set 107
    local.get 107
    call $hash_table_free
    i32.const 64
    local.set 108
    local.get 2
    local.get 108
    i32.add
    local.set 109
    local.get 109
    global.set $__stack_pointer
    return)"
new_key,int value,"Allocates heap memory for a new data structure or buffer.
Returns NULL on allocation failure; the caller must handle errors.",result,"int *new_key(int value)
{
	int *result;

	result = malloc(sizeof(int));
	*result = value;

	++allocated_keys;

	return result;
}","(func $new_key (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const 4
    local.set 4
    local.get 4
    call $alloc_test_malloc
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=8
    local.get 3
    i32.load offset=12
    local.set 6
    local.get 3
    i32.load offset=8
    local.set 7
    local.get 7
    local.get 6
    i32.store
    i32.const 0
    local.set 8
    local.get 8
    i32.load offset=2356
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.add
    local.set 11
    i32.const 0
    local.set 12
    local.get 12
    local.get 11
    i32.store offset=2356
    local.get 3
    i32.load offset=8
    local.set 13
    i32.const 16
    local.set 14
    local.get 3
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    local.get 13
    return)"
free_key,void *key,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void free_key(void *key)
{
	free(key);

	--allocated_keys;
}","(func $free_key (type 3) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    call $alloc_test_free
    i32.const 0
    local.set 5
    local.get 5
    i32.load offset=2356
    local.set 6
    i32.const -1
    local.set 7
    local.get 6
    local.get 7
    i32.add
    local.set 8
    i32.const 0
    local.set 9
    local.get 9
    local.get 8
    i32.store offset=2356
    i32.const 16
    local.set 10
    local.get 3
    local.get 10
    i32.add
    local.set 11
    local.get 11
    global.set $__stack_pointer
    return)"
new_value,int value,"Allocates heap memory for a new data structure or buffer.
Returns NULL on allocation failure; the caller must handle errors.",result,"int *new_value(int value)
{
	int *result;

	result = malloc(sizeof(int));
	*result = value;

	++allocated_values;

	return result;
}","(func $new_value (type 0) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    i32.const 4
    local.set 4
    local.get 4
    call $alloc_test_malloc
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=8
    local.get 3
    i32.load offset=12
    local.set 6
    local.get 3
    i32.load offset=8
    local.set 7
    local.get 7
    local.get 6
    i32.store
    i32.const 0
    local.set 8
    local.get 8
    i32.load offset=2576
    local.set 9
    i32.const 1
    local.set 10
    local.get 9
    local.get 10
    i32.add
    local.set 11
    i32.const 0
    local.set 12
    local.get 12
    local.get 11
    i32.store offset=2576
    local.get 3
    i32.load offset=8
    local.set 13
    i32.const 16
    local.set 14
    local.get 3
    local.get 14
    i32.add
    local.set 15
    local.get 15
    global.set $__stack_pointer
    local.get 13
    return)"
free_value,void *value,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void free_value(void *value)
{
	free(value);

	--allocated_values;
}","(func $free_value (type 4) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    call $alloc_test_free
    i32.const 0
    local.set 5
    local.get 5
    i32.load offset=2576
    local.set 6
    i32.const -1
    local.set 7
    local.get 6
    local.get 7
    i32.add
    local.set 8
    i32.const 0
    local.set 9
    local.get 9
    local.get 8
    i32.store offset=2576
    i32.const 16
    local.set 10
    local.get 3
    local.get 10
    i32.add
    local.set 11
    local.get 11
    global.set $__stack_pointer
    return)"
test_hash_table_free_functions,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_hash_table_free_functions(void)
{
	HashTable *hash_table;
	int *key;
	int *value;
	int i;

	/* Create a hash table, fill it with values */
	hash_table = hash_table_new(int_hash, int_equal);

	hash_table_register_free_functions(hash_table, free_key, free_value);

	allocated_values = 0;

	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		key = new_key(i);
		value = new_value(99);

		hash_table_insert(hash_table, key, value);
	}

	assert(allocated_keys == NUM_TEST_VALUES);
	assert(allocated_values == NUM_TEST_VALUES);

	/* Check that removing a key works */
	i = NUM_TEST_VALUES / 2;
	hash_table_remove(hash_table, &i);

	assert(allocated_keys == NUM_TEST_VALUES - 1);
	assert(allocated_values == NUM_TEST_VALUES - 1);

	/* Check that replacing an existing key works */
	key = new_key(NUM_TEST_VALUES / 3);
	value = new_value(999);

	assert(allocated_keys == NUM_TEST_VALUES);
	assert(allocated_values == NUM_TEST_VALUES);

	hash_table_insert(hash_table, key, value);

	assert(allocated_keys == NUM_TEST_VALUES - 1);
	assert(allocated_values == NUM_TEST_VALUES - 1);

	/* A free of the hash table should free all of the keys and values */
	hash_table_free(hash_table);

	assert(allocated_keys == 0);
	assert(allocated_values == 0);
}","(func $test_hash_table_free_functions (type 8)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 4
    local.set 3
    i32.const 5
    local.set 4
    local.get 3
    local.get 4
    call $hash_table_new
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=12
    local.get 2
    i32.load offset=12
    local.set 6
    i32.const 6
    local.set 7
    i32.const 7
    local.set 8
    local.get 6
    local.get 7
    local.get 8
    call $hash_table_register_free_functions
    i32.const 0
    local.set 9
    i32.const 0
    local.set 10
    local.get 10
    local.get 9
    i32.store offset=2360
    i32.const 0
    local.set 11
    local.get 2
    local.get 11
    i32.store
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load
        local.set 12
        i32.const 10000
        local.set 13
        local.get 12
        local.get 13
        i32.lt_s
        local.set 14
        i32.const 1
        local.set 15
        local.get 14
        local.get 15
        i32.and
        local.set 16
        local.get 16
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load
        local.set 17
        local.get 17
        call $new_key
        local.set 18
        local.get 2
        local.get 18
        i32.store offset=8
        i32.const 99
        local.set 19
        local.get 19
        call $new_value
        local.set 20
        local.get 2
        local.get 20
        i32.store offset=4
        local.get 2
        i32.load offset=12
        local.set 21
        local.get 2
        i32.load offset=8
        local.set 22
        local.get 2
        i32.load offset=4
        local.set 23
        local.get 21
        local.get 22
        local.get 23
        call $hash_table_insert
        drop
        local.get 2
        i32.load
        local.set 24
        i32.const 1
        local.set 25
        local.get 24
        local.get 25
        i32.add
        local.set 26
        local.get 2
        local.get 26
        i32.store
        br 0 (;@2;)
      end
    end
    i32.const 0
    local.set 27
    local.get 27
    i32.load offset=2356
    local.set 28
    i32.const 10000
    local.set 29
    local.get 28
    local.get 29
    i32.eq
    local.set 30
    i32.const 1
    local.set 31
    local.get 30
    local.get 31
    i32.and
    local.set 32
    block  ;; label = @1
      local.get 32
      br_if 0 (;@1;)
      i32.const 1398
      local.set 33
      i32.const 1342
      local.set 34
      i32.const 324
      local.set 35
      i32.const 1054
      local.set 36
      local.get 33
      local.get 34
      local.get 35
      local.get 36
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 37
    local.get 37
    i32.load offset=2360
    local.set 38
    i32.const 10000
    local.set 39
    local.get 38
    local.get 39
    i32.eq
    local.set 40
    i32.const 1
    local.set 41
    local.get 40
    local.get 41
    i32.and
    local.set 42
    block  ;; label = @1
      local.get 42
      br_if 0 (;@1;)
      i32.const 1432
      local.set 43
      i32.const 1342
      local.set 44
      i32.const 325
      local.set 45
      i32.const 1054
      local.set 46
      local.get 43
      local.get 44
      local.get 45
      local.get 46
      call $__assert_fail
      unreachable
    end
    i32.const 5000
    local.set 47
    local.get 2
    local.get 47
    i32.store
    local.get 2
    i32.load offset=12
    local.set 48
    local.get 2
    local.set 49
    local.get 48
    local.get 49
    call $hash_table_remove
    drop
    i32.const 0
    local.set 50
    local.get 50
    i32.load offset=2356
    local.set 51
    i32.const 9999
    local.set 52
    local.get 51
    local.get 52
    i32.eq
    local.set 53
    i32.const 1
    local.set 54
    local.get 53
    local.get 54
    i32.and
    local.set 55
    block  ;; label = @1
      local.get 55
      br_if 0 (;@1;)
      i32.const 1760
      local.set 56
      i32.const 1342
      local.set 57
      i32.const 331
      local.set 58
      i32.const 1054
      local.set 59
      local.get 56
      local.get 57
      local.get 58
      local.get 59
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 60
    local.get 60
    i32.load offset=2360
    local.set 61
    i32.const 9999
    local.set 62
    local.get 61
    local.get 62
    i32.eq
    local.set 63
    i32.const 1
    local.set 64
    local.get 63
    local.get 64
    i32.and
    local.set 65
    block  ;; label = @1
      local.get 65
      br_if 0 (;@1;)
      i32.const 1798
      local.set 66
      i32.const 1342
      local.set 67
      i32.const 332
      local.set 68
      i32.const 1054
      local.set 69
      local.get 66
      local.get 67
      local.get 68
      local.get 69
      call $__assert_fail
      unreachable
    end
    i32.const 3333
    local.set 70
    local.get 70
    call $new_key
    local.set 71
    local.get 2
    local.get 71
    i32.store offset=8
    i32.const 999
    local.set 72
    local.get 72
    call $new_value
    local.set 73
    local.get 2
    local.get 73
    i32.store offset=4
    i32.const 0
    local.set 74
    local.get 74
    i32.load offset=2356
    local.set 75
    i32.const 10000
    local.set 76
    local.get 75
    local.get 76
    i32.eq
    local.set 77
    i32.const 1
    local.set 78
    local.get 77
    local.get 78
    i32.and
    local.set 79
    block  ;; label = @1
      local.get 79
      br_if 0 (;@1;)
      i32.const 1398
      local.set 80
      i32.const 1342
      local.set 81
      i32.const 338
      local.set 82
      i32.const 1054
      local.set 83
      local.get 80
      local.get 81
      local.get 82
      local.get 83
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 84
    local.get 84
    i32.load offset=2360
    local.set 85
    i32.const 10000
    local.set 86
    local.get 85
    local.get 86
    i32.eq
    local.set 87
    i32.const 1
    local.set 88
    local.get 87
    local.get 88
    i32.and
    local.set 89
    block  ;; label = @1
      local.get 89
      br_if 0 (;@1;)
      i32.const 1432
      local.set 90
      i32.const 1342
      local.set 91
      i32.const 339
      local.set 92
      i32.const 1054
      local.set 93
      local.get 90
      local.get 91
      local.get 92
      local.get 93
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 94
    local.get 2
    i32.load offset=8
    local.set 95
    local.get 2
    i32.load offset=4
    local.set 96
    local.get 94
    local.get 95
    local.get 96
    call $hash_table_insert
    drop
    i32.const 0
    local.set 97
    local.get 97
    i32.load offset=2356
    local.set 98
    i32.const 9999
    local.set 99
    local.get 98
    local.get 99
    i32.eq
    local.set 100
    i32.const 1
    local.set 101
    local.get 100
    local.get 101
    i32.and
    local.set 102
    block  ;; label = @1
      local.get 102
      br_if 0 (;@1;)
      i32.const 1760
      local.set 103
      i32.const 1342
      local.set 104
      i32.const 343
      local.set 105
      i32.const 1054
      local.set 106
      local.get 103
      local.get 104
      local.get 105
      local.get 106
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 107
    local.get 107
    i32.load offset=2360
    local.set 108
    i32.const 9999
    local.set 109
    local.get 108
    local.get 109
    i32.eq
    local.set 110
    i32.const 1
    local.set 111
    local.get 110
    local.get 111
    i32.and
    local.set 112
    block  ;; label = @1
      local.get 112
      br_if 0 (;@1;)
      i32.const 1798
      local.set 113
      i32.const 1342
      local.set 114
      i32.const 344
      local.set 115
      i32.const 1054
      local.set 116
      local.get 113
      local.get 114
      local.get 115
      local.get 116
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=12
    local.set 117
    local.get 117
    call $hash_table_free
    i32.const 0
    local.set 118
    local.get 118
    i32.load offset=2356
    local.set 119
    block  ;; label = @1
      local.get 119
      i32.eqz
      br_if 0 (;@1;)
      i32.const 1897
      local.set 120
      i32.const 1342
      local.set 121
      i32.const 349
      local.set 122
      i32.const 1054
      local.set 123
      local.get 120
      local.get 121
      local.get 122
      local.get 123
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 124
    local.get 124
    i32.load offset=2360
    local.set 125
    block  ;; label = @1
      local.get 125
      i32.eqz
      br_if 0 (;@1;)
      i32.const 1917
      local.set 126
      i32.const 1342
      local.set 127
      i32.const 350
      local.set 128
      i32.const 1054
      local.set 129
      local.get 126
      local.get 127
      local.get 128
      local.get 129
      call $__assert_fail
      unreachable
    end
    i32.const 16
    local.set 130
    local.get 2
    local.get 130
    i32.add
    local.set 131
    local.get 131
    global.set $__stack_pointer
    return)"
test_hash_table_out_of_memory,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_hash_table_out_of_memory(void)
{
	HashTable *hash_table;
	int values[66];
	unsigned int i;

	hash_table = hash_table_new(int_hash, int_equal);

	/* Test normal failure */
	alloc_test_set_limit(0);
	values[0] = 0;
	assert(hash_table_insert(hash_table, &values[0], &values[0]) == 0);
	assert(hash_table_num_entries(hash_table) == 0);

	alloc_test_set_limit(-1);

	/* Test failure when increasing table size.
	 * The initial table size is 193 entries.  The table increases in
	 * size when 1/3 full, so the 66th entry should cause the insert
	 * to fail.
	 */
	for (i = 0; i < 65; ++i) {
		values[i] = (int) i;

		assert(hash_table_insert(hash_table, &values[i], &values[i]) !=
		       0);
		assert(hash_table_num_entries(hash_table) == i + 1);
	}

	assert(hash_table_num_entries(hash_table) == 65);

	/* Test the 66th insert */
	alloc_test_set_limit(0);

	values[65] = 65;

	assert(hash_table_insert(hash_table, &values[65], &values[65]) == 0);
	assert(hash_table_num_entries(hash_table) == 65);

	hash_table_free(hash_table);
}","(func $test_hash_table_out_of_memory (type 8)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 288
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 4
    local.set 3
    i32.const 5
    local.set 4
    local.get 3
    local.get 4
    call $hash_table_new
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=284
    i32.const 0
    local.set 6
    local.get 6
    call $alloc_test_set_limit
    i32.const 0
    local.set 7
    local.get 2
    local.get 7
    i32.store offset=16
    local.get 2
    i32.load offset=284
    local.set 8
    i32.const 16
    local.set 9
    local.get 2
    local.get 9
    i32.add
    local.set 10
    local.get 10
    local.set 11
    i32.const 16
    local.set 12
    local.get 2
    local.get 12
    i32.add
    local.set 13
    local.get 13
    local.set 14
    local.get 8
    local.get 11
    local.get 14
    call $hash_table_insert
    local.set 15
    block  ;; label = @1
      local.get 15
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2105
      local.set 16
      i32.const 1342
      local.set 17
      i32.const 365
      local.set 18
      i32.const 1024
      local.set 19
      local.get 16
      local.get 17
      local.get 18
      local.get 19
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 20
    local.get 20
    call $hash_table_num_entries
    local.set 21
    block  ;; label = @1
      local.get 21
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2004
      local.set 22
      i32.const 1342
      local.set 23
      i32.const 366
      local.set 24
      i32.const 1024
      local.set 25
      local.get 22
      local.get 23
      local.get 24
      local.get 25
      call $__assert_fail
      unreachable
    end
    i32.const -1
    local.set 26
    local.get 26
    call $alloc_test_set_limit
    i32.const 0
    local.set 27
    local.get 2
    local.get 27
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 28
        i32.const 65
        local.set 29
        local.get 28
        local.get 29
        i32.lt_u
        local.set 30
        i32.const 1
        local.set 31
        local.get 30
        local.get 31
        i32.and
        local.set 32
        local.get 32
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=12
        local.set 33
        local.get 2
        i32.load offset=12
        local.set 34
        i32.const 16
        local.set 35
        local.get 2
        local.get 35
        i32.add
        local.set 36
        local.get 36
        local.set 37
        i32.const 2
        local.set 38
        local.get 34
        local.get 38
        i32.shl
        local.set 39
        local.get 37
        local.get 39
        i32.add
        local.set 40
        local.get 40
        local.get 33
        i32.store
        local.get 2
        i32.load offset=284
        local.set 41
        local.get 2
        i32.load offset=12
        local.set 42
        i32.const 16
        local.set 43
        local.get 2
        local.get 43
        i32.add
        local.set 44
        local.get 44
        local.set 45
        i32.const 2
        local.set 46
        local.get 42
        local.get 46
        i32.shl
        local.set 47
        local.get 45
        local.get 47
        i32.add
        local.set 48
        local.get 2
        i32.load offset=12
        local.set 49
        i32.const 16
        local.set 50
        local.get 2
        local.get 50
        i32.add
        local.set 51
        local.get 51
        local.set 52
        i32.const 2
        local.set 53
        local.get 49
        local.get 53
        i32.shl
        local.set 54
        local.get 52
        local.get 54
        i32.add
        local.set 55
        local.get 41
        local.get 48
        local.get 55
        call $hash_table_insert
        local.set 56
        block  ;; label = @3
          local.get 56
          br_if 0 (;@3;)
          i32.const 2230
          local.set 57
          i32.const 1342
          local.set 58
          i32.const 379
          local.set 59
          i32.const 1024
          local.set 60
          local.get 57
          local.get 58
          local.get 59
          local.get 60
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=284
        local.set 61
        local.get 61
        call $hash_table_num_entries
        local.set 62
        local.get 2
        i32.load offset=12
        local.set 63
        i32.const 1
        local.set 64
        local.get 63
        local.get 64
        i32.add
        local.set 65
        local.get 62
        local.get 65
        i32.eq
        local.set 66
        i32.const 1
        local.set 67
        local.get 66
        local.get 67
        i32.and
        local.set 68
        block  ;; label = @3
          local.get 68
          br_if 0 (;@3;)
          i32.const 1838
          local.set 69
          i32.const 1342
          local.set 70
          i32.const 380
          local.set 71
          i32.const 1024
          local.set 72
          local.get 69
          local.get 70
          local.get 71
          local.get 72
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=12
        local.set 73
        i32.const 1
        local.set 74
        local.get 73
        local.get 74
        i32.add
        local.set 75
        local.get 2
        local.get 75
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=284
    local.set 76
    local.get 76
    call $hash_table_num_entries
    local.set 77
    i32.const 65
    local.set 78
    local.get 77
    local.get 78
    i32.eq
    local.set 79
    i32.const 1
    local.set 80
    local.get 79
    local.get 80
    i32.and
    local.set 81
    block  ;; label = @1
      local.get 81
      br_if 0 (;@1;)
      i32.const 1719
      local.set 82
      i32.const 1342
      local.set 83
      i32.const 383
      local.set 84
      i32.const 1024
      local.set 85
      local.get 82
      local.get 83
      local.get 84
      local.get 85
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 86
    local.get 86
    call $alloc_test_set_limit
    i32.const 65
    local.set 87
    local.get 2
    local.get 87
    i32.store offset=276
    local.get 2
    i32.load offset=284
    local.set 88
    i32.const 16
    local.set 89
    local.get 2
    local.get 89
    i32.add
    local.set 90
    local.get 90
    local.set 91
    i32.const 260
    local.set 92
    local.get 91
    local.get 92
    i32.add
    local.set 93
    i32.const 16
    local.set 94
    local.get 2
    local.get 94
    i32.add
    local.set 95
    local.get 95
    local.set 96
    i32.const 260
    local.set 97
    local.get 96
    local.get 97
    i32.add
    local.set 98
    local.get 88
    local.get 93
    local.get 98
    call $hash_table_insert
    local.set 99
    block  ;; label = @1
      local.get 99
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2044
      local.set 100
      i32.const 1342
      local.set 101
      i32.const 390
      local.set 102
      i32.const 1024
      local.set 103
      local.get 100
      local.get 101
      local.get 102
      local.get 103
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 104
    local.get 104
    call $hash_table_num_entries
    local.set 105
    i32.const 65
    local.set 106
    local.get 105
    local.get 106
    i32.eq
    local.set 107
    i32.const 1
    local.set 108
    local.get 107
    local.get 108
    i32.and
    local.set 109
    block  ;; label = @1
      local.get 109
      br_if 0 (;@1;)
      i32.const 1719
      local.set 110
      i32.const 1342
      local.set 111
      i32.const 391
      local.set 112
      i32.const 1024
      local.set 113
      local.get 110
      local.get 111
      local.get 112
      local.get 113
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 114
    local.get 114
    call $hash_table_free
    i32.const 288
    local.set 115
    local.get 2
    local.get 115
    i32.add
    local.set 116
    local.get 116
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_list_iterate_bad_remove,,"Inserts an element at the beginning of a collection.
Shifts existing elements forward and increments the length.",null,"void test_list_iterate_bad_remove(void)
{
	ListEntry *list;
	ListIterator iter;
	int values[49];
	int i;
	int *val;

	/* Create a list with 49 entries */
	list = NULL;

	for (i = 0; i < 49; ++i) {
		values[i] = i;
		assert(list_prepend(&list, &values[i]) != NULL);
	}

	/* Iterate over the list, removing each element in turn.  We
	 * use an odd number of list elements so that the first and
	 * last entries are removed. */
	list_iterate(&list, &iter);

	while (list_iter_has_more(&iter)) {
		val = list_iter_next(&iter);

		/* Remove all the even numbers. Check that list_iter_remove
		 * can cope with the fact that the current element has
		 * already been removed. */
		if ((*val % 2) == 0) {
			assert(list_remove_data(&list, int_equal, val) != 0);
			list_iter_remove(&iter);
		}
	}

	list_free(list);
}","(func $test_list_iterate_bad_remove (type 6)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 224
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 0
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=220
    i32.const 0
    local.set 4
    local.get 2
    local.get 4
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 5
        i32.const 49
        local.set 6
        local.get 5
        local.get 6
        i32.lt_s
        local.set 7
        i32.const 1
        local.set 8
        local.get 7
        local.get 8
        i32.and
        local.set 9
        local.get 9
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=12
        local.set 10
        local.get 2
        i32.load offset=12
        local.set 11
        i32.const 16
        local.set 12
        local.get 2
        local.get 12
        i32.add
        local.set 13
        local.get 13
        local.set 14
        i32.const 2
        local.set 15
        local.get 11
        local.get 15
        i32.shl
        local.set 16
        local.get 14
        local.get 16
        i32.add
        local.set 17
        local.get 17
        local.get 10
        i32.store
        local.get 2
        i32.load offset=12
        local.set 18
        i32.const 16
        local.set 19
        local.get 2
        local.get 19
        i32.add
        local.set 20
        local.get 20
        local.set 21
        i32.const 2
        local.set 22
        local.get 18
        local.get 22
        i32.shl
        local.set 23
        local.get 21
        local.get 23
        i32.add
        local.set 24
        i32.const 220
        local.set 25
        local.get 2
        local.get 25
        i32.add
        local.set 26
        local.get 26
        local.set 27
        local.get 27
        local.get 24
        call $list_prepend
        local.set 28
        i32.const 0
        local.set 29
        local.get 28
        local.get 29
        i32.ne
        local.set 30
        i32.const 1
        local.set 31
        local.get 30
        local.get 31
        i32.and
        local.set 32
        block  ;; label = @3
          local.get 32
          br_if 0 (;@3;)
          i32.const 1774
          local.set 33
          i32.const 1321
          local.set 34
          i32.const 485
          local.set 35
          i32.const 1239
          local.set 36
          local.get 33
          local.get 34
          local.get 35
          local.get 36
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=12
        local.set 37
        i32.const 1
        local.set 38
        local.get 37
        local.get 38
        i32.add
        local.set 39
        local.get 2
        local.get 39
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    i32.const 220
    local.set 40
    local.get 2
    local.get 40
    i32.add
    local.set 41
    local.get 41
    local.set 42
    i32.const 212
    local.set 43
    local.get 2
    local.get 43
    i32.add
    local.set 44
    local.get 44
    local.set 45
    local.get 42
    local.get 45
    call $list_iterate
    block  ;; label = @1
      loop  ;; label = @2
        i32.const 212
        local.set 46
        local.get 2
        local.get 46
        i32.add
        local.set 47
        local.get 47
        local.set 48
        local.get 48
        call $list_iter_has_more
        local.set 49
        local.get 49
        i32.eqz
        br_if 1 (;@1;)
        i32.const 212
        local.set 50
        local.get 2
        local.get 50
        i32.add
        local.set 51
        local.get 51
        local.set 52
        local.get 52
        call $list_iter_next
        local.set 53
        local.get 2
        local.get 53
        i32.store offset=8
        local.get 2
        i32.load offset=8
        local.set 54
        local.get 54
        i32.load
        local.set 55
        i32.const 2
        local.set 56
        local.get 55
        local.get 56
        i32.rem_s
        local.set 57
        block  ;; label = @3
          local.get 57
          br_if 0 (;@3;)
          local.get 2
          i32.load offset=8
          local.set 58
          i32.const 220
          local.set 59
          local.get 2
          local.get 59
          i32.add
          local.set 60
          local.get 60
          local.set 61
          i32.const 1
          local.set 62
          local.get 61
          local.get 62
          local.get 58
          call $list_remove_data
          local.set 63
          block  ;; label = @4
            local.get 63
            br_if 0 (;@4;)
            i32.const 3413
            local.set 64
            i32.const 1321
            local.set 65
            i32.const 500
            local.set 66
            i32.const 1239
            local.set 67
            local.get 64
            local.get 65
            local.get 66
            local.get 67
            call $__assert_fail
            unreachable
          end
          i32.const 212
          local.set 68
          local.get 2
          local.get 68
          i32.add
          local.set 69
          local.get 69
          local.set 70
          local.get 70
          call $list_iter_remove
        end
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=220
    local.set 71
    local.get 71
    call $list_free
    i32.const 224
    local.set 72
    local.get 2
    local.get 72
    i32.add
    local.set 73
    local.get 73
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_queue_new_free,,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void test_queue_new_free(void)
{
	int i;
	Queue *queue;

	/* Create and destroy a queue */
	queue = queue_new();

	queue_free(queue);

	/* Add lots of values and then destroy */
	queue = queue_new();

	for (i = 0; i < 1000; ++i) {
		queue_push_head(queue, &variable1);
	}

	queue_free(queue);

	/* Test allocation when there is no free memory */
	alloc_test_set_limit(0);
	queue = queue_new();
	assert(queue == NULL);
}","(func $test_queue_new_free (type 5)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    call $queue_new
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=8
    local.get 2
    i32.load offset=8
    local.set 4
    local.get 4
    call $queue_free
    call $queue_new
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=8
    i32.const 0
    local.set 6
    local.get 2
    local.get 6
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 7
        i32.const 1000
        local.set 8
        local.get 7
        local.get 8
        i32.lt_s
        local.set 9
        i32.const 1
        local.set 10
        local.get 9
        local.get 10
        i32.and
        local.set 11
        local.get 11
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=8
        local.set 12
        i32.const 2068
        local.set 13
        local.get 12
        local.get 13
        call $queue_push_head
        drop
        local.get 2
        i32.load offset=12
        local.set 14
        i32.const 1
        local.set 15
        local.get 14
        local.get 15
        i32.add
        local.set 16
        local.get 2
        local.get 16
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=8
    local.set 17
    local.get 17
    call $queue_free
    i32.const 0
    local.set 18
    local.get 18
    call $alloc_test_set_limit
    call $queue_new
    local.set 19
    local.get 2
    local.get 19
    i32.store offset=8
    local.get 2
    i32.load offset=8
    local.set 20
    i32.const 0
    local.set 21
    local.get 20
    local.get 21
    i32.eq
    local.set 22
    i32.const 1
    local.set 23
    local.get 22
    local.get 23
    i32.and
    local.set 24
    block  ;; label = @1
      local.get 24
      br_if 0 (;@1;)
      i32.const 1214
      local.set 25
      i32.const 1188
      local.set 26
      i32.const 73
      local.set 27
      i32.const 1106
      local.set 28
      local.get 25
      local.get 26
      local.get 27
      local.get 28
      call $__assert_fail
      unreachable
    end
    i32.const 16
    local.set 29
    local.get 2
    local.get 29
    i32.add
    local.set 30
    local.get 30
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
print_tree,"RBTreeNode *node, int depth","Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",null,"static void print_tree(RBTreeNode *node, int depth)
{
	int *value;
	int i;

	if (node == NULL) {
		return;
	}

	print_tree(rb_tree_node_child(node, RB_TREE_NODE_LEFT), depth + 1);

	for (i=0; i<depth*6; ++i) {
		printf("" "");
	}

	value = rb_tree_node_key(node);
	printf(""%i\n"", *value);

	print_tree(rb_tree_node_child(node, RB_TREE_NODE_RIGHT), depth + 1);
}",
find_subtree_height,RBTreeNode *node,"Performs an action and returns 0 on failure or 1 on success.
Typical for functions that modify data structures and need to signal status.",0 | left_height + 1 | right_height + 1,"
int find_subtree_height(RBTreeNode *node)
{
	RBTreeNode *left_subtree;
	RBTreeNode *right_subtree;
	int left_height, right_height;

	if (node == NULL) {
		return 0;
	}

	left_subtree = rb_tree_node_child(node, RB_TREE_NODE_LEFT);
	right_subtree = rb_tree_node_child(node, RB_TREE_NODE_RIGHT);
	left_height = find_subtree_height(left_subtree);
	right_height = find_subtree_height(right_subtree);

	if (left_height > right_height) {
		return left_height + 1;
	} else {
		return right_height + 1;
	}
}","(func $find_subtree_height (type 1) (param i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 32
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=24
    local.get 3
    i32.load offset=24
    local.set 4
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.eq
    local.set 6
    i32.const 1
    local.set 7
    local.get 6
    local.get 7
    i32.and
    local.set 8
    block  ;; label = @1
      block  ;; label = @2
        local.get 8
        i32.eqz
        br_if 0 (;@2;)
        i32.const 0
        local.set 9
        local.get 3
        local.get 9
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=24
      local.set 10
      i32.const 0
      local.set 11
      local.get 10
      local.get 11
      call $avl_tree_node_child
      local.set 12
      local.get 3
      local.get 12
      i32.store offset=20
      local.get 3
      i32.load offset=24
      local.set 13
      i32.const 1
      local.set 14
      local.get 13
      local.get 14
      call $avl_tree_node_child
      local.set 15
      local.get 3
      local.get 15
      i32.store offset=16
      local.get 3
      i32.load offset=20
      local.set 16
      local.get 16
      call $find_subtree_height
      local.set 17
      local.get 3
      local.get 17
      i32.store offset=12
      local.get 3
      i32.load offset=16
      local.set 18
      local.get 18
      call $find_subtree_height
      local.set 19
      local.get 3
      local.get 19
      i32.store offset=8
      local.get 3
      i32.load offset=12
      local.set 20
      local.get 3
      i32.load offset=8
      local.set 21
      local.get 20
      local.get 21
      i32.gt_s
      local.set 22
      i32.const 1
      local.set 23
      local.get 22
      local.get 23
      i32.and
      local.set 24
      block  ;; label = @2
        local.get 24
        i32.eqz
        br_if 0 (;@2;)
        local.get 3
        i32.load offset=12
        local.set 25
        i32.const 1
        local.set 26
        local.get 25
        local.get 26
        i32.add
        local.set 27
        local.get 3
        local.get 27
        i32.store offset=28
        br 1 (;@1;)
      end
      local.get 3
      i32.load offset=8
      local.set 28
      i32.const 1
      local.set 29
      local.get 28
      local.get 29
      i32.add
      local.set 30
      local.get 3
      local.get 30
      i32.store offset=28
    end
    local.get 3
    i32.load offset=28
    local.set 31
    i32.const 32
    local.set 32
    local.get 3
    local.get 32
    i32.add
    local.set 33
    local.get 33
    global.set $__stack_pointer
    local.get 31
    return)"
validate_tree,RBTree *tree,"Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",null,"
void validate_tree(RBTree *tree)
{
}","(func $validate_tree (type 4) (param i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 1
    i32.const 16
    local.set 2
    local.get 1
    local.get 2
    i32.sub
    local.set 3
    local.get 3
    global.set $__stack_pointer
    local.get 3
    local.get 0
    i32.store offset=12
    local.get 3
    i32.load offset=12
    local.set 4
    local.get 4
    call $avl_tree_root_node
    local.set 5
    local.get 3
    local.get 5
    i32.store offset=8
    local.get 3
    i32.load offset=8
    local.set 6
    i32.const 0
    local.set 7
    local.get 6
    local.get 7
    i32.ne
    local.set 8
    i32.const 1
    local.set 9
    local.get 8
    local.get 9
    i32.and
    local.set 10
    block  ;; label = @1
      local.get 10
      i32.eqz
      br_if 0 (;@1;)
      local.get 3
      i32.load offset=8
      local.set 11
      local.get 11
      call $find_subtree_height
      local.set 12
      local.get 3
      local.get 12
      i32.store offset=4
      local.get 3
      i32.load offset=8
      local.set 13
      local.get 13
      call $avl_tree_subtree_height
      local.set 14
      local.get 3
      i32.load offset=4
      local.set 15
      local.get 14
      local.get 15
      i32.eq
      local.set 16
      i32.const 1
      local.set 17
      local.get 16
      local.get 17
      i32.and
      local.set 18
      block  ;; label = @2
        local.get 18
        br_if 0 (;@2;)
        i32.const 1186
        local.set 19
        i32.const 1567
        local.set 20
        i32.const 143
        local.set 21
        i32.const 1452
        local.set 22
        local.get 19
        local.get 20
        local.get 21
        local.get 22
        call $__assert_fail
        unreachable
      end
    end
    i32.const -1
    local.set 23
    i32.const 0
    local.set 24
    local.get 24
    local.get 23
    i32.store offset=2304
    local.get 3
    i32.load offset=8
    local.set 25
    local.get 25
    call $validate_subtree
    drop
    i32.const 16
    local.set 26
    local.get 3
    local.get 26
    i32.add
    local.set 27
    local.get 27
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);
	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_set_iterating_remove,,"Frees allocated memory associated with the data structure or object.
Performs NULL checks before freeing to avoid invalid free operations.",null,"void test_set_iterating_remove(void)
{
	Set *set;
	SetIterator iterator;
	int count;
	unsigned int removed;
	char *value;

	set = generate_set();

	count = 0;
	removed = 0;

	/* Iterate over all values in the set */
	set_iterate(set, &iterator);

	while (set_iter_has_more(&iterator)) {

		value = set_iter_next(&iterator);

		if ((atoi(value) % 100) == 0) {

			/* Remove this value */
			set_remove(set, value);

			++removed;
		}

		++count;
	}

	/* Check final counts */
	assert(count == 10000);
	assert(removed == 100);
	assert(set_num_entries(set) == 10000 - removed);

	set_free(set);
}","(func $test_set_iterating_remove (type 7)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 32
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    call $generate_set
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=28
    i32.const 0
    local.set 4
    local.get 2
    local.get 4
    i32.store offset=12
    i32.const 0
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=8
    local.get 2
    i32.load offset=28
    local.set 6
    i32.const 16
    local.set 7
    local.get 2
    local.get 7
    i32.add
    local.set 8
    local.get 8
    local.set 9
    local.get 6
    local.get 9
    call $set_iterate
    block  ;; label = @1
      loop  ;; label = @2
        i32.const 16
        local.set 10
        local.get 2
        local.get 10
        i32.add
        local.set 11
        local.get 11
        local.set 12
        local.get 12
        call $set_iter_has_more
        local.set 13
        local.get 13
        i32.eqz
        br_if 1 (;@1;)
        i32.const 16
        local.set 14
        local.get 2
        local.get 14
        i32.add
        local.set 15
        local.get 15
        local.set 16
        local.get 16
        call $set_iter_next
        local.set 17
        local.get 2
        local.get 17
        i32.store offset=4
        local.get 2
        i32.load offset=4
        local.set 18
        local.get 18
        call $atoi
        local.set 19
        i32.const 100
        local.set 20
        local.get 19
        local.get 20
        i32.rem_s
        local.set 21
        block  ;; label = @3
          local.get 21
          br_if 0 (;@3;)
          local.get 2
          i32.load offset=28
          local.set 22
          local.get 2
          i32.load offset=4
          local.set 23
          local.get 22
          local.get 23
          call $set_remove
          drop
          local.get 2
          i32.load offset=8
          local.set 24
          i32.const 1
          local.set 25
          local.get 24
          local.get 25
          i32.add
          local.set 26
          local.get 2
          local.get 26
          i32.store offset=8
        end
        local.get 2
        i32.load offset=12
        local.set 27
        i32.const 1
        local.set 28
        local.get 27
        local.get 28
        i32.add
        local.set 29
        local.get 2
        local.get 29
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=12
    local.set 30
    i32.const 10000
    local.set 31
    local.get 30
    local.get 31
    i32.eq
    local.set 32
    i32.const 1
    local.set 33
    local.get 32
    local.get 33
    i32.and
    local.set 34
    block  ;; label = @1
      local.get 34
      br_if 0 (;@1;)
      i32.const 1821
      local.set 35
      i32.const 1367
      local.set 36
      i32.const 403
      local.set 37
      i32.const 1243
      local.set 38
      local.get 35
      local.get 36
      local.get 37
      local.get 38
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=8
    local.set 39
    i32.const 100
    local.set 40
    local.get 39
    local.get 40
    i32.eq
    local.set 41
    i32.const 1
    local.set 42
    local.get 41
    local.get 42
    i32.and
    local.set 43
    block  ;; label = @1
      local.get 43
      br_if 0 (;@1;)
      i32.const 1781
      local.set 44
      i32.const 1367
      local.set 45
      i32.const 404
      local.set 46
      i32.const 1243
      local.set 47
      local.get 44
      local.get 45
      local.get 46
      local.get 47
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=28
    local.set 48
    local.get 48
    call $set_num_entries
    local.set 49
    local.get 2
    i32.load offset=8
    local.set 50
    i32.const 10000
    local.set 51
    local.get 51
    local.get 50
    i32.sub
    local.set 52
    local.get 49
    local.get 52
    i32.eq
    local.set 53
    i32.const 1
    local.set 54
    local.get 53
    local.get 54
    i32.and
    local.set 55
    block  ;; label = @1
      local.get 55
      br_if 0 (;@1;)
      i32.const 1287
      local.set 56
      i32.const 1367
      local.set 57
      i32.const 405
      local.set 58
      i32.const 1243
      local.set 59
      local.get 56
      local.get 57
      local.get 58
      local.get 59
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=28
    local.set 60
    local.get 60
    call $set_free
    i32.const 32
    local.set 61
    local.get 2
    local.get 61
    i32.add
    local.set 62
    local.get 62
    global.set $__stack_pointer
    return)"
test_set_out_of_memory,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"void test_set_out_of_memory(void)
{
	Set *set;
	int values[66];
	unsigned int i;

	set = set_new(int_hash, int_equal);

	/* Test normal failure */
	alloc_test_set_limit(0);
	values[0] = 0;
	assert(set_insert(set, &values[0]) == 0);
	assert(set_num_entries(set) == 0);

	alloc_test_set_limit(-1);

	/* Test failure when increasing table size.
	 * The initial table size is 193 entries.  The table increases in
	 * size when 1/3 full, so the 66th entry should cause the insert
	 * to fail. */
	for (i = 0; i < 65; ++i) {
		values[i] = (int) i;

		assert(set_insert(set, &values[i]) != 0);
		assert(set_num_entries(set) == i + 1);
	}

	assert(set_num_entries(set) == 65);

	/* Test the 66th insert */
	alloc_test_set_limit(0);

	values[65] = 65;

	assert(set_insert(set, &values[65]) == 0);
	assert(set_num_entries(set) == 65);

	set_free(set);
}","(func $test_set_out_of_memory (type 7)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 288
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 4
    local.set 3
    i32.const 5
    local.set 4
    local.get 3
    local.get 4
    call $set_new
    local.set 5
    local.get 2
    local.get 5
    i32.store offset=284
    i32.const 0
    local.set 6
    local.get 6
    call $alloc_test_set_limit
    i32.const 0
    local.set 7
    local.get 2
    local.get 7
    i32.store offset=16
    local.get 2
    i32.load offset=284
    local.set 8
    i32.const 16
    local.set 9
    local.get 2
    local.get 9
    i32.add
    local.set 10
    local.get 10
    local.set 11
    local.get 8
    local.get 11
    call $set_insert
    local.set 12
    block  ;; label = @1
      local.get 12
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2024
      local.set 13
      i32.const 1367
      local.set 14
      i32.const 474
      local.set 15
      i32.const 1024
      local.set 16
      local.get 13
      local.get 14
      local.get 15
      local.get 16
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 17
    local.get 17
    call $set_num_entries
    local.set 18
    block  ;; label = @1
      local.get 18
      i32.eqz
      br_if 0 (;@1;)
      i32.const 1879
      local.set 19
      i32.const 1367
      local.set 20
      i32.const 475
      local.set 21
      i32.const 1024
      local.set 22
      local.get 19
      local.get 20
      local.get 21
      local.get 22
      call $__assert_fail
      unreachable
    end
    i32.const -1
    local.set 23
    local.get 23
    call $alloc_test_set_limit
    i32.const 0
    local.set 24
    local.get 2
    local.get 24
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 25
        i32.const 65
        local.set 26
        local.get 25
        local.get 26
        i32.lt_u
        local.set 27
        i32.const 1
        local.set 28
        local.get 27
        local.get 28
        i32.and
        local.set 29
        local.get 29
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=12
        local.set 30
        local.get 2
        i32.load offset=12
        local.set 31
        i32.const 16
        local.set 32
        local.get 2
        local.get 32
        i32.add
        local.set 33
        local.get 33
        local.set 34
        i32.const 2
        local.set 35
        local.get 31
        local.get 35
        i32.shl
        local.set 36
        local.get 34
        local.get 36
        i32.add
        local.set 37
        local.get 37
        local.get 30
        i32.store
        local.get 2
        i32.load offset=284
        local.set 38
        local.get 2
        i32.load offset=12
        local.set 39
        i32.const 16
        local.set 40
        local.get 2
        local.get 40
        i32.add
        local.set 41
        local.get 41
        local.set 42
        i32.const 2
        local.set 43
        local.get 39
        local.get 43
        i32.shl
        local.set 44
        local.get 42
        local.get 44
        i32.add
        local.set 45
        local.get 38
        local.get 45
        call $set_insert
        local.set 46
        block  ;; label = @3
          local.get 46
          br_if 0 (;@3;)
          i32.const 2235
          local.set 47
          i32.const 1367
          local.set 48
          i32.const 486
          local.set 49
          i32.const 1024
          local.set 50
          local.get 47
          local.get 48
          local.get 49
          local.get 50
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=284
        local.set 51
        local.get 51
        call $set_num_entries
        local.set 52
        local.get 2
        i32.load offset=12
        local.set 53
        i32.const 1
        local.set 54
        local.get 53
        local.get 54
        i32.add
        local.set 55
        local.get 52
        local.get 55
        i32.eq
        local.set 56
        i32.const 1
        local.set 57
        local.get 56
        local.get 57
        i32.and
        local.set 58
        block  ;; label = @3
          local.get 58
          br_if 0 (;@3;)
          i32.const 1724
          local.set 59
          i32.const 1367
          local.set 60
          i32.const 487
          local.set 61
          i32.const 1024
          local.set 62
          local.get 59
          local.get 60
          local.get 61
          local.get 62
          call $__assert_fail
          unreachable
        end
        local.get 2
        i32.load offset=12
        local.set 63
        i32.const 1
        local.set 64
        local.get 63
        local.get 64
        i32.add
        local.set 65
        local.get 2
        local.get 65
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=284
    local.set 66
    local.get 66
    call $set_num_entries
    local.set 67
    i32.const 65
    local.set 68
    local.get 67
    local.get 68
    i32.eq
    local.set 69
    i32.const 1
    local.set 70
    local.get 69
    local.get 70
    i32.and
    local.set 71
    block  ;; label = @1
      local.get 71
      br_if 0 (;@1;)
      i32.const 1565
      local.set 72
      i32.const 1367
      local.set 73
      i32.const 490
      local.set 74
      i32.const 1024
      local.set 75
      local.get 72
      local.get 73
      local.get 74
      local.get 75
      call $__assert_fail
      unreachable
    end
    i32.const 0
    local.set 76
    local.get 76
    call $alloc_test_set_limit
    i32.const 65
    local.set 77
    local.get 2
    local.get 77
    i32.store offset=276
    local.get 2
    i32.load offset=284
    local.set 78
    i32.const 16
    local.set 79
    local.get 2
    local.get 79
    i32.add
    local.set 80
    local.get 80
    local.set 81
    i32.const 260
    local.set 82
    local.get 81
    local.get 82
    i32.add
    local.set 83
    local.get 78
    local.get 83
    call $set_insert
    local.set 84
    block  ;; label = @1
      local.get 84
      i32.eqz
      br_if 0 (;@1;)
      i32.const 1990
      local.set 85
      i32.const 1367
      local.set 86
      i32.const 497
      local.set 87
      i32.const 1024
      local.set 88
      local.get 85
      local.get 86
      local.get 87
      local.get 88
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 89
    local.get 89
    call $set_num_entries
    local.set 90
    i32.const 65
    local.set 91
    local.get 90
    local.get 91
    i32.eq
    local.set 92
    i32.const 1
    local.set 93
    local.get 92
    local.get 93
    i32.and
    local.set 94
    block  ;; label = @1
      local.get 94
      br_if 0 (;@1;)
      i32.const 1565
      local.set 95
      i32.const 1367
      local.set 96
      i32.const 498
      local.set 97
      i32.const 1024
      local.set 98
      local.get 95
      local.get 96
      local.get 97
      local.get 98
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=284
    local.set 99
    local.get 99
    call $set_free
    i32.const 288
    local.set 100
    local.get 2
    local.get 100
    i32.add
    local.set 101
    local.get 101
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_slist_iterate_bad_remove,,"Inserts an element at the beginning of a collection.
Shifts existing elements forward and increments the length.",null,"void test_slist_iterate_bad_remove(void)
{
	SListEntry *list;
	SListIterator iter;
	int values[49];
	int i;
	int *val;

	/* Create a list with 49 entries */
	list = NULL;

	for (i = 0; i < 49; ++i) {
		values[i] = i;
		slist_prepend(&list, &values[i]);
	}

	/* Iterate over the list, removing each element in turn.  We
	 * use an odd number of list elements so that the first and
	 * last entries are removed. */
	slist_iterate(&list, &iter);

	while (slist_iter_has_more(&iter)) {
		val = slist_iter_next(&iter);

		/* Remove all the even numbers. Check that slist_iter_remove
		 * can cope with the fact that the current element has
		 * already been removed. */
		if ((*val % 2) == 0) {
			assert(slist_remove_data(&list, int_equal, val) != 0);
			slist_iter_remove(&iter);
		}
	}

	slist_free(list);
}","(func $test_slist_iterate_bad_remove (type 6)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 224
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 0
    local.set 3
    local.get 2
    local.get 3
    i32.store offset=220
    i32.const 0
    local.set 4
    local.get 2
    local.get 4
    i32.store offset=12
    block  ;; label = @1
      loop  ;; label = @2
        local.get 2
        i32.load offset=12
        local.set 5
        i32.const 49
        local.set 6
        local.get 5
        local.get 6
        i32.lt_s
        local.set 7
        i32.const 1
        local.set 8
        local.get 7
        local.get 8
        i32.and
        local.set 9
        local.get 9
        i32.eqz
        br_if 1 (;@1;)
        local.get 2
        i32.load offset=12
        local.set 10
        local.get 2
        i32.load offset=12
        local.set 11
        i32.const 16
        local.set 12
        local.get 2
        local.get 12
        i32.add
        local.set 13
        local.get 13
        local.set 14
        i32.const 2
        local.set 15
        local.get 11
        local.get 15
        i32.shl
        local.set 16
        local.get 14
        local.get 16
        i32.add
        local.set 17
        local.get 17
        local.get 10
        i32.store
        local.get 2
        i32.load offset=12
        local.set 18
        i32.const 16
        local.set 19
        local.get 2
        local.get 19
        i32.add
        local.set 20
        local.get 20
        local.set 21
        i32.const 2
        local.set 22
        local.get 18
        local.get 22
        i32.shl
        local.set 23
        local.get 21
        local.get 23
        i32.add
        local.set 24
        i32.const 220
        local.set 25
        local.get 2
        local.get 25
        i32.add
        local.set 26
        local.get 26
        local.set 27
        local.get 27
        local.get 24
        call $slist_prepend
        drop
        local.get 2
        i32.load offset=12
        local.set 28
        i32.const 1
        local.set 29
        local.get 28
        local.get 29
        i32.add
        local.set 30
        local.get 2
        local.get 30
        i32.store offset=12
        br 0 (;@2;)
      end
    end
    i32.const 220
    local.set 31
    local.get 2
    local.get 31
    i32.add
    local.set 32
    local.get 32
    local.set 33
    i32.const 212
    local.set 34
    local.get 2
    local.get 34
    i32.add
    local.set 35
    local.get 35
    local.set 36
    local.get 33
    local.get 36
    call $slist_iterate
    block  ;; label = @1
      loop  ;; label = @2
        i32.const 212
        local.set 37
        local.get 2
        local.get 37
        i32.add
        local.set 38
        local.get 38
        local.set 39
        local.get 39
        call $slist_iter_has_more
        local.set 40
        local.get 40
        i32.eqz
        br_if 1 (;@1;)
        i32.const 212
        local.set 41
        local.get 2
        local.get 41
        i32.add
        local.set 42
        local.get 42
        local.set 43
        local.get 43
        call $slist_iter_next
        local.set 44
        local.get 2
        local.get 44
        i32.store offset=8
        local.get 2
        i32.load offset=8
        local.set 45
        local.get 45
        i32.load
        local.set 46
        i32.const 2
        local.set 47
        local.get 46
        local.get 47
        i32.rem_s
        local.set 48
        block  ;; label = @3
          local.get 48
          br_if 0 (;@3;)
          local.get 2
          i32.load offset=8
          local.set 49
          i32.const 220
          local.set 50
          local.get 2
          local.get 50
          i32.add
          local.set 51
          local.get 51
          local.set 52
          i32.const 1
          local.set 53
          local.get 52
          local.get 53
          local.get 49
          call $slist_remove_data
          local.set 54
          block  ;; label = @4
            local.get 54
            br_if 0 (;@4;)
            i32.const 3269
            local.set 55
            i32.const 1286
            local.set 56
            i32.const 466
            local.set 57
            i32.const 1200
            local.set 58
            local.get 55
            local.get 56
            local.get 57
            local.get 58
            call $__assert_fail
            unreachable
          end
          i32.const 212
          local.set 59
          local.get 2
          local.get 59
          i32.add
          local.set 60
          local.get 60
          local.set 61
          local.get 61
          call $slist_iter_remove
        end
        br 0 (;@2;)
      end
    end
    local.get 2
    i32.load offset=220
    local.set 62
    local.get 62
    call $slist_free
    i32.const 224
    local.set 63
    local.get 2
    local.get 63
    i32.add
    local.set 64
    local.get 64
    global.set $__stack_pointer
    return)"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
test_trie_negative_keys,,"Inserts an element into a collection at a specified position.
Shifts existing elements as needed and updates size/metadata.",null,"static void test_trie_negative_keys(void)
{
	char my_key[] = {'a', 'b', 'c', -50, -20, '\0'};
	Trie *trie;
	void *value;

	trie = trie_new();

	assert(trie_insert(trie, my_key, ""hello world"") != 0);

	value = trie_lookup(trie, my_key);

	assert(!strcmp(value, ""hello world""));

	assert(trie_remove(trie, my_key) != 0);
	assert(trie_remove(trie, my_key) == 0);
	assert(trie_lookup(trie, my_key) == NULL);

	trie_free(trie);
}","(func $test_trie_negative_keys (type 7)
    (local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 0
    i32.const 16
    local.set 1
    local.get 0
    local.get 1
    i32.sub
    local.set 2
    local.get 2
    global.set $__stack_pointer
    i32.const 0
    local.set 3
    local.get 3
    i32.load16_u offset=1028 align=1
    local.set 4
    i32.const 12
    local.set 5
    local.get 2
    local.get 5
    i32.add
    local.set 6
    local.get 6
    local.get 4
    i32.store16
    local.get 3
    i32.load offset=1024 align=1
    local.set 7
    local.get 2
    local.get 7
    i32.store offset=8
    call $trie_new
    local.set 8
    local.get 2
    local.get 8
    i32.store offset=4
    local.get 2
    i32.load offset=4
    local.set 9
    i32.const 8
    local.set 10
    local.get 2
    local.get 10
    i32.add
    local.set 11
    local.get 11
    local.set 12
    i32.const 1430
    local.set 13
    local.get 9
    local.get 12
    local.get 13
    call $trie_insert
    local.set 14
    block  ;; label = @1
      local.get 14
      br_if 0 (;@1;)
      i32.const 3145
      local.set 15
      i32.const 1505
      local.set 16
      i32.const 253
      local.set 17
      i32.const 1149
      local.set 18
      local.get 15
      local.get 16
      local.get 17
      local.get 18
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=4
    local.set 19
    i32.const 8
    local.set 20
    local.get 2
    local.get 20
    i32.add
    local.set 21
    local.get 21
    local.set 22
    local.get 19
    local.get 22
    call $trie_lookup
    local.set 23
    local.get 2
    local.get 23
    i32.store
    local.get 2
    i32.load
    local.set 24
    i32.const 1430
    local.set 25
    local.get 24
    local.get 25
    call $strcmp
    local.set 26
    block  ;; label = @1
      local.get 26
      i32.eqz
      br_if 0 (;@1;)
      i32.const 3432
      local.set 27
      i32.const 1505
      local.set 28
      i32.const 257
      local.set 29
      i32.const 1149
      local.set 30
      local.get 27
      local.get 28
      local.get 29
      local.get 30
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=4
    local.set 31
    i32.const 8
    local.set 32
    local.get 2
    local.get 32
    i32.add
    local.set 33
    local.get 33
    local.set 34
    local.get 31
    local.get 34
    call $trie_remove
    local.set 35
    block  ;; label = @1
      local.get 35
      br_if 0 (;@1;)
      i32.const 2624
      local.set 36
      i32.const 1505
      local.set 37
      i32.const 259
      local.set 38
      i32.const 1149
      local.set 39
      local.get 36
      local.get 37
      local.get 38
      local.get 39
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=4
    local.set 40
    i32.const 8
    local.set 41
    local.get 2
    local.get 41
    i32.add
    local.set 42
    local.get 42
    local.set 43
    local.get 40
    local.get 43
    call $trie_remove
    local.set 44
    block  ;; label = @1
      local.get 44
      i32.eqz
      br_if 0 (;@1;)
      i32.const 2048
      local.set 45
      i32.const 1505
      local.set 46
      i32.const 260
      local.set 47
      i32.const 1149
      local.set 48
      local.get 45
      local.get 46
      local.get 47
      local.get 48
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=4
    local.set 49
    i32.const 8
    local.set 50
    local.get 2
    local.get 50
    i32.add
    local.set 51
    local.get 51
    local.set 52
    local.get 49
    local.get 52
    call $trie_lookup
    local.set 53
    i32.const 0
    local.set 54
    local.get 53
    local.get 54
    i32.eq
    local.set 55
    i32.const 1
    local.set 56
    local.get 55
    local.get 56
    i32.and
    local.set 57
    block  ;; label = @1
      local.get 57
      br_if 0 (;@1;)
      i32.const 1713
      local.set 58
      i32.const 1505
      local.set 59
      i32.const 261
      local.set 60
      i32.const 1149
      local.set 61
      local.get 58
      local.get 59
      local.get 60
      local.get 61
      call $__assert_fail
      unreachable
    end
    local.get 2
    i32.load offset=4
    local.set 62
    local.get 62
    call $trie_free
    i32.const 16
    local.set 63
    local.get 2
    local.get 63
    i32.add
    local.set 64
    local.get 64
    global.set $__stack_pointer
    return)
  (table (;0;) 12 12 funcref)
  (memory (;0;) 4)
  (global $__stack_pointer (mut i32) (i32.const 209152))
  (global (;1;) i32 (i32.const 3616))
  (global (;2;) i32 (i32.const 43616))
  (global (;3;) i32 (i32.const 3543))
  (global (;4;) i32 (i32.const 3536))
  (global (;5;) i32 (i32.const 3551))
  (global (;6;) i32 (i32.const 3554))
  (global (;7;) i32 (i32.const 1024))
  (global (;8;) i32 (i32.const 143616))
  (global (;9;) i32 (i32.const 143616))
  (global (;10;) i32 (i32.const 209152))
  (global (;11;) i32 (i32.const 1024))
  (global (;12;) i32 (i32.const 209152))
  (global (;13;) i32 (i32.const 262144))
  (global (;14;) i32 (i32.const 0))
  (global (;15;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""generate_trie"" (func $generate_trie))
  (export ""test_array"" (global 1))
  (export ""test_strings"" (global 2))
  (export ""test_trie_new_free"" (func $test_trie_new_free))
  (export ""test_trie_insert"" (func $test_trie_insert))
  (export ""test_trie_lookup"" (func $test_trie_lookup))
  (export ""test_trie_remove"" (func $test_trie_remove))
  (export ""test_trie_replace"" (func $test_trie_replace))
  (export ""test_trie_insert_empty"" (func $test_trie_insert_empty))
  (export ""generate_binary_trie"" (func $generate_binary_trie))
  (export ""bin_key2"" (global 3))
  (export ""bin_key"" (global 4))
  (export ""test_trie_insert_binary"" (func $test_trie_insert_binary))
  (export ""bin_key3"" (global 5))
  (export ""test_trie_insert_out_of_memory"" (func $test_trie_insert_out_of_memory))
  (export ""bin_key4"" (global 6))
  (export ""test_trie_remove_binary"" (func $test_trie_remove_binary))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 7))
  (export ""__data_end"" (global 8))
  (export ""__stack_low"" (global 9))
  (export ""__stack_high"" (global 10))
  (export ""__global_base"" (global 11))
  (export ""__heap_base"" (global 12))
  (export ""__heap_end"" (global 13))
  (export ""__memory_base"" (global 14))
  (export ""__table_base"" (global 15))
  (elem (;0;) (i32.const 1) func $test_trie_new_free $test_trie_insert $test_trie_lookup $test_trie_remove $test_trie_replace $test_trie_insert_empty $test_trie_free_long $test_trie_negative_keys $test_trie_insert_binary $test_trie_insert_out_of_memory $test_trie_remove_binary)
  (data $.rodata (i32.const 1024) ""abc\ce\ec\00test_trie_insert_empty\00test_trie_insert_out_of_memory\00test_trie_insert_binary\00test_trie_remove_binary\00test_trie_insert\00test_trie_negative_keys\00trie_num_entries(trie) == entries\00test_trie_lookup\00hello\00hell\00trie_lookup(trie, \22999\22) == val\00%i\00*val == i\00testing\00trie_lookup(trie, \22\22) == buf\00asfasf\00test_trie_remove\00test value\00there\00generate_binary_trie\00generate_trie\00test_trie_new_free\00test_trie_replace\00hello world\00hi world\00goodbye world\00alloc_test_get_allocated() == allocated\00../files/src/test-trie.c\00a\00entries == NUM_TEST_VALUES\00trie_num_entries(trie) == NUM_TEST_VALUES\00trie_lookup(trie, \22000000000000000\22) == TRIE_NULL\00trie_lookup(trie, \22\22) == TRIE_NULL\00value == NULL\00trie == NULL\00trie_lookup(trie, my_key) == NULL\00trie_lookup_binary(trie, bin_key, sizeof(bin_key)) == NULL\00trie_lookup_binary(trie, bin_key4, sizeof(bin_key4)) == NULL\00trie_lookup_binary(trie, bin_key2, sizeof(bin_key2)) == NULL\00trie != NULL\00trie_lookup_binary(trie, bin_key, sizeof(bin_key)) != NULL\00999\00trie_num_entries(trie) == 2\00000000000000000\00trie_remove(trie, my_key) == 0\00trie_num_entries(trie) == 0\00trie_insert_binary(trie, bin_key3, sizeof(bin_key3), NULL) == 0\00trie_insert(trie, \22hello world\22, NULL) == 0\00trie_lookup_binary(trie, bin_key4, sizeof(bin_key4)) == 0\00trie_remove_binary(trie, bin_key4, sizeof(bin_key4)) == 0\00trie_remove_binary(trie, bin_key3, sizeof(bin_key3)) == 0\00trie_insert_binary(trie, bin_key4, sizeof(bin_key4), \22test value\22) == 0\00trie_insert(trie, \22hello world\22, \22test value\22) == 0\00trie_insert(trie, \22a\22, \22test value\22) == 0\00trie_remove(trie, \22000000000000000\22) == 0\00trie_remove(trie, \22\22) == 0\00trie_remove(trie, my_key) != 0\00trie_insert(trie, \22999\22, val) != 0\00trie_remove(trie, buf) != 0\00trie_insert(trie, \22\22, buf) != 0\00trie_num_entries(trie) != 0\00trie_insert(trie, test_strings[i], &test_array[i]) != 0\00trie_remove_binary(trie, bin_key, sizeof(bin_key)) != 0\00trie_remove_binary(trie, bin_key2, sizeof(bin_key2)) != 0\00trie_remove(trie, \22hello\22) != 0\00trie_insert(trie, \22hell\22, \22testing\22) != 0\00trie_insert(trie, \22testing\22, \22testing\22) != 0\00trie_insert(trie, \22\22, \22asfasf\22) != 0\00trie_insert(trie, \22hello\22, \22there\22) != 0\00trie_insert(trie, my_key, \22hello world\22) != 0\00trie_insert_binary(trie, bin_key, sizeof(bin_key), \22hello world\22) != 0\00trie_insert_binary(trie, bin_key, sizeof(bin_key), \22hi world\22) != 0\00trie_insert_binary(trie, bin_key2, sizeof(bin_key2), \22goodbye world\22) != 0\00trie_remove(trie, \22\22) != 0\00!strcmp(value, \22hello world\22)\00!strcmp(value, \22hi world\22)\00!strcmp(value, \22goodbye world\22)\00"")
  (data $.data (i32.const 3536) ""abc\00\01\02\ffabc\00\01\02\ff\00abcz\00zz\00\00\00\00\00\00\00\00\00\00\01\00\00\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\08\00\00\00\09\00\00\00\0a\00\00\00\0b\00\00\00\00\00\00\00""))"
main,"int argc, char *argv[]","Performs the operation implemented in the C code for this function.
Handles memory and control flow according to the function logic.",0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}","(func $main (type 1) (param i32 i32) (result i32)
    (local i32 i32 i32 i32 i32 i32 i32 i32)
    global.get $__stack_pointer
    local.set 2
    i32.const 16
    local.set 3
    local.get 2
    local.get 3
    i32.sub
    local.set 4
    local.get 4
    global.set $__stack_pointer
    i32.const 0
    local.set 5
    local.get 4
    local.get 5
    i32.store offset=12
    local.get 4
    local.get 0
    i32.store offset=8
    local.get 4
    local.get 1
    i32.store offset=4
    i32.const 3040
    local.set 6
    local.get 6
    call $run_tests
    i32.const 0
    local.set 7
    i32.const 16
    local.set 8
    local.get 4
    local.get 8
    i32.add
    local.set 9
    local.get 9
    global.set $__stack_pointer
    local.get 7
    return)
  (table (;0;) 8 8 funcref)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 68608))
  (global (;1;) i32 (i32.const 1024))
  (global (;2;) i32 (i32.const 3068))
  (global (;3;) i32 (i32.const 3072))
  (global (;4;) i32 (i32.const 68608))
  (global (;5;) i32 (i32.const 1024))
  (global (;6;) i32 (i32.const 68608))
  (global (;7;) i32 (i32.const 131072))
  (global (;8;) i32 (i32.const 0))
  (global (;9;) i32 (i32.const 1))
  (export ""memory"" (memory 0))
  (export ""__wasm_call_ctors"" (func $__wasm_call_ctors))
  (export ""check_sorted"" (func $check_sorted))
  (export ""generate_sortedarray"" (func $generate_sortedarray))
  (export ""test_sortedarray_new_free"" (func $test_sortedarray_new_free))
  (export ""test_sortedarray_insert"" (func $test_sortedarray_insert))
  (export ""test_sortedarray_get"" (func $test_sortedarray_get))
  (export ""test_sortedarray_remove"" (func $test_sortedarray_remove))
  (export ""test_sortedarray_index_of"" (func $test_sortedarray_index_of))
  (export ""test_sortedarray_clear"" (func $test_sortedarray_clear))
  (export ""__main_argc_argv"" (func $main))
  (export ""__indirect_function_table"" (table 0))
  (export ""__dso_handle"" (global 1))
  (export ""__data_end"" (global 2))
  (export ""__stack_low"" (global 3))
  (export ""__stack_high"" (global 4))
  (export ""__global_base"" (global 5))
  (export ""__heap_base"" (global 6))
  (export ""__heap_end"" (global 7))
  (export ""__memory_base"" (global 8))
  (export ""__table_base"" (global 9))
  (elem (;0;) (i32.const 1) func $int_compare $test_sortedarray_new_free $test_sortedarray_insert $test_sortedarray_get $test_sortedarray_remove $test_sortedarray_index_of $test_sortedarray_clear)
  (data $.rodata (i32.const 1024) ""test_sortedarray_insert\00test_sortedarray_get\00test_sortedarray_clear\00test_sortedarray_index_of\00test_sortedarray_remove\00test_sortedarray_new_free\00check_sorted\00../files/src/test-sortedarray.c\00*got == sorted_test_values[check_idx]\00*got == sorted_test_values[i]\00sorted_test_values[got_idx] == sorted_test_values[i]\00sortedarray_length(sa) == NUM_TEST_VALUES - 1 - REMOVE_IDX_2_LEN - REMOVE_IDX_3_REAL_LEN\00sa == NULL\00sortedarray_new(0, NULL) == NULL\00sortedarray_get(sa, 999999) == NULL\00sortedarray_get(NULL, 0) == NULL\00sortedarray_get(sa, sortedarray_length(sa)) == NULL\00got != NULL\00sa != NULL\00sortedarray_index_of(sa, &test_index) == -1\00sortedarray_index_of(NULL, NULL) == -1\00sortedarray_length(sa) == 0\00sortedarray_insert(NULL, NULL) == 0\00sortedarray_remove(sa, 999999) == 0\00sortedarray_remove_range(sa, 999999, 44) == 0\00sortedarray_remove_range(sa, sortedarray_length(sa), 3) == 0\00sortedarray_remove(NULL, 0) == 0\00sortedarray_remove(sa, sortedarray_length(sa)) == 0\00int_compare(sortedarray_get(sa, i - 1), sortedarray_get(sa, i)) <= 0\00sortedarray_remove_range(sa, REMOVE_IDX_3, REMOVE_IDX_3_LEN) != 0\00sortedarray_remove_range(sa, REMOVE_IDX_2, REMOVE_IDX_2_LEN) != 0\00sortedarray_remove(sa, REMOVE_IDX_1) != 0\00"")
  (data $.data (i32.const 2240) ""|\c0\01\00lx\04\00\94;\00\00\bf\d9\04\00\1e\1d\0d\00{d\0e\00i\a6\02\00\ec\c7\06\00\c2k\04\00\e7\ed\00\00\c7\c7\0a\00\8fL\06\00\d0\ca\ff\ffA\15\07\00$\0f\0e\00zE\06\00\c7\d0\01\00\88\de\0d\00:\0b\0d\00\1f}\03\00F\ac\02\00\ac\e7\0e\00\81\b3\0e\00\a4\99\00\00\85\cf\0b\00\f0\fb\08\00\d7[\00\00\8c\8f\05\00\01v\0c\00\81\03\01\00\a3\e9\0d\00\ac\cf\0b\00\f4\10\00\002J\ff\ffoJ\0b\00\95\ed\05\00\ed\d8\0a\00\efy\0c\00\97\e2\08\00c+\0f\00\f2N\0b\00\f7h\0c\00O\dc\02\00a>\02\00\a5<\0e\00\a5<\0e\00\a5<\0e\00\e1}\0b\004*\07\00\8fw\0d\00\ee\8a\0e\00>\8a\02\00\f7\9b\ff\ff\8e\b3\0b\008\0b\03\00\0b\1c\04\00\cb\b7\09\00\91\c2\00\00R\aa\09\00\b8W\02\00\9c\f7\04\00M>\00\00\02d\06\00\c0B\08\00\e2\7f\0e\00\e2\95\0c\00c\08\01\00^\e7\08\00ie\01\00D\b3\0c\00\a2\07\09\00\88\84\04\00\13y\01\00\cd=\0d\00\9f\ef\01\00\f7\ef\0a\00\0eu\0a\00\db\9b\0c\00aW\0a\00\cd\93\07\00\87\e5\ff\ffl.\0a\00\c9\d0\06\00U\8c\08\00\9d\1b\0b\00q[\0a\00\aa\88\06\00)\9e\0b\00\f1\fc\01\00\f7\0e\0b\00\b8\96\04\00B3\0b\00\e3\86\07\00\e8\bf\0b\00\926\07\000\e3\01\00\ef\98\04\00\db\ce\07\00\96\d9\05\00\aaQ\02\002J\ff\ff\f7\9b\ff\ff\d0\ca\ff\ff\87\e5\ff\ff\f4\10\00\00\94;\00\00M>\00\00\d7[\00\00\a4\99\00\00\91\c2\00\00\e7\ed\00\00\81\03\01\00c\08\01\00ie\01\00\13y\01\00|\c0\01\00\c7\d0\01\000\e3\01\00\9f\ef\01\00\f1\fc\01\00a>\02\00\aaQ\02\00\b8W\02\00>\8a\02\00i\a6\02\00F\ac\02\00O\dc\02\008\0b\03\00\1f}\03\00\0b\1c\04\00\c2k\04\00lx\04\00\88\84\04\00\b8\96\04\00\ef\98\04\00\bf\d9\04\00\9c\f7\04\00\8c\8f\05\00\96\d9\05\00\95\ed\05\00zE\06\00\8fL\06\00\02d\06\00\aa\88\06\00\ec\c7\06\00\c9\d0\06\00A\15\07\004*\07\00\926\07\00\e3\86\07\00\cd\93\07\00\db\ce\07\00\c0B\08\00U\8c\08\00\97\e2\08\00^\e7\08\00\f0\fb\08\00\a2\07\09\00R\aa\09\00\cb\b7\09\00l.\0a\00aW\0a\00q[\0a\00\0eu\0a\00\c7\c7\0a\00\ed\d8\0a\00\f7\ef\0a\00\f7\0e\0b\00\9d\1b\0b\00B3\0b\00oJ\0b\00\f2N\0b\00\e1}\0b\00)\9e\0b\00\8e\b3\0b\00\e8\bf\0b\00\85\cf\0b\00\ac\cf\0b\00\f7h\0c\00\01v\0c\00\efy\0c\00\e2\95\0c\00\db\9b\0c\00D\b3\0c\00:\0b\0d\00\1e\1d\0d\00\cd=\0d\00\8fw\0d\00\88\de\0d\00\a3\e9\0d\00$\0f\0e\00\a5<\0e\00\a5<\0e\00\a5<\0e\00{d\0e\00\e2\7f\0e\00\ee\8a\0e\00\81\b3\0e\00\ac\e7\0e\00c+\0f\00\02\00\00\00\03\00\00\00\04\00\00\00\05\00\00\00\06\00\00\00\07\00\00\00\00\00\00\00""))"
