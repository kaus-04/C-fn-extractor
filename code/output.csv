fn_name,parameters,description,return_statement,c_implementation
arraylist_free,ArrayList *arraylist,,null,"
void arraylist_free(ArrayList *arraylist)
{
	/* Do not free if a NULL pointer is passed */
	if (arraylist != NULL) {
		free(arraylist->data);
		free(arraylist);
	}
}"
arraylist_enlarge,ArrayList *arraylist,,0 | 1,"
static int arraylist_enlarge(ArrayList *arraylist)
{
	ArrayListValue *data;
	unsigned int newsize;

	/* Double the allocated size */
	newsize = arraylist->_alloced * 2;

	/* Reallocate the array to the new size */
	data = realloc(arraylist->data, sizeof(ArrayListValue) * newsize);

	if (data == NULL) {
		return 0;
	} else {
		arraylist->data = data;
		arraylist->_alloced = newsize;

		return 1;
	}
}"
arraylist_insert,"ArrayList *arraylist, unsigned int index, ArrayListValue data",,0 | 1,"
int arraylist_insert(ArrayList *arraylist, unsigned int index,
                     ArrayListValue data)
{
	/* Sanity check the index */
	if (index > arraylist->length) {
		return 0;
	}

	/* Increase the size if necessary */
	if (arraylist->length + 1 > arraylist->_alloced) {
		if (!arraylist_enlarge(arraylist)) {
			return 0;
		}
	}

	/* Move the contents of the array forward from the index
	 * onwards */
	memmove(&arraylist->data[index + 1], &arraylist->data[index],
	        (arraylist->length - index) * sizeof(ArrayListValue));

	/* Insert the new entry at the index */
	arraylist->data[index] = data;
	++arraylist->length;

	return 1;
}"
arraylist_append,"ArrayList *arraylist, ArrayListValue data",,"arraylist_insert(arraylist, arraylist->length, data)","
int arraylist_append(ArrayList *arraylist, ArrayListValue data)
{
	return arraylist_insert(arraylist, arraylist->length, data);
}"
arraylist_prepend,"ArrayList *arraylist, ArrayListValue data",,"arraylist_insert(arraylist, 0, data)","
int arraylist_prepend(ArrayList *arraylist, ArrayListValue data)
{
	return arraylist_insert(arraylist, 0, data);
}"
arraylist_remove_range,"ArrayList *arraylist, unsigned int index, unsigned int length",,null,"
void arraylist_remove_range(ArrayList *arraylist, unsigned int index,
                            unsigned int length)
{
	/* Check this is a valid range */
	if (index > arraylist->length || index + length > arraylist->length) {
		return;
	}

	/* Move back the entries following the range to be removed */
	memmove(&arraylist->data[index], &arraylist->data[index + length],
	        (arraylist->length - (index + length)) *
	            sizeof(ArrayListValue));

	/* Decrease the counter */
	arraylist->length -= length;
}"
arraylist_remove,"ArrayList *arraylist, unsigned int index",Decrease the counter,null,"
void arraylist_remove(ArrayList *arraylist, unsigned int index)
{
	arraylist_remove_range(arraylist, index, 1);
}"
arraylist_index_of,"ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data",,(int) i | -1,"
int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback,
                       ArrayListValue data)
{
	unsigned int i;

	for (i = 0; i < arraylist->length; ++i) {
		if (callback(arraylist->data[i], data) != 0) {
			return (int) i;
		}
	}

	return -1;
}"
arraylist_clear,ArrayList *arraylist,,null,"
void arraylist_clear(ArrayList *arraylist)
{
	/* To clear the list, simply set the length to zero */
	arraylist->length = 0;
}"
arraylist_sort_internal,"ArrayListValue *list_data, unsigned int list_length, ArrayListCompareFunc compare_func","To clear the list, simply set the length to zero",null,"
static void arraylist_sort_internal(ArrayListValue *list_data,
                                    unsigned int list_length,
                                    ArrayListCompareFunc compare_func)
{
	ArrayListValue pivot;
	ArrayListValue tmp;
	unsigned int i;
	unsigned int list1_length;
	unsigned int list2_length;

	/* If less than two items, it is always sorted. */
	if (list_length <= 1) {
		return;
	}

	/* Take the last item as the pivot. */
	pivot = list_data[list_length - 1];

	/* Divide the list into two lists:
	 *
	 * List 1 contains data less than the pivot.
	 * List 2 contains data more than the pivot.
	 *
	 * As the lists are build up, they are stored sequentially after
	 * each other, ie. list_data[list1_length-1] is the last item
	 * in list 1, list_data[list1_length] is the first item in
	 * list 2.
	 */
	list1_length = 0;

	for (i = 0; i < list_length - 1; ++i) {

		if (compare_func(list_data[i], pivot) < 0) {

			/* This should be in list 1.  Therefore it is in the
			 * wrong position. Swap the data immediately following
			 * the last item in list 1 with this data. */
			tmp = list_data[i];
			list_data[i] = list_data[list1_length];
			list_data[list1_length] = tmp;

			++list1_length;

		} else {
			/* This should be in list 2.  This is already in the
			 * right position. */
		}
	}

	/* The length of list 2 can be calculated. */
	list2_length = list_length - list1_length - 1;

	/* list_data[0..list1_length-1] now contains all items which are
	 * before the pivot.
	 * list_data[list1_length..list_length-2] contains all items after
	 * or equal to the pivot.
	 * Move the pivot into place, by swapping it with the item
	 * immediately following the end of list 1. */
	list_data[list_length - 1] = list_data[list1_length];
	list_data[list1_length] = pivot;

	/* Recursively sort the sublists. */
	arraylist_sort_internal(list_data, list1_length, compare_func);

	arraylist_sort_internal(&list_data[list1_length + 1], list2_length,
	                        compare_func);
}"
arraylist_sort,"ArrayList *arraylist, ArrayListCompareFunc compare_func",,null,"
void arraylist_sort(ArrayList *arraylist, ArrayListCompareFunc compare_func)
{
	/* Perform the recursive sort */
	arraylist_sort_internal(arraylist->data, arraylist->length,
	                        compare_func);
}"
avl_tree_update_height,AVLTreeNode *node,,null,"static void avl_tree_update_height(AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	int left_height, right_height;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];
	left_height = avl_tree_subtree_height(left_subtree);
	right_height = avl_tree_subtree_height(right_subtree);

	if (left_height > right_height) {
		node->height = left_height + 1;
	} else {
		node->height = right_height + 1;
	}
}"
avl_tree_node_replace,"AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2",,new_root | node,"static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1,
                                  AVLTreeNode *node2)
{
	int side;

	/* Set the node's parent pointer. */
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}

	/* The root node? */
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = avl_tree_node_parent_side(node1);
		node1->parent->children[side] = node2;

		avl_tree_update_height(node1->parent);
	}
}

/* Rotate a section of the tree.  'node' is the node at the top
 * of the section to be rotated.  'direction' is the direction in
 * which to rotate the tree: left or right, as shown in the following
 * diagram:
 *
 * Left rotation:              Right rotation:
 *
 *      B                             D
 *     / \                           / \
 *    A   D                         B   E
 *       / \                       / \
 *      C   E                     A   C

 * is rotated to:              is rotated to:
 *
 *        D                           B
 *       / \                         / \
 *      B   E                       A   D
 *     / \                             / \
 *    A   C                           C   E
 */
static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node,
                                    AVLTreeNodeSide direction)
{
	AVLTreeNode *new_root;

	/* The child of this node will take its place:
	   for a left rotation, it is the right child, and vice versa. */
	new_root = node->children[1 - direction];

	/* Make new_root the root, update parent pointers. */
	avl_tree_node_replace(tree, node, new_root);

	/* Rearrange pointers */
	node->children[1 - direction] = new_root->children[direction];
	new_root->children[direction] = node;

	/* Update parent references */
	node->parent = new_root;

	if (node->children[1 - direction] != NULL) {
		node->children[1 - direction]->parent = node;
	}

	/* Update heights of the affected nodes */
	avl_tree_update_height(new_root);
	avl_tree_update_height(node);

	return new_root;
}

/* Balance a particular tree node.
 *
 * Returns the root node of the new subtree which is replacing the
 * old one. */
static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	AVLTreeNode *child;
	int diff;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];

	/* Check the heights of the child trees.  If there is an unbalance
	 * (difference between left and right > 2), then rotate nodes
	 * around to fix it */
	diff = avl_tree_subtree_height(right_subtree) -
	       avl_tree_subtree_height(left_subtree);

	if (diff >= 2) {

		/* Biased toward the right side too much. */
		child = right_subtree;

		if (avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_RIGHT]) <
		    avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_LEFT])) {

			/* If the right child is biased toward the left
			 * side, it must be rotated right first (double
			 * rotation) */
			avl_tree_rotate(tree, right_subtree,
			                AVL_TREE_NODE_RIGHT);
		}

		/* Perform a left rotation.  After this, the right child will
		 * take the place of this node.  Update the node pointer. */
		node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);

	} else if (diff <= -2) {

		/* Biased toward the left side too much. */
		child = node->children[AVL_TREE_NODE_LEFT];

		if (avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_LEFT]) <
		    avl_tree_subtree_height(
		        child->children[AVL_TREE_NODE_RIGHT])) {

			/* If the left child is biased toward the right
			 * side, it must be rotated right left (double
			 * rotation) */
			avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);
		}

		/* Perform a right rotation.  After this, the left child will
		 * take the place of this node.  Update the node pointer. */
		node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);
	}

	/* Update the height of this node */
	avl_tree_update_height(node);

	return node;
}

/* Walk up the tree from the given node, performing any needed rotations */
static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *rover;

	rover = node;

	while (rover != NULL) {

		/* Balance this node if necessary */
		rover = avl_tree_node_balance(tree, rover);

		/* Go to this node's parent */
		rover = rover->parent;
	}"
avl_tree_balance_to_root,"AVLTree *tree, AVLTreeNode *node",,"NULL | new_node | result | 0 | 1 | this node */
			return node | avl_tree_null_value | node->value | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes | array","static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *rover;

	rover = node;

	while (rover != NULL) {

		/* Balance this node if necessary */
		rover = avl_tree_node_balance(tree, rover);

		/* Go to this node's parent */
		rover = rover->parent;
	}
}

AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)
{
	AVLTreeNode **rover;
	AVLTreeNode *new_node;
	AVLTreeNode *previous_node;

	/* Walk down the tree until we reach a NULL pointer */
	rover = &tree->root_node;
	previous_node = NULL;

	while (*rover != NULL) {
		previous_node = *rover;
		if (tree->compare_func(key, (*rover)->key) < 0) {
			rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);
		} else {
			rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);
		}
	}

	/* Create a new node.  Use the last node visited as the parent link. */
	new_node = (AVLTreeNode *) malloc(sizeof(AVLTreeNode));

	if (new_node == NULL) {
		return NULL;
	}

	new_node->children[AVL_TREE_NODE_LEFT] = NULL;
	new_node->children[AVL_TREE_NODE_RIGHT] = NULL;
	new_node->parent = previous_node;
	new_node->key = key;
	new_node->value = value;
	new_node->height = 1;

	/* Insert at the NULL pointer that was reached */
	*rover = new_node;

	/* Rebalance the tree, starting from the previous node. */
	avl_tree_balance_to_root(tree, previous_node);

	/* Keep track of the number of entries */
	++tree->num_nodes;

	return new_node;
}

/* Find the nearest node to the given node, to replace it.
 * The node returned is unlinked from the tree.
 * Returns NULL if the node has no children. */
static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree,
                                                  AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	AVLTreeNode *result;
	AVLTreeNode *child;
	int left_height, right_height;
	int side;

	left_subtree = node->children[AVL_TREE_NODE_LEFT];
	right_subtree = node->children[AVL_TREE_NODE_RIGHT];

	/* No children? */
	if (left_subtree == NULL && right_subtree == NULL) {
		return NULL;
	}

	/* Pick a node from whichever subtree is taller.  This helps to
	 * keep the tree balanced. */
	left_height = avl_tree_subtree_height(left_subtree);
	right_height = avl_tree_subtree_height(right_subtree);

	if (left_height < right_height) {
		side = AVL_TREE_NODE_RIGHT;
	} else {
		side = AVL_TREE_NODE_LEFT;
	}

	/* Search down the tree, back towards the center. */
	result = node->children[side];

	while (result->children[1 - side] != NULL) {
		result = result->children[1 - side];
	}

	/* Unlink the result node, and hook in its remaining child
	 * (if it has one) to replace it. */
	child = result->children[side];
	avl_tree_node_replace(tree, result, child);

	/* Update the subtree height for the result node's old parent. */
	avl_tree_update_height(result->parent);

	return result;
}

/* Remove a node from a tree */
void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *swap_node;
	AVLTreeNode *balance_startpoint;
	int i;

	/* The node to be removed must be swapped with an ""adjacent""
	 * node, ie. one which has the closest key to this one. Find
	 * a node to swap with. */
	swap_node = avl_tree_node_get_replacement(tree, node);

	if (swap_node == NULL) {

		/* This is a leaf node and has no children, therefore
		 * it can be immediately removed. */
		/* Unlink this node from its parent. */
		avl_tree_node_replace(tree, node, NULL);

		/* Start rebalancing from the parent of the original node */
		balance_startpoint = node->parent;

	} else {
		/* We will start rebalancing from the old parent of the
		 * swap node.  Sometimes, the old parent is the node we
		 * are removing, in which case we must start rebalancing
		 * from the swap node. */
		if (swap_node->parent == node) {
			balance_startpoint = swap_node;
		} else {
			balance_startpoint = swap_node->parent;
		}

		/* Copy references in the node into the swap node */
		for (i = 0; i < 2; ++i) {
			swap_node->children[i] = node->children[i];

			if (swap_node->children[i] != NULL) {
				swap_node->children[i]->parent = swap_node;
			}
		}

		swap_node->height = node->height;

		/* Link the parent's reference to this node */
		avl_tree_node_replace(tree, node, swap_node);
	}

	/* Destroy the node */
	free(node);

	/* Keep track of the number of nodes */
	--tree->num_nodes;

	/* Rebalance the tree */
	avl_tree_balance_to_root(tree, balance_startpoint);
}

/* Remove a node by key */
int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}

AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;
	int diff;

	/* Search down the tree and attempt to find the node which
	 * has the specified key */
	node = tree->root_node;

	while (node != NULL) {

		diff = tree->compare_func(key, node->key);

		if (diff == 0) {

			/* Keys are equal: return this node */
			return node;

		} else if (diff < 0) {
			node = node->children[AVL_TREE_NODE_LEFT];
		} else {
			node = node->children[AVL_TREE_NODE_RIGHT];
		}
	}

	/* Not found */
	return NULL;
}

AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		return avl_tree_null_value;
	} else {
		return node->value;
	}
}

AVLTreeNode *avl_tree_root_node(AVLTree *tree)
{
	return tree->root_node;
}

AVLTreeKey avl_tree_node_key(AVLTreeNode *node)
{
	return node->key;
}

AVLTreeValue avl_tree_node_value(AVLTreeNode *node)
{
	return node->value;
}

AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)
{
	if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)
{
	return node->parent;
}

unsigned int avl_tree_num_entries(AVLTree *tree)
{
	return tree->num_nodes;
}

static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}

AVLTreeKey *avl_tree_to_array(AVLTree *tree)
{
	AVLTreeKey *array;
	int index;

	/* Allocate the array */
	array = malloc(sizeof(AVLTreeKey) * tree->num_nodes);

	if (array == NULL) {
		return NULL;
	}

	index = 0;

	/* Add all keys */
	avl_tree_to_array_add_subtree(tree->root_node, array, &index);

	return array;
}"
avl_tree_remove_node,"AVLTree *tree, AVLTreeNode *node",,"0 | 1 | this node */
			return node | NULL | avl_tree_null_value | node->value | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes | array","void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)
{
	AVLTreeNode *swap_node;
	AVLTreeNode *balance_startpoint;
	int i;

	/* The node to be removed must be swapped with an ""adjacent""
	 * node, ie. one which has the closest key to this one. Find
	 * a node to swap with. */
	swap_node = avl_tree_node_get_replacement(tree, node);

	if (swap_node == NULL) {

		/* This is a leaf node and has no children, therefore
		 * it can be immediately removed. */
		/* Unlink this node from its parent. */
		avl_tree_node_replace(tree, node, NULL);

		/* Start rebalancing from the parent of the original node */
		balance_startpoint = node->parent;

	} else {
		/* We will start rebalancing from the old parent of the
		 * swap node.  Sometimes, the old parent is the node we
		 * are removing, in which case we must start rebalancing
		 * from the swap node. */
		if (swap_node->parent == node) {
			balance_startpoint = swap_node;
		} else {
			balance_startpoint = swap_node->parent;
		}

		/* Copy references in the node into the swap node */
		for (i = 0; i < 2; ++i) {
			swap_node->children[i] = node->children[i];

			if (swap_node->children[i] != NULL) {
				swap_node->children[i]->parent = swap_node;
			}
		}

		swap_node->height = node->height;

		/* Link the parent's reference to this node */
		avl_tree_node_replace(tree, node, swap_node);
	}

	/* Destroy the node */
	free(node);

	/* Keep track of the number of nodes */
	--tree->num_nodes;

	/* Rebalance the tree */
	avl_tree_balance_to_root(tree, balance_startpoint);
}

/* Remove a node by key */
int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}

AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;
	int diff;

	/* Search down the tree and attempt to find the node which
	 * has the specified key */
	node = tree->root_node;

	while (node != NULL) {

		diff = tree->compare_func(key, node->key);

		if (diff == 0) {

			/* Keys are equal: return this node */
			return node;

		} else if (diff < 0) {
			node = node->children[AVL_TREE_NODE_LEFT];
		} else {
			node = node->children[AVL_TREE_NODE_RIGHT];
		}
	}

	/* Not found */
	return NULL;
}

AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		return avl_tree_null_value;
	} else {
		return node->value;
	}
}

AVLTreeNode *avl_tree_root_node(AVLTree *tree)
{
	return tree->root_node;
}

AVLTreeKey avl_tree_node_key(AVLTreeNode *node)
{
	return node->key;
}

AVLTreeValue avl_tree_node_value(AVLTreeNode *node)
{
	return node->value;
}

AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)
{
	if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)
{
	return node->parent;
}

unsigned int avl_tree_num_entries(AVLTree *tree)
{
	return tree->num_nodes;
}

static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}

AVLTreeKey *avl_tree_to_array(AVLTree *tree)
{
	AVLTreeKey *array;
	int index;

	/* Allocate the array */
	array = malloc(sizeof(AVLTreeKey) * tree->num_nodes);

	if (array == NULL) {
		return NULL;
	}

	index = 0;

	/* Add all keys */
	avl_tree_to_array_add_subtree(tree->root_node, array, &index);

	return array;
}"
avl_tree_remove,"AVLTree *tree, AVLTreeKey key",,0 | 1,"int avl_tree_remove(AVLTree *tree, AVLTreeKey key)
{
	AVLTreeNode *node;

	/* Find the node to remove */
	node = avl_tree_lookup_node(tree, key);

	if (node == NULL) {
		/* Not found in tree */
		return 0;
	}

	/* Remove the node */
	avl_tree_remove_node(tree, node);

	return 1;
}"
avl_tree_to_array_add_subtree,"AVLTreeNode *subtree, AVLTreeKey *array, int *index",,null,"
static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree,
                                          AVLTreeKey *array, int *index)
{
	if (subtree == NULL) {
		return;
	}

	/* Add left subtree first */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT],
	                              array, index);

	/* Add this node */
	array[*index] = subtree->key;
	++*index;

	/* Finally add right subtree */
	avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT],
	                              array, index);
}"
binary_heap_cmp,"BinaryHeap *heap, BinaryHeapValue data1, BinaryHeapValue data2",Null value that can be returned without creating a local variable,"heap->compare_func(data1, data2) | -heap->compare_func(data1, data2)","
static int binary_heap_cmp(BinaryHeap *heap, BinaryHeapValue data1,
                           BinaryHeapValue data2)
{
	if (heap->heap_type == BINARY_HEAP_TYPE_MIN) {
		return heap->compare_func(data1, data2);
	} else {
		return -heap->compare_func(data1, data2);
	}
}"
binary_heap_free,BinaryHeap *heap,,null,"
void binary_heap_free(BinaryHeap *heap)
{
	free(heap->values);
	free(heap);
}"
binary_heap_insert,"BinaryHeap *heap, BinaryHeapValue value",,0 | 1,"
int binary_heap_insert(BinaryHeap *heap, BinaryHeapValue value)
{
	BinaryHeapValue *new_values;
	unsigned int index;
	unsigned int new_size;
	unsigned int parent;

	/* Possibly realloc the heap to a larger size */
	if (heap->num_values >= heap->alloced_size) {

		/* Double the table size */
		new_size = heap->alloced_size * 2;
		new_values =
		    realloc(heap->values, sizeof(BinaryHeapValue) * new_size);

		if (new_values == NULL) {
			return 0;
		}

		heap->alloced_size = new_size;
		heap->values = new_values;
	}

	/* Add to the bottom of the heap and start from there */
	index = heap->num_values;
	++heap->num_values;

	/* Percolate the value up to the top of the heap */
	while (index > 0) {

		/* The parent index is found by halving the node index */
		parent = (index - 1) / 2;

		/* Compare the node with its parent */
		if (binary_heap_cmp(heap, heap->values[parent], value) < 0) {

			/* Ordered correctly - insertion is complete */
			break;

		} else {

			/* Need to swap this node with its parent */
			heap->values[index] = heap->values[parent];

			/* Advance up to the parent */
			index = parent;
		}
	}

	/* Save the new value in the final location */
	heap->values[index] = value;

	return 1;
}"
binomial_heap_merge_undo,"BinomialTree **new_roots, unsigned int count",,null,"static void binomial_heap_merge_undo(BinomialTree **new_roots,
                                     unsigned int count)
{
	unsigned int i;

	for (i = 0; i <= count; ++i) {
		binomial_tree_unref(new_roots[i]);
	}

	free(new_roots);
}"
binomial_heap_merge,"BinomialHeap *heap, BinomialHeap *other",,0 | 1,"static int binomial_heap_merge(BinomialHeap *heap, BinomialHeap *other)
{
	BinomialTree **new_roots;
	unsigned int new_roots_length;
	BinomialTree *vals[3];
	int num_vals;
	BinomialTree *carry;
	BinomialTree *new_carry;
	unsigned int max;
	unsigned int i;

	/* Find the maximum length of the two heaps.  Add one because
	 * after merging we may have one more value to carry over. */
	if (heap->roots_length > other->roots_length) {
		max = heap->roots_length + 1;
	} else {
		max = other->roots_length + 1;
	}

	/* Allocate an array for the new roots */
	new_roots = malloc(sizeof(BinomialTree *) * max);

	if (new_roots == NULL) {
		return 0;
	}

	/* Go through one entry at a time.  This works kind of like a
	 * ripple-carry adder. */
	new_roots_length = 0;
	carry = NULL;

	for (i = 0; i < max; ++i) {

		/* Build up 'vals' as a list of all the values we must
		 * merge at this step. */
		num_vals = 0;

		/* If there is a value in 'heap', add it */
		if (i < heap->roots_length && heap->roots[i] != NULL) {
			vals[num_vals] = heap->roots[i];
			++num_vals;
		}

		/* If there is a value in 'other', add it */
		if (i < other->roots_length && other->roots[i] != NULL) {
			vals[num_vals] = other->roots[i];
			++num_vals;
		}

		/* If there is a carried value from the previous iteration,
		 * add it */
		if (carry != NULL) {
			vals[num_vals] = carry;
			++num_vals;
		}

		/* When num_vals == 1 or 3, we store a value. */
		if ((num_vals & 1) != 0) {

			/* Save the last value into new_roots. */
			new_roots[i] = vals[num_vals - 1];
			binomial_tree_ref(new_roots[i]);
			new_roots_length = i + 1;

		} else {

			/* No value to store at this iteration */
			new_roots[i] = NULL;
		}

		/* When num_vals == 2 or 3, we must carry over to the
		 * next iteration */
		if ((num_vals & 2) != 0) {

			/* Merge the first two values and carry to the
			 * next iteration */
			new_carry = binomial_tree_merge(heap, vals[0], vals[1]);

			if (new_carry == NULL) {

				/* Remove references that we have added
				 * (freeing any BinomialTree structures
				 * that were created in the process) */
				binomial_heap_merge_undo(new_roots, i);

				/* Unreference the carry variable */
				binomial_tree_unref(carry);

				return 0;
			}

		} else {

			/* Nothing to carry */
			new_carry = NULL;
		}

		/* Unreference previous carried value */
		binomial_tree_unref(carry);

		/* Assign the new value of carry, and add a reference */
		carry = new_carry;

		binomial_tree_ref(carry);
	}

	/* Unreference all values in the old 'roots' array, freeing unused
	 * BinomialTree structures as necessary. */
	for (i = 0; i < heap->roots_length; ++i) {
		if (heap->roots[i] != NULL) {
			binomial_tree_unref(heap->roots[i]);
		}
	}

	/* Free the old roots array and use the new one */
	free(heap->roots);
	heap->roots = new_roots;
	heap->roots_length = new_roots_length;

	/* Merged successfully */
	return 1;
}"
binomial_heap_free,BinomialHeap *heap,,null,"
void binomial_heap_free(BinomialHeap *heap)
{
	unsigned int i;

	/* Unreference all trees in the heap.  This should free
	 * back all subtrees. */
	for (i = 0; i < heap->roots_length; ++i) {
		binomial_tree_unref(heap->roots[i]);
	}

	/* Free the heap itself */
	free(heap->roots);
	free(heap);
}"
binomial_heap_insert,"BinomialHeap *heap, BinomialHeapValue value",,0 | result,"
int binomial_heap_insert(BinomialHeap *heap, BinomialHeapValue value)
{
	BinomialHeap fake_heap;
	BinomialTree *new_tree;
	int result;

	/* Allocate an order 0 tree for storing the new value */
	new_tree = malloc(sizeof(BinomialTree));

	if (new_tree == NULL) {
		return 0;
	}

	/* Fill in values.  This has an initial reference count of 1 that
	 * the ""fake"" heap holds; this will be removed at the end of
	 * this function. */
	new_tree->value = value;
	new_tree->order = 0;
	new_tree->refcount = 1;
	new_tree->subtrees = NULL;

	/* Build a fake heap structure for merging */
	fake_heap.heap_type = heap->heap_type;
	fake_heap.compare_func = heap->compare_func;
	fake_heap.num_values = 1;
	fake_heap.roots = &new_tree;
	fake_heap.roots_length = 1;

	/* Perform the merge */
	result = binomial_heap_merge(heap, &fake_heap);

	if (result != 0) {
		++heap->num_values;
	}

	/* Remove reference to the new tree. */
	binomial_tree_unref(new_tree);

	return result;
}"
bloom_filter_free,BloomFilter *bloomfilter,,null,"
void bloom_filter_free(BloomFilter *bloomfilter)
{
	free(bloomfilter->table);
	free(bloomfilter);
}"
bloom_filter_insert,"BloomFilter *bloomfilter, BloomFilterValue value",,null,"
void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)
{
	unsigned int hash;
	unsigned int subhash;
	unsigned int index;
	unsigned int i;
	unsigned char b;

	/* Generate hash of the value to insert */
	hash = bloomfilter->hash_func(value);

	/* Generate multiple unique hashes by XORing with values in the
	 * salt table. */
	for (i = 0; i < bloomfilter->num_functions; ++i) {

		/* Generate a unique hash */
		subhash = hash ^ salts[i];

		/* Find the index into the table */
		index = subhash % bloomfilter->table_size;

		/* Insert into the table.
		 * index / 8 finds the byte index of the table,
		 * index % 8 gives the bit index within that byte to set. */
		b = (unsigned char) (1 << (index % 8));
		bloomfilter->table[index / 8] |= b;
	}
}"
bloom_filter_query,"BloomFilter *bloomfilter, BloomFilterValue value",,0 | 1,"
int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)
{
	unsigned int hash;
	unsigned int subhash;
	unsigned int index;
	unsigned int i;
	unsigned char b;
	int bit;

	/* Generate hash of the value to lookup */
	hash = bloomfilter->hash_func(value);

	/* Generate multiple unique hashes by XORing with values in the
	 * salt table. */
	for (i = 0; i < bloomfilter->num_functions; ++i) {

		/* Generate a unique hash */
		subhash = hash ^ salts[i];

		/* Find the index into the table to test */
		index = subhash % bloomfilter->table_size;

		/* The byte at index / 8 holds the value to test */
		b = bloomfilter->table[index / 8];
		bit = 1 << (index % 8);

		/* Test if the particular bit is set; if it is not set,
		 * this value can not have been inserted. */
		if ((b & bit) == 0) {
			return 0;
		}
	}

	/* All necessary bits were set.  This may indicate that the value
	 * was inserted, or the values could have been set through other
	 * insertions. */
	return 1;
}"
bloom_filter_read,"BloomFilter *bloomfilter, unsigned char *array","All necessary bits were set.  This may indicate that the value
was inserted, or the values could have been set through other
insertions.",null,"
void bloom_filter_read(BloomFilter *bloomfilter, unsigned char *array)
{
	unsigned int array_size;

	/* The table is an array of bits, packed into bytes.  Round up
	 * to the nearest byte. */
	array_size = (bloomfilter->table_size + 7) / 8;

	/* Copy into the buffer of the calling routine. */
	memcpy(array, bloomfilter->table, array_size);
}"
bloom_filter_load,"BloomFilter *bloomfilter, unsigned char *array",Copy into the buffer of the calling routine.,null,"
void bloom_filter_load(BloomFilter *bloomfilter, unsigned char *array)
{
	unsigned int array_size;

	/* The table is an array of bits, packed into bytes.  Round up
	 * to the nearest byte. */
	array_size = (bloomfilter->table_size + 7) / 8;

	/* Copy from the buffer of the calling routine. */
	memcpy(bloomfilter->table, array, array_size);
}"
int_equal,"void *vlocation1, void *vlocation2",Comparison functions for a pointer to an integer,*location1 == *location2,"
int int_equal(void *vlocation1, void *vlocation2)
{
	int *location1;
	int *location2;

	location1 = (int *) vlocation1;
	location2 = (int *) vlocation2;

	return *location1 == *location2;
}"
int_compare,"void *vlocation1, void *vlocation2",,-1 | 1 | 0,"
int int_compare(void *vlocation1, void *vlocation2)
{
	int *location1;
	int *location2;

	location1 = (int *) vlocation1;
	location2 = (int *) vlocation2;

	if (*location1 < *location2) {
		return -1;
	} else if (*location1 > *location2) {
		return 1;
	} else {
		return 0;
	}
}"
pointer_equal,"void *location1, void *location2",Comparison functions for a generic void pointer,location1 == location2,"
int pointer_equal(void *location1, void *location2)
{
	return location1 == location2;
}"
pointer_compare,"void *location1, void *location2",,-1 | 1 | 0,"
int pointer_compare(void *location1, void *location2)
{
	if (location1 < location2) {
		return -1;
	} else if (location1 > location2) {
		return 1;
	} else {
		return 0;
	}
}"
string_nocase_equal,"void *string1, void *string2",,"string_nocase_compare((char *) string1, (char *) string2) == 0","int string_nocase_equal(void *string1, void *string2)
{
	return string_nocase_compare((char *) string1, (char *) string2) == 0;
}"
string_nocase_compare,"void *string1, void *string2",,-1 | 1 | 0,"int string_nocase_compare(void *string1, void *string2)
{
	char *p1;
	char *p2;
	int c1, c2;

	/* Iterate over each character in the strings */
	p1 = (char *) string1;
	p2 = (char *) string2;

	for (;;) {

		c1 = tolower(*p1);
		c2 = tolower(*p2);

		if (c1 != c2) {

			/* Strings are different */
			if (c1 < c2) {
				return -1;
			} else {
				return 1;
			}
		}

		/* End of string */
		if (c1 == '\0') {
			break;
		}

		/* Advance to the next character */
		++p1;
		++p2;
	}

	/* Reached the end of string and no difference found */
	return 0;
}"
hash_table_allocate_table,HashTable *hash_table,,hash_table->table != NULL,"static int hash_table_allocate_table(HashTable *hash_table)
{
	unsigned int new_table_size;

	/* Determine the table size based on the current prime index.
	 * An attempt is made here to ensure sensible behavior if the
	 * maximum prime is exceeded, but in practice other things are
	 * likely to break long before that happens. */
	if (hash_table->prime_index < hash_table_num_primes) {
		new_table_size = hash_table_primes[hash_table->prime_index];
	} else {
		new_table_size = hash_table->entries * 10;
	}

	hash_table->table_size = new_table_size;

	/* Allocate the table and initialise to NULL for all entries */
	hash_table->table =
	    calloc(hash_table->table_size, sizeof(HashTableEntry *));

	return hash_table->table != NULL;
}"
hash_table_free_entry,"HashTable *hash_table, HashTableEntry *entry",,null,"static void hash_table_free_entry(HashTable *hash_table, HashTableEntry *entry)
{
	HashTablePair *pair;

	pair = &(entry->pair);

	/* If there is a function registered for freeing keys, use it to free
	 * the key */
	if (hash_table->key_free_func != NULL) {
		hash_table->key_free_func(pair->key);
	}

	/* Likewise with the value */
	if (hash_table->value_free_func != NULL) {
		hash_table->value_free_func(pair->value);
	}

	/* Free the data structure */
	free(entry);
}"
hash_table_free,HashTable *hash_table,,null,"
void hash_table_free(HashTable *hash_table)
{
	HashTableEntry *rover;
	HashTableEntry *next;
	unsigned int i;

	/* Free all entries in all chains */
	for (i = 0; i < hash_table->table_size; ++i) {
		rover = hash_table->table[i];
		while (rover != NULL) {
			next = rover->next;
			hash_table_free_entry(hash_table, rover);
			rover = next;
		}
	}

	/* Free the table */
	free(hash_table->table);

	/* Free the hash table structure */
	free(hash_table);
}"
hash_table_register_free_functions,"HashTable *hash_table, HashTableKeyFreeFunc key_free_func, HashTableValueFreeFunc value_free_func",Free the hash table structure,null,"
void hash_table_register_free_functions(HashTable *hash_table,
                                        HashTableKeyFreeFunc key_free_func,
                                        HashTableValueFreeFunc value_free_func)
{
	hash_table->key_free_func = key_free_func;
	hash_table->value_free_func = value_free_func;
}"
hash_table_enlarge,HashTable *hash_table,,0 | 1,"
static int hash_table_enlarge(HashTable *hash_table)
{
	HashTableEntry **old_table;
	unsigned int old_table_size;
	unsigned int old_prime_index;
	HashTableEntry *rover;
	HashTablePair *pair;
	HashTableEntry *next;
	unsigned int index;
	unsigned int i;

	/* Store a copy of the old table */
	old_table = hash_table->table;
	old_table_size = hash_table->table_size;
	old_prime_index = hash_table->prime_index;

	/* Allocate a new, larger table */
	++hash_table->prime_index;

	if (!hash_table_allocate_table(hash_table)) {

		/* Failed to allocate the new table */
		hash_table->table = old_table;
		hash_table->table_size = old_table_size;
		hash_table->prime_index = old_prime_index;

		return 0;
	}

	/* Link all entries from all chains into the new table */
	for (i = 0; i < old_table_size; ++i) {
		rover = old_table[i];

		while (rover != NULL) {
			next = rover->next;

			/* Fetch rover HashTablePair */
			pair = &(rover->pair);

			/* Find the index into the new table */
			index = hash_table->hash_func(pair->key) %
			        hash_table->table_size;

			/* Link this entry into the chain */
			rover->next = hash_table->table[index];
			hash_table->table[index] = rover;

			/* Advance to next in the chain */
			rover = next;
		}
	}

	/* Free the old table */
	free(old_table);

	return 1;
}"
hash_table_insert,"HashTable *hash_table, HashTableKey key, HashTableValue value",,0 | 1 | pair->value | hash_table_null_value | result | hash_table->entries | iterator->next_entry != NULL | pair,"
int hash_table_insert(HashTable *hash_table, HashTableKey key,
                      HashTableValue value)
{
	HashTableEntry *rover;
	HashTablePair *pair;
	HashTableEntry *newentry;
	unsigned int index;

	/* If there are too many items in the table with respect to the table
	 * size, the number of hash collisions increases and performance
	 * decreases. Enlarge the table size to prevent this happening */
	if ((hash_table->entries * 3) / hash_table->table_size > 0) {

		/* Table is more than 1/3 full */
		if (!hash_table_enlarge(hash_table)) {

			/* Failed to enlarge the table */
			return 0;
		}
	}

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Traverse the chain at this location and look for an existing
	 * entry with the same key */
	rover = hash_table->table[index];

	while (rover != NULL) {

		/* Fetch rover's HashTablePair entry */
		pair = &(rover->pair);

		if (hash_table->equal_func(pair->key, key) != 0) {

			/* Same key: overwrite this entry with new data */
			/* If there is a value free function, free the old data
			 * before adding in the new data */
			if (hash_table->value_free_func != NULL) {
				hash_table->value_free_func(pair->value);
			}

			/* Same with the key: use the new key value and free
			 * the old one */
			if (hash_table->key_free_func != NULL) {
				hash_table->key_free_func(pair->key);
			}

			pair->key = key;
			pair->value = value;

			/* Finished */
			return 1;
		}

		rover = rover->next;
	}

	/* Not in the hash table yet.  Create a new entry */
	newentry = (HashTableEntry *) malloc(sizeof(HashTableEntry));

	if (newentry == NULL) {
		return 0;
	}

	newentry->pair.key = key;
	newentry->pair.value = value;

	/* Link into the list */
	newentry->next = hash_table->table[index];
	hash_table->table[index] = newentry;

	/* Maintain the count of the number of entries */
	++hash_table->entries;

	/* Added successfully */
	return 1;
}

HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry *rover;
	HashTablePair *pair;
	unsigned int index;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Walk the chain at this index until the corresponding entry is
	 * found */
	rover = hash_table->table[index];

	while (rover != NULL) {
		pair = &(rover->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* Found the entry.  Return the data. */
			return pair->value;
		}

		rover = rover->next;
	}

	/* Not found */
	return hash_table_null_value;
}

int hash_table_remove(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry **rover;
	HashTableEntry *entry;
	HashTablePair *pair;
	unsigned int index;
	int result;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Rover points at the pointer which points at the current entry
	 * in the chain being inspected.  ie. the entry in the table, or
	 * the ""next"" pointer of the previous entry in the chain.  This
	 * allows us to unlink the entry when we find it. */
	result = 0;
	rover = &hash_table->table[index];

	while (*rover != NULL) {

		pair = &((*rover)->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* This is the entry to remove */
			entry = *rover;

			/* Unlink from the list */
			*rover = entry->next;

			/* Destroy the entry structure */
			hash_table_free_entry(hash_table, entry);

			/* Track count of entries */
			--hash_table->entries;

			result = 1;

			break;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	return result;
}

unsigned int hash_table_num_entries(HashTable *hash_table)
{
	return hash_table->entries;
}

void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)
{
	unsigned int chain;

	iterator->hash_table = hash_table;

	/* Default value of next if no entries are found. */
	iterator->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < hash_table->table_size; ++chain) {

		if (hash_table->table[chain] != NULL) {
			iterator->next_entry = hash_table->table[chain];
			iterator->next_chain = chain;
			break;
		}
	}
}

int hash_table_iter_has_more(HashTableIterator *iterator)
{
	return iterator->next_entry != NULL;
}

HashTablePair hash_table_iter_next(HashTableIterator *iterator)
{
	HashTableEntry *current_entry;
	HashTable *hash_table;
	HashTablePair pair = {HASH_TABLE_KEY_NULL, HASH_TABLE_NULL};
	unsigned int chain;

	hash_table = iterator->hash_table;

	if (iterator->next_entry == NULL) {
		return pair;
	}

	/* Result is immediately available */
	current_entry = iterator->next_entry;
	pair = current_entry->pair;

	/* Find the next entry */
	if (current_entry->next != NULL) {

		/* Next entry in current chain */
		iterator->next_entry = current_entry->next;

	} else {

		/* None left in this chain, so advance to the next chain */
		chain = iterator->next_chain + 1;

		/* Default value if no next chain found */
		iterator->next_entry = NULL;

		while (chain < hash_table->table_size) {

			/* Is there anything in this chain? */
			if (hash_table->table[chain] != NULL) {
				iterator->next_entry = hash_table->table[chain];
				break;
			}

			/* Try the next chain */
			++chain;
		}

		iterator->next_chain = chain;
	}

	return pair;
}
"
hash_table_remove,"HashTable *hash_table, HashTableKey key",Not found,result,"
int hash_table_remove(HashTable *hash_table, HashTableKey key)
{
	HashTableEntry **rover;
	HashTableEntry *entry;
	HashTablePair *pair;
	unsigned int index;
	int result;

	/* Generate the hash of the key and hence the index into the table */
	index = hash_table->hash_func(key) % hash_table->table_size;

	/* Rover points at the pointer which points at the current entry
	 * in the chain being inspected.  ie. the entry in the table, or
	 * the ""next"" pointer of the previous entry in the chain.  This
	 * allows us to unlink the entry when we find it. */
	result = 0;
	rover = &hash_table->table[index];

	while (*rover != NULL) {

		pair = &((*rover)->pair);

		if (hash_table->equal_func(key, pair->key) != 0) {

			/* This is the entry to remove */
			entry = *rover;

			/* Unlink from the list */
			*rover = entry->next;

			/* Destroy the entry structure */
			hash_table_free_entry(hash_table, entry);

			/* Track count of entries */
			--hash_table->entries;

			result = 1;

			break;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	return result;
}"
hash_table_iterate,"HashTable *hash_table, HashTableIterator *iterator",,null,"
void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)
{
	unsigned int chain;

	iterator->hash_table = hash_table;

	/* Default value of next if no entries are found. */
	iterator->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < hash_table->table_size; ++chain) {

		if (hash_table->table[chain] != NULL) {
			iterator->next_entry = hash_table->table[chain];
			iterator->next_chain = chain;
			break;
		}
	}
}"
hash_table_iter_has_more,HashTableIterator *iterator,,iterator->next_entry != NULL,"
int hash_table_iter_has_more(HashTableIterator *iterator)
{
	return iterator->next_entry != NULL;
}"
list_free,ListEntry *list,Null value that can be returned without creating a local variable,null,"
void list_free(ListEntry *list)
{
	ListEntry *entry;

	/* Iterate over each entry, freeing each list entry, until the
	 * end is reached */
	entry = list;

	while (entry != NULL) {
		ListEntry *next;

		next = entry->next;

		free(entry);

		entry = next;
	}
}"
list_set_data,"ListEntry *listentry, ListValue value",,null,"
void list_set_data(ListEntry *listentry, ListValue value)
{
	if (listentry != NULL) {
		listentry->data = value;
	}
}"
list_remove_entry,"ListEntry **list, ListEntry *entry",,0 | 1 | entries_removed | NULL | *list | pivot | more_list_end | rover | *iter->prev_next != NULL | iter->current->next != NULL | list_null_value | iter->current->data,"
int list_remove_entry(ListEntry **list, ListEntry *entry)
{
	/* If the list is empty, or entry is NULL, always fail */
	if (list == NULL || *list == NULL || entry == NULL) {
		return 0;
	}

	/* Action to take is different if the entry is the first in the list */
	if (entry->prev == NULL) {

		/* Unlink the first entry and update the starting pointer */
		*list = entry->next;

		/* Update the second entry's prev pointer, if there is a second
		 * entry */
		if (entry->next != NULL) {
			entry->next->prev = NULL;
		}

	} else {

		/* This is not the first in the list, so we must have a
		 * previous entry.  Update its 'next' pointer to the new
		 * value */
		entry->prev->next = entry->next;

		/* If there is an entry following this one, update its 'prev'
		 * pointer to the new value */
		if (entry->next != NULL) {
			entry->next->prev = entry->prev;
		}
	}

	/* Free the list entry */
	free(entry);

	/* Operation successful */
	return 1;
}

unsigned int list_remove_data(ListEntry **list, ListEqualFunc callback,
                              ListValue data)
{
	unsigned int entries_removed;
	ListEntry *rover;
	ListEntry *next;

	if (list == NULL || callback == NULL) {
		return 0;
	}

	entries_removed = 0;

	/* Iterate over the entries in the list */
	rover = *list;

	while (rover != NULL) {

		next = rover->next;

		if (callback(rover->data, data)) {

			/* This data needs to be removed.  Unlink this entry
			 * from the list. */
			if (rover->prev == NULL) {

				/* This is the first entry in the list */
				*list = rover->next;
			} else {

				/* Point the previous entry at its new
				 * location */
				rover->prev->next = rover->next;
			}

			if (rover->next != NULL) {
				rover->next->prev = rover->prev;
			}

			/* Free the entry */
			free(rover);

			++entries_removed;
		}

		/* Advance to the next list entry */
		rover = next;
	}

	return entries_removed;
}

/* Function used internally for sorting.  Returns the last entry in the
 * new sorted list */
static ListEntry *list_sort_internal(ListEntry **list,
                                     ListCompareFunc compare_func)
{
	ListEntry *pivot;
	ListEntry *rover;
	ListEntry *less_list, *more_list;
	ListEntry *less_list_end, *more_list_end;

	if (list == NULL || compare_func == NULL) {
		return NULL;
	}

	/* If there are less than two entries in this list, it is
	 * already sorted */
	if (*list == NULL || (*list)->next == NULL) {
		return *list;
	}

	/* The first entry is the pivot */
	pivot = *list;

	/* Iterate over the list, starting from the second entry.  Sort
	 * all entries into the less and more lists based on comparisons
	 * with the pivot */
	less_list = NULL;
	more_list = NULL;
	rover = (*list)->next;

	while (rover != NULL) {
		ListEntry *next = rover->next;

		if (compare_func(rover->data, pivot->data) < 0) {

			/* Place this in the less list */
			rover->prev = NULL;
			rover->next = less_list;
			if (less_list != NULL) {
				less_list->prev = rover;
			}
			less_list = rover;

		} else {

			/* Place this in the more list */
			rover->prev = NULL;
			rover->next = more_list;
			if (more_list != NULL) {
				more_list->prev = rover;
			}
			more_list = rover;
		}

		rover = next;
	}

	/* Sort the sublists recursively */
	less_list_end = list_sort_internal(&less_list, compare_func);
	more_list_end = list_sort_internal(&more_list, compare_func);

	/* Create the new list starting from the less list */
	*list = less_list;

	/* Append the pivot to the end of the less list.  If the less list
	 * was empty, start from the pivot */
	if (less_list == NULL) {
		pivot->prev = NULL;
		*list = pivot;
	} else {
		pivot->prev = less_list_end;
		less_list_end->next = pivot;
	}

	/* Append the more list after the pivot */
	pivot->next = more_list;
	if (more_list != NULL) {
		more_list->prev = pivot;
	}

	/* Work out what the last entry in the list is.  If the more list was
	 * empty, the pivot was the last entry.  Otherwise, the end of the
	 * more list is the end of the total list. */
	if (more_list == NULL) {
		return pivot;
	} else {
		return more_list_end;
	}
}

void list_sort(ListEntry **list, ListCompareFunc compare_func)
{
	list_sort_internal(list, compare_func);
}

ListEntry *list_find_data(ListEntry *list, ListEqualFunc callback,
                          ListValue data)
{
	ListEntry *rover;

	/* Iterate over entries in the list until the data is found */
	for (rover = list; rover != NULL; rover = rover->next) {
		if (callback(rover->data, data) != 0) {
			return rover;
		}
	}

	/* Not found */
	return NULL;
}

void list_iterate(ListEntry **list, ListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}

int list_iter_has_more(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {
		/* The current entry as not been deleted since the last
		 * call to list_iter_next: there is a next entry if
		 * current->next is not NULL */
		return iter->current->next != NULL;
	}
}

ListValue list_iter_next(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we are reading the first entry, we have reached
		 * the end of the list, or the previous entry was removed.
		 * Get the next entry with iter->prev_next. */
		iter->current = *iter->prev_next;

	} else {

		/* Last value returned from list_iter_next was not deleted.
		 * Advance to the next entry. */
		iter->prev_next = &iter->current->next;
		iter->current = iter->current->next;
	}

	/* Have we reached the end of the list? */
	if (iter->current == NULL) {
		return list_null_value;
	} else {
		return iter->current->data;
	}
}

void list_iter_remove(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;

		if (iter->current->next != NULL) {
			iter->current->next->prev = iter->current->prev;
		}

		free(iter->current);
		iter->current = NULL;
	}
}
"
list_sort,"ListEntry **list, ListCompareFunc compare_func",,null,"
void list_sort(ListEntry **list, ListCompareFunc compare_func)
{
	list_sort_internal(list, compare_func);
}"
list_iterate,"ListEntry **list, ListIterator *iter",Not found,null,"
void list_iterate(ListEntry **list, ListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}"
list_iter_has_more,ListIterator *iter,We have not yet read the first item.,*iter->prev_next != NULL | iter->current->next != NULL,"
int list_iter_has_more(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {
		/* The current entry as not been deleted since the last
		 * call to list_iter_next: there is a next entry if
		 * current->next is not NULL */
		return iter->current->next != NULL;
	}
}"
list_iter_remove,ListIterator *iter,,null,"
void list_iter_remove(ListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;

		if (iter->current->next != NULL) {
			iter->current->next->prev = iter->current->prev;
		}

		free(iter->current);
		iter->current = NULL;
	}
}"
queue_free,Queue *queue,,null,"
void queue_free(Queue *queue)
{
	/* Empty the queue */
	while (!queue_is_empty(queue)) {
		queue_pop_head(queue);
	}

	/* Free back the queue */
	free(queue);
}"
queue_push_head,"Queue *queue, QueueValue data",Free back the queue,0 | 1,"
int queue_push_head(Queue *queue, QueueValue data)
{
	QueueEntry *new_entry;

	/* Create the new entry and fill in the fields in the structure */
	new_entry = malloc(sizeof(QueueEntry));

	if (new_entry == NULL) {
		return 0;
	}

	new_entry->data = data;
	new_entry->prev = NULL;
	new_entry->next = queue->head;

	/* Insert into the queue */
	if (queue->head == NULL) {

		/* If the queue was previously empty, both the head and
		 * tail must be pointed at the new entry */
		queue->head = new_entry;
		queue->tail = new_entry;

	} else {

		/* First entry in the list must have prev pointed back to this
		 * new entry */
		queue->head->prev = new_entry;

		/* Only the head must be pointed at the new entry */
		queue->head = new_entry;
	}

	return 1;
}"
queue_push_tail,"Queue *queue, QueueValue data",,0 | 1,"
int queue_push_tail(Queue *queue, QueueValue data)
{
	QueueEntry *new_entry;

	/* Create the new entry and fill in the fields in the structure */
	new_entry = malloc(sizeof(QueueEntry));

	if (new_entry == NULL) {
		return 0;
	}

	new_entry->data = data;
	new_entry->prev = queue->tail;
	new_entry->next = NULL;

	/* Insert into the queue tail */
	if (queue->tail == NULL) {

		/* If the queue was previously empty, both the head and
		 * tail must be pointed at the new entry */
		queue->head = new_entry;
		queue->tail = new_entry;

	} else {

		/* The current entry at the tail must have next pointed to this
		 * new entry */
		queue->tail->next = new_entry;

		/* Only the tail must be pointed at the new entry */
		queue->tail = new_entry;
	}

	return 1;
}"
queue_is_empty,Queue *queue,,queue->head == NULL,"
int queue_is_empty(Queue *queue)
{
	return queue->head == NULL;
}"
rb_tree_node_replace,"RBTree *tree, RBTreeNode *node1, RBTreeNode *node2",,new_root | NULL | new_tree | node | rb_tree_null_value | node->value | 0 | 1 | tree->root_node | node->key | node->children[side] | node->parent | tree->num_nodes,"static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1,
                                 RBTreeNode *node2)
{
	int side;

	/* Set the node's parent pointer. */
	if (node2 != NULL) {
		node2->parent = node1->parent;
	}

	/* The root node? */
	if (node1->parent == NULL) {
		tree->root_node = node2;
	} else {
		side = rb_tree_node_side(node1);
		node1->parent->children[side] = node2;
	}
}

/* Rotate a section of the tree.  'node' is the node at the top
 * of the section to be rotated.  'direction' is the direction in
 * which to rotate the tree: left or right, as shown in the following
 * diagram:
 *
 * Left rotation:              Right rotation:
 *
 *      B                             D
 *     / \                           / \
 *    A   D                         B   E
 *       / \                       / \
 *      C   E                     A   C

 * is rotated to:              is rotated to:
 *
 *        D                           B
 *       / \                         / \
 *      B   E                       A   D
 *     / \                             / \
 *    A   C                           C   E
 */
static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node,
                                  RBTreeNodeSide direction)
{
	RBTreeNode *new_root;

	/* The child of this node will take its place:
	   for a left rotation, it is the right child, and vice versa. */
	new_root = node->children[1 - direction];

	/* Make new_root the root, update parent pointers. */
	rb_tree_node_replace(tree, node, new_root);

	/* Rearrange pointers */
	node->children[1 - direction] = new_root->children[direction];
	new_root->children[direction] = node;

	/* Update parent references */
	node->parent = new_root;

	if (node->children[1 - direction] != NULL) {
		node->children[1 - direction]->parent = node;
	}

	return new_root;
}

RBTree *rb_tree_new(RBTreeCompareFunc compare_func)
{
	RBTree *new_tree;

	new_tree = malloc(sizeof(RBTree));

	if (new_tree == NULL) {
		return NULL;
	}

	new_tree->root_node = NULL;
	new_tree->num_nodes = 0;
	new_tree->compare_func = compare_func;

	return new_tree;
}

static void rb_tree_free_subtree(RBTreeNode *node)
{
	if (node != NULL) {
		/* Recurse to subnodes */
		rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);
		rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);

		/* Free this node */
		free(node);
	}
}

void rb_tree_free(RBTree *tree)
{
	/* Free all nodes in the tree */
	rb_tree_free_subtree(tree->root_node);

	/* Free back the main tree structure */
	free(tree);
}

static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node);
static void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node);

/* Insert case 1: If the new node is at the root of the tree, it must
 * be recolored black, as the root is always black. */
static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)
{
	if (node->parent == NULL) {

		/* The root node is black */
		node->color = RB_TREE_NODE_BLACK;

	} else {

		/* Not root */
		rb_tree_insert_case2(tree, node);
	}
}

/* Insert case 2: If the parent of the new node is red, this
 * conflicts with the red-black tree conditions, as both children
 * of every red node are black. */
static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	/* Note that if this function is being called, we already know
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}

/* Insert case 3: If the parent and uncle are both red, repaint them
 * both black and repaint the grandparent red.  */
static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *grandparent;
	RBTreeNode *uncle;

	/* Note that the node must have a grandparent, as the parent
	 * is red, and the root node is always black. */
	grandparent = node->parent->parent;
	uncle = rb_tree_node_uncle(node);

	if (uncle != NULL && uncle->color == RB_TREE_NODE_RED) {

		node->parent->color = RB_TREE_NODE_BLACK;
		uncle->color = RB_TREE_NODE_BLACK;
		grandparent->color = RB_TREE_NODE_RED;

		/* Recurse to grandparent */
		rb_tree_insert_case1(tree, grandparent);

	} else {
		rb_tree_insert_case4(tree, node);
	}
}

/* Case 4: If the parent is red, but the uncle is black, we need to do
 * some rotations to keep the tree balanced and complying with the tree
 * conditions.  If the node is on the opposite side relative to its parent
 * as the parent is relative to its grandparent, rotate around the
 * parent.  Either way, we will continue to case 5.
 *
 * eg.
 *
 *         B                              B
 *        / \                            / \
 *       R   B          ->     node ->  R   B
 *        \                            /
 *         R  <- node                 R
 *
 */
void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *next_node;
	RBTreeNodeSide side;

	/* Note that at this point, by implication from case 3, we know
	 * that the parent is red, but the uncle is black.  We therefore
	 * only need to examine what side the node is on relative
	 * to its parent, and the side the parent is on relative to
	 * the grandparent. */
	side = rb_tree_node_side(node);

	if (side != rb_tree_node_side(node->parent)) {

		/* After the rotation, we will continue to case 5, but
		 * the parent node will be at the bottom. */
		next_node = node->parent;

		/* Rotate around the parent in the opposite direction
		 * to side. */
		rb_tree_rotate(tree, node->parent, 1 - side);
	} else {
		next_node = node;
	}

	rb_tree_insert_case5(tree, next_node);
}

/* Case 5: The node is on the same side relative to its parent as the
 * parent is relative to its grandparent.  The node and its parent are
 * red, but the uncle is black.
 *
 * Now, rotate at the grandparent and recolor the parent and grandparent
 * to black and red respectively.
 *
 *               G/B                 P/B
 *              /   \               /   \
 *           P/R     U/B    ->   N/R     G/R
 *          /   \                       /   \
 *       N/R      ?                   ?      U/B
 *
 */
void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *parent;
	RBTreeNode *grandparent;
	RBTreeNodeSide side;

	parent = node->parent;
	grandparent = parent->parent;

	/* What side are we, relative to the parent?  This will determine
	 * the direction that we rotate. */
	side = rb_tree_node_side(node);

	/* Rotate at the grandparent, in the opposite direction to side. */
	rb_tree_rotate(tree, grandparent, 1 - side);

	/* Recolor the (old) parent and grandparent. */
	parent->color = RB_TREE_NODE_BLACK;
	grandparent->color = RB_TREE_NODE_RED;
}

RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)
{
	RBTreeNode *node;
	RBTreeNode **rover;
	RBTreeNode *parent;
	RBTreeNodeSide side;

	/* Allocate a new node */
	node = malloc(sizeof(RBTreeNode));

	if (node == NULL) {
		return NULL;
	}

	/* Set up structure.  Initially, the node is red. */
	node->key = key;
	node->value = value;
	node->color = RB_TREE_NODE_RED;
	node->children[RB_TREE_NODE_LEFT] = NULL;
	node->children[RB_TREE_NODE_RIGHT] = NULL;

	/* First, perform a normal binary tree-style insert. */
	parent = NULL;
	rover = &tree->root_node;

	while (*rover != NULL) {

		/* Update parent */
		parent = *rover;

		/* Choose which path to go down, left or right child */
		if (tree->compare_func(key, (*rover)->key) < 0) {
			side = RB_TREE_NODE_LEFT;
		} else {
			side = RB_TREE_NODE_RIGHT;
		}

		rover = &(*rover)->children[side];
	}

	/* Insert at the position we have reached */
	*rover = node;
	node->parent = parent;

	/* Possibly reorder the tree. */
	rb_tree_insert_case1(tree, node);

	/* Update the node count */
	++tree->num_nodes;

	return node;
}

RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;
	RBTreeNodeSide side;
	int diff;

	node = tree->root_node;

	/* Search down the tree. */
	while (node != NULL) {
		diff = tree->compare_func(key, node->key);

		if (diff == 0) {
			return node;
		} else if (diff < 0) {
			side = RB_TREE_NODE_LEFT;
		} else {
			side = RB_TREE_NODE_RIGHT;
		}

		node = node->children[side];
	}

	/* Not found. */
	return NULL;
}

RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node for this key. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return rb_tree_null_value;
	} else {
		return node->value;
	}
}

void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)
{ /* TODO */
}

int rb_tree_remove(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node to remove. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return 0;
	}

	rb_tree_remove_node(tree, node);

	return 1;
}

RBTreeNode *rb_tree_root_node(RBTree *tree)
{
	return tree->root_node;
}

RBTreeKey rb_tree_node_key(RBTreeNode *node)
{
	return node->key;
}

RBTreeValue rb_tree_node_value(RBTreeNode *node)
{
	return node->value;
}

RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)
{
	if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT) {
		return node->children[side];
	} else {
		return NULL;
	}
}

RBTreeNode *rb_tree_node_parent(RBTreeNode *node)
{
	return node->parent;
}

RBTreeKey *rb_tree_to_array(RBTree *tree)
{
	/* TODO */
	return NULL;
}

int rb_tree_num_entries(RBTree *tree)
{
	return tree->num_nodes;
}"
rb_tree_insert_case1,"RBTree *tree, RBTreeNode *node",,null,"static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)
{
	if (node->parent == NULL) {

		/* The root node is black */
		node->color = RB_TREE_NODE_BLACK;

	} else {

		/* Not root */
		rb_tree_insert_case2(tree, node);
	}
}"
rb_tree_insert_case2,"RBTree *tree, RBTreeNode *node",,null,"static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)
{
	/* Note that if this function is being called, we already know
	 * the node has a parent, as it is not the root node. */
	if (node->parent->color != RB_TREE_NODE_BLACK) {
		rb_tree_insert_case3(tree, node);
	}
}"
rb_tree_insert_case3,"RBTree *tree, RBTreeNode *node","Insert case 2: If the parent of the new node is red, this
conflicts with the red-black tree conditions, as both children
of every red node are black.",null,"static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *grandparent;
	RBTreeNode *uncle;

	/* Note that the node must have a grandparent, as the parent
	 * is red, and the root node is always black. */
	grandparent = node->parent->parent;
	uncle = rb_tree_node_uncle(node);

	if (uncle != NULL && uncle->color == RB_TREE_NODE_RED) {

		node->parent->color = RB_TREE_NODE_BLACK;
		uncle->color = RB_TREE_NODE_BLACK;
		grandparent->color = RB_TREE_NODE_RED;

		/* Recurse to grandparent */
		rb_tree_insert_case1(tree, grandparent);

	} else {
		rb_tree_insert_case4(tree, node);
	}
}"
rb_tree_insert_case4,"RBTree *tree, RBTreeNode *node",,null,"void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *next_node;
	RBTreeNodeSide side;

	/* Note that at this point, by implication from case 3, we know
	 * that the parent is red, but the uncle is black.  We therefore
	 * only need to examine what side the node is on relative
	 * to its parent, and the side the parent is on relative to
	 * the grandparent. */
	side = rb_tree_node_side(node);

	if (side != rb_tree_node_side(node->parent)) {

		/* After the rotation, we will continue to case 5, but
		 * the parent node will be at the bottom. */
		next_node = node->parent;

		/* Rotate around the parent in the opposite direction
		 * to side. */
		rb_tree_rotate(tree, node->parent, 1 - side);
	} else {
		next_node = node;
	}

	rb_tree_insert_case5(tree, next_node);
}"
rb_tree_insert_case5,"RBTree *tree, RBTreeNode *node",,null,"void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)
{
	RBTreeNode *parent;
	RBTreeNode *grandparent;
	RBTreeNodeSide side;

	parent = node->parent;
	grandparent = parent->parent;

	/* What side are we, relative to the parent?  This will determine
	 * the direction that we rotate. */
	side = rb_tree_node_side(node);

	/* Rotate at the grandparent, in the opposite direction to side. */
	rb_tree_rotate(tree, grandparent, 1 - side);

	/* Recolor the (old) parent and grandparent. */
	parent->color = RB_TREE_NODE_BLACK;
	grandparent->color = RB_TREE_NODE_RED;
}"
rb_tree_remove_node,"RBTree *tree, RBTreeNode *node",,null,"
void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)
{ /* TODO */
}"
rb_tree_remove,"RBTree *tree, RBTreeKey key",TODO,0 | 1,"
int rb_tree_remove(RBTree *tree, RBTreeKey key)
{
	RBTreeNode *node;

	/* Find the node to remove. */
	node = rb_tree_lookup_node(tree, key);

	if (node == NULL) {
		return 0;
	}

	rb_tree_remove_node(tree, node);

	return 1;
}"
rb_tree_num_entries,RBTree *tree,TODO,tree->num_nodes,"
int rb_tree_num_entries(RBTree *tree)
{
	return tree->num_nodes;
}"
set_allocate_table,Set *set,Null value that can be returned without creating a local variable,set->table != NULL,"
static int set_allocate_table(Set *set)
{
	/* Determine the table size based on the current prime index.
	 * An attempt is made here to ensure sensible behavior if the
	 * maximum prime is exceeded, but in practice other things are
	 * likely to break long before that happens. */
	if (set->prime_index < set_num_primes) {
		set->table_size = set_primes[set->prime_index];
	} else {
		set->table_size = set->entries * 10;
	}

	/* Allocate the table and initialise to NULL */
	set->table = calloc(set->table_size, sizeof(SetEntry *));

	return set->table != NULL;
}"
set_free_entry,"Set *set, SetEntry *entry",,null,"
static void set_free_entry(Set *set, SetEntry *entry)
{
	/* If there is a free function registered, call it to free the
	 * data for this entry first */
	if (set->free_func != NULL) {
		set->free_func(entry->data);
	}

	/* Free the entry structure */
	free(entry);
}"
set_free,Set *set,,null,"
void set_free(Set *set)
{
	SetEntry *rover;
	SetEntry *next;
	unsigned int i;

	/* Free all entries in all chains */
	for (i = 0; i < set->table_size; ++i) {
		rover = set->table[i];

		while (rover != NULL) {
			next = rover->next;

			/* Free this entry */
			set_free_entry(set, rover);

			/* Advance to the next entry in the chain */
			rover = next;
		}
	}

	/* Free the table */
	free(set->table);

	/* Free the set structure */
	free(set);
}"
set_register_free_function,"Set *set, SetFreeFunc free_func",Free the set structure,null,"
void set_register_free_function(Set *set, SetFreeFunc free_func)
{
	set->free_func = free_func;
}"
set_enlarge,Set *set,,0 | 1,"
static int set_enlarge(Set *set)
{
	SetEntry *rover;
	SetEntry *next;
	SetEntry **old_table;
	unsigned int old_table_size;
	unsigned int old_prime_index;
	unsigned int index;
	unsigned int i;

	/* Store the old table */
	old_table = set->table;
	old_table_size = set->table_size;
	old_prime_index = set->prime_index;

	/* Use the next table size from the prime number array */
	++set->prime_index;

	/* Allocate the new table */
	if (!set_allocate_table(set)) {
		set->table = old_table;
		set->table_size = old_table_size;
		set->prime_index = old_prime_index;

		return 0;
	}

	/* Iterate through all entries in the old table and add them
	 * to the new one */
	for (i = 0; i < old_table_size; ++i) {

		/* Walk along this chain */
		rover = old_table[i];

		while (rover != NULL) {

			next = rover->next;

			/* Hook this entry into the new table */
			index = set->hash_func(rover->data) % set->table_size;
			rover->next = set->table[index];
			set->table[index] = rover;

			/* Advance to the next entry in the chain */
			rover = next;
		}
	}

	/* Free back the old table */
	free(old_table);

	/* Resized successfully */
	return 1;
}"
set_insert,"Set *set, SetValue data",Resized successfully,0 | 1,"
int set_insert(Set *set, SetValue data)
{
	SetEntry *newentry;
	SetEntry *rover;
	unsigned int index;

	/* The hash table becomes less efficient as the number of entries
	 * increases. Check if the percentage used becomes large. */
	if ((set->entries * 3) / set->table_size > 0) {

		/* The table is more than 1/3 full and must be increased
		 * in size */
		if (!set_enlarge(set)) {
			return 0;
		}
	}

	/* Use the hash of the data to determine an index to insert into the
	 * table at. */
	index = set->hash_func(data) % set->table_size;

	/* Walk along this chain and attempt to determine if this data has
	 * already been added to the table */
	rover = set->table[index];

	while (rover != NULL) {

		if (set->equal_func(data, rover->data) != 0) {

			/* This data is already in the set */
			return 0;
		}

		rover = rover->next;
	}

	/* Not in the set.  We must add a new entry. */
	/* Make a new entry for this data */
	newentry = (SetEntry *) malloc(sizeof(SetEntry));

	if (newentry == NULL) {
		return 0;
	}

	newentry->data = data;

	/* Link into chain */
	newentry->next = set->table[index];
	set->table[index] = newentry;

	/* Keep track of the number of entries in the set */
	++set->entries;

	/* Added successfully */
	return 1;
}"
set_remove,"Set *set, SetValue data",Added successfully,"*/
			set_free_entry(set, entry) | 1 | 0","
int set_remove(Set *set, SetValue data)
{
	SetEntry **rover;
	SetEntry *entry;
	unsigned int index;

	/* Look up the data by its hash key */
	index = set->hash_func(data) % set->table_size;

	/* Search this chain, until the corresponding entry is found */
	rover = &set->table[index];

	while (*rover != NULL) {
		if (set->equal_func(data, (*rover)->data) != 0) {

			/* Found the entry */
			entry = *rover;

			/* Unlink from the linked list */
			*rover = entry->next;

			/* Update counter */
			--set->entries;

			/* Free the entry and return */
			set_free_entry(set, entry);

			return 1;
		}

		/* Advance to the next entry */
		rover = &((*rover)->next);
	}

	/* Not found in set */
	return 0;
}"
set_query,"Set *set, SetValue data",Not found in set,1 | 0,"
int set_query(Set *set, SetValue data)
{
	SetEntry *rover;
	unsigned int index;

	/* Look up the data by its hash key */
	index = set->hash_func(data) % set->table_size;

	/* Search this chain, until the corresponding entry is found */
	rover = set->table[index];

	while (rover != NULL) {
		if (set->equal_func(data, rover->data) != 0) {

			/* Found the entry */
			return 1;
		}

		/* Advance to the next entry in the chain */
		rover = rover->next;
	}

	/* Not found */
	return 0;
}"
set_iterate,"Set *set, SetIterator *iter",,null,"
void set_iterate(Set *set, SetIterator *iter)
{
	unsigned int chain;

	iter->set = set;
	iter->next_entry = NULL;

	/* Find the first entry */
	for (chain = 0; chain < set->table_size; ++chain) {

		/* There is a value at the start of this chain */
		if (set->table[chain] != NULL) {
			iter->next_entry = set->table[chain];
			break;
		}
	}

	iter->next_chain = chain;
}"
set_iter_has_more,SetIterator *iterator,,iterator->next_entry != NULL,"
int set_iter_has_more(SetIterator *iterator)
{
	return iterator->next_entry != NULL;
}"
slist_free,SListEntry *list,Null value that can be returned without creating a local variable,null,"
void slist_free(SListEntry *list)
{
	SListEntry *entry;

	/* Iterate over each entry, freeing each list entry, until the
	 * end is reached */
	entry = list;

	while (entry != NULL) {
		SListEntry *next;

		next = entry->next;

		free(entry);

		entry = next;
	}
}"
slist_set_data,"SListEntry *listentry, SListValue data",,null,"
void slist_set_data(SListEntry *listentry, SListValue data)
{
	if (listentry != NULL) {
		listentry->data = data;
	}
}"
slist_remove_entry,"SListEntry **list, SListEntry *entry",,0 | 1,"
int slist_remove_entry(SListEntry **list, SListEntry *entry)
{
	SListEntry *rover;

	/* If the list is empty, or entry is NULL, always fail */
	if (*list == NULL || entry == NULL) {
		return 0;
	}

	/* Action to take is different if the entry is the first in the list */
	if (*list == entry) {

		/* Unlink the first entry and update the starting pointer */
		*list = entry->next;

	} else {

		/* Search through the list to find the preceding entry */
		rover = *list;

		while (rover != NULL && rover->next != entry) {
			rover = rover->next;
		}

		if (rover == NULL) {

			/* Not found in list */
			return 0;

		} else {

			/* rover->next now points at entry, so rover is the
			 * preceding entry. Unlink the entry from the list. */
			rover->next = entry->next;
		}
	}

	/* Free the list entry */
	free(entry);

	/* Operation successful */
	return 1;
}"
slist_sort,"SListEntry **list, SListCompareFunc compare_func",,null,"
void slist_sort(SListEntry **list, SListCompareFunc compare_func)
{
	slist_sort_internal(list, compare_func);
}"
slist_iterate,"SListEntry **list, SListIterator *iter",Not found,null,"
void slist_iterate(SListEntry **list, SListIterator *iter)
{
	/* Start iterating from the beginning of the list. */
	iter->prev_next = list;

	/* We have not yet read the first item. */
	iter->current = NULL;
}"
slist_iter_has_more,SListIterator *iter,We have not yet read the first item.,*iter->prev_next != NULL | iter->current->next != NULL,"
int slist_iter_has_more(SListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not read the first entry, the current
		 * item was removed or we have reached the end of the
		 * list.  Use prev_next to determine if we have a next
		 * value to iterate over. */
		return *iter->prev_next != NULL;

	} else {

		/* The current entry has not been deleted.  There
		 * is a next entry if current->next is not NULL. */
		return iter->current->next != NULL;
	}
}"
slist_iter_remove,SListIterator *iter,,null,"
void slist_iter_remove(SListIterator *iter)
{
	if (iter->current == NULL || iter->current != *iter->prev_next) {

		/* Either we have not yet read the first item, we have
		 * reached the end of the list, or we have already removed
		 * the current value.  Either way, do nothing. */
	} else {

		/* Remove the current entry */
		*iter->prev_next = iter->current->next;
		free(iter->current);
		iter->current = NULL;
	}
}"
sortedarray_index_of,"SortedArray *sortedarray, SortedArrayValue data",,-1 | (int) index,"int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)
{
	unsigned int left, right, index;
	int order;

	if (sortedarray == NULL) {
		return -1;
	}

	left = 0;
	right = sortedarray->length;
	index = 0;

	/* safe subtract 1 of right without going negative */
	right = (right > 1) ? right : 0;

	while (left != right) {
		index = (left + right) / 2;
		order = sortedarray->cmp_func(data, sortedarray->data[index]);

		if (order < 0) {
			/* value should be left */
			right = index;
		} else if (order > 0) {
			/* value should be right */
			left = index + 1;
		} else {
			return (int) index;
		}
	}

	return -1;
}"
sortedarray_clear,SortedArray *sortedarray,,null,"
void sortedarray_clear(SortedArray *sortedarray)
{
	/* set length to 0 */
	sortedarray->length = 0;
}"
trie_insert_rollback,"Trie *trie, unsigned char *key",,null,"static void trie_insert_rollback(Trie *trie, unsigned char *key)
{
	TrieNode *node;
	TrieNode **prev_ptr;
	TrieNode *next_node;
	TrieNode **next_prev_ptr;
	unsigned char *p;

	/* Follow the chain along.  We know that we will never reach the
	 * end of the string because trie_insert never got that far.  As a
	 * result, it is not necessary to check for the end of string
	 * delimiter (NUL) */
	node = trie->root_node;
	prev_ptr = &trie->root_node;
	p = key;

	while (node != NULL) {

		/* Find the next node now. We might free this node. */
		next_prev_ptr = &node->next[(unsigned char) *p];
		next_node = *next_prev_ptr;
		++p;

		/* Decrease the use count and free the node if it
		 * reaches zero. */
		--node->use_count;

		if (node->use_count == 0) {
			free(node);

			if (prev_ptr != NULL) {
				*prev_ptr = NULL;
			}

			next_prev_ptr = NULL;
		}

		/* Update pointers */
		node = next_node;
		prev_ptr = next_prev_ptr;
	}
}"
trie_value_is_null,TrieValue *v,,"!memcmp(v, &trie_null_value, sizeof(TrieValue))","
static int trie_value_is_null(TrieValue *v)
{
	return !memcmp(v, &trie_null_value, sizeof(TrieValue));
}"
trie_insert,"Trie *trie, char *key, TrieValue value",,"0 | success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value | 1","
int trie_insert(Trie *trie, char *key, TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	char *p;
	int c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end(trie, key);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = key;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie,
				                     (unsigned char *) key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) *p;

		/* Reached the end of string?  If so, we're finished. */
		if (c == '\0') {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}

int trie_insert_binary(Trie *trie, unsigned char *key, int key_length,
                       TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	int p, c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end_binary(trie, key, key_length);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = 0;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie, key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) key[p];

		/* Reached the end of string?  If so, we're finished. */
		if (p == key_length) {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}"
trie_insert_binary,"Trie *trie, unsigned char *key, int key_length, TrieValue value",,"0 | success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value | 1","
int trie_insert_binary(Trie *trie, unsigned char *key, int key_length,
                       TrieValue value)
{
	TrieNode **rover;
	TrieNode *node;
	int p, c;

	/* Cannot insert NULL values */
	if (trie_value_is_null(&value)) {
		return 0;
	}

	/* Search to see if this is already in the tree */
	node = trie_find_end_binary(trie, key, key_length);

	/* Already in the tree? If so, replace the existing value and
	 * return success. */
	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = value;
		return 1;
	}

	/* Search down the trie until we reach the end of string,
	 * creating nodes as necessary */
	rover = &trie->root_node;
	p = 0;

	for (;;) {

		node = *rover;

		if (node == NULL) {

			/* Node does not exist, so create it */
			node = (TrieNode *) calloc(1, sizeof(TrieNode));

			if (node == NULL) {

				/* Allocation failed.  Go back and undo
				 * what we have done so far. */
				trie_insert_rollback(trie, key);

				return 0;
			}

			node->data = trie_null_value;

			/* Link in to the trie */
			*rover = node;
		}

		/* Increase the node use count */
		++node->use_count;

		/* Current character */
		c = (unsigned char) key[p];

		/* Reached the end of string?  If so, we're finished. */
		if (p == key_length) {

			/* Set the data at the node we have reached */
			node->data = value;

			break;
		}

		/* Advance to the next node in the chain */
		rover = &node->next[c];
		++p;
	}

	return 1;
}

int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	int p, c;

	/* Find the end node and remove the value */
	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = 0;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) key[p];
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (p == key_length) {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}"
trie_remove_binary,"Trie *trie, unsigned char *key, int key_length",,0 | 1,"
int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	int p, c;

	/* Find the end node and remove the value */
	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = 0;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) key[p];
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (p == key_length) {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}

int trie_remove(Trie *trie, char *key)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	char *p;
	int c;

	/* Find the end node and remove the value */
	node = trie_find_end(trie, key);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = key;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) *p;
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (c == '\0') {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}"
trie_remove,"Trie *trie, char *key",Removed successfully,0 | 1 | node->data | trie_null_value | trie->root_node->use_count,"
int trie_remove(Trie *trie, char *key)
{
	TrieNode *node;
	TrieNode *next;
	TrieNode **last_next_ptr;
	char *p;
	int c;

	/* Find the end node and remove the value */
	node = trie_find_end(trie, key);

	if (node != NULL && !trie_value_is_null(&node->data)) {
		node->data = trie_null_value;
	} else {
		return 0;
	}

	/* Now traverse the tree again as before, decrementing the use
	 * count of each node.  Free back nodes as necessary. */
	node = trie->root_node;
	last_next_ptr = &trie->root_node;
	p = key;

	for (;;) {

		/* Find the next node */
		c = (unsigned char) *p;
		next = node->next[c];

		/* Free this node if necessary */
		--node->use_count;

		if (node->use_count <= 0) {
			free(node);

			/* Set the ""next"" pointer on the previous node to NULL,
			 * to unlink the freed node from the tree.  This only
			 * needs to be done once in a remove.  After the first
			 * unlink, all further nodes are also going to be
			 * free'd. */
			if (last_next_ptr != NULL) {
				*last_next_ptr = NULL;
				last_next_ptr = NULL;
			}
		}

		/* Go to the next character or finish */
		if (c == '\0') {
			break;
		} else {
			++p;
		}

		/* If necessary, save the location of the ""next"" pointer
		 * so that it may be set to NULL on the next iteration if
		 * the next node visited is freed. */
		if (last_next_ptr != NULL) {
			last_next_ptr = &node->next[c];
		}

		/* Jump to the next node */
		node = next;
	}

	/* Removed successfully */
	return 1;
}

TrieValue trie_lookup(Trie *trie, char *key)
{
	TrieNode *node;

	node = trie_find_end(trie, key);

	if (node != NULL) {
		return node->data;
	} else {
		return trie_null_value;
	}
}

TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)
{
	TrieNode *node;

	node = trie_find_end_binary(trie, key, key_length);

	if (node != NULL) {
		return node->data;
	} else {
		return trie_null_value;
	}
}

unsigned int trie_num_entries(Trie *trie)
{
	/* To find the number of entries, simply look at the use count
	 * of the root node. */
	if (trie->root_node == NULL) {
		return 0;
	} else {
		return trie->root_node->use_count;
	}
}
"
alloc_test_overwrite,"void *ptr, size_t length, unsigned int pattern",,null,"static void alloc_test_overwrite(void *ptr, size_t length, unsigned int pattern)
{
	unsigned char *byte_ptr;
	int pattern_seq;
	unsigned char b;
	size_t i;

	byte_ptr = ptr;

	for (i = 0; i < length; ++i) {
		pattern_seq = (int) (i & 3);
		b = (unsigned char) ((pattern >> (8 * pattern_seq)) & 0xff);
		byte_ptr[i] = b;
	}
}"
alloc_test_malloc,size_t bytes,,"NULL | the block itself */
	return header + 1","void *alloc_test_malloc(size_t bytes)
{
	BlockHeader *header;
	void *ptr;

	/* Check if we have reached the allocation limit. */
	if (allocation_limit == 0) {
		return NULL;
	}

	/* Allocate the requested block with enough room for the block header
	 * as well. */
	header = malloc(sizeof(BlockHeader) + bytes);

	if (header == NULL) {
		return NULL;
	}

	header->magic_number = ALLOC_TEST_MAGIC;
	header->bytes = bytes;

	/* Fill memory with MALLOC_PATTERN, to ensure that code under test
	 * does not rely on memory being initialised to zero. */
	ptr = header + 1;
	alloc_test_overwrite(ptr, bytes, MALLOC_PATTERN);

	/* Update counter */
	allocated_bytes += bytes;

	/* Decrease the allocation limit */
	if (allocation_limit > 0) {
		--allocation_limit;
	}

	/* Skip past the header and return the block itself */
	return header + 1;
}"
alloc_test_free,void *ptr,,null,"void alloc_test_free(void *ptr)
{
	BlockHeader *header;
	size_t block_size;

	/* Must accept NULL as a valid pointer to free. */
	if (ptr == NULL) {
		return;
	}

	/* Get the block header and do a sanity check */
	header = alloc_test_get_header(ptr);
	block_size = header->bytes;
	assert(allocated_bytes >= block_size);

	/* Trash the allocated block to foil any code that relies on memory
	 * that has been freed. */
	alloc_test_overwrite(ptr, header->bytes, FREE_PATTERN);

	/* Trash the magic number in the block header to stop the same block
	 * from being freed again. */
	header->magic_number = 0;

	/* Free the allocated memory. */
	free(header);

	/* Update counter */
	allocated_bytes -= block_size;
}"
alloc_test_realloc,"void *ptr, size_t bytes",Update counter,NULL | new_ptr,"
void *alloc_test_realloc(void *ptr, size_t bytes)
{
	BlockHeader *header;
	void *new_ptr;
	size_t bytes_to_copy;

	/* Allocate the new block */
	new_ptr = alloc_test_malloc(bytes);

	if (new_ptr == NULL) {
		return NULL;
	}

	/* Copy over the old data and free the old block, if there was any. */
	if (ptr != NULL) {
		header = alloc_test_get_header(ptr);

		bytes_to_copy = header->bytes;

		if (bytes_to_copy > bytes) {
			bytes_to_copy = bytes;
		}

		memcpy(new_ptr, ptr, bytes_to_copy);

		alloc_test_free(ptr);
	}

	return new_ptr;
}"
alloc_test_calloc,"size_t nmemb, size_t bytes",,NULL | result,"
void *alloc_test_calloc(size_t nmemb, size_t bytes)
{
	void *result;
	size_t total_bytes = nmemb * bytes;

	/* Allocate the block. */
	result = alloc_test_malloc(total_bytes);

	if (result == NULL) {
		return NULL;
	}

	/* Initialise to zero. */
	memset(result, 0, total_bytes);

	return result;
}"
alloc_test_strdup,const char *string,,NULL | result,"
char *alloc_test_strdup(const char *string)
{
	char *result;

	result = alloc_test_malloc(strlen(string) + 1);

	if (result == NULL) {
		return NULL;
	}

	strcpy(result, string);

	return result;
}"
alloc_test_set_limit,signed int alloc_count,,null,"
void alloc_test_set_limit(signed int alloc_count)
{
	allocation_limit = alloc_count;
}"
alloc_test_get_allocated,,,allocated_bytes,"
size_t alloc_test_get_allocated(void)
{
	return allocated_bytes;
}"
run_test,UnitTestFunction test,,null,"static void run_test(UnitTestFunction test)
{
	/* Turn off any allocation limits that may have been set
	 * by a previous test. */
	alloc_test_set_limit(-1);

	/* Run the test */
	test();

	/* Check that all memory was correctly freed back during
	 * the test. */
	assert(alloc_test_get_allocated() == 0);
}"
run_tests,UnitTestFunction *tests,"Check that all memory was correctly freed back during
the test.",null,"
void run_tests(UnitTestFunction *tests)
{
	int i;

	for (i = 0; tests[i] != NULL; ++i) {
		run_test(tests[i]);
	}
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
print_tree,"AVLTreeNode *node, int depth",,null,"static void print_tree(AVLTreeNode *node, int depth)
{
	int *value;
	int i;

	if (node == NULL) {
		return;
	}

	print_tree(avl_tree_node_child(node, AVL_TREE_NODE_LEFT), depth + 1);

	for (i=0; i<depth*6; ++i) {
		printf("" "");
	}

	value = avl_tree_node_key(node);
	printf(""%i\n"", *value);

	print_tree(avl_tree_node_child(node, AVL_TREE_NODE_RIGHT), depth + 1);
}"
find_subtree_height,AVLTreeNode *node,,0 | left_height + 1 | right_height + 1,"
int find_subtree_height(AVLTreeNode *node)
{
	AVLTreeNode *left_subtree;
	AVLTreeNode *right_subtree;
	int left_height, right_height;

	if (node == NULL) {
		return 0;
	}

	left_subtree = avl_tree_node_child(node, AVL_TREE_NODE_LEFT);
	right_subtree = avl_tree_node_child(node, AVL_TREE_NODE_RIGHT);
	left_height = find_subtree_height(left_subtree);
	right_height = find_subtree_height(right_subtree);

	if (left_height > right_height) {
		return left_height + 1;
	} else {
		return right_height + 1;
	}
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);
	return 0;
}"
test_out_of_memory,,,null,"void test_out_of_memory(void)
{
	BinaryHeap *heap;
	int *value;
	int values[] = {
	    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
	};
	int i;

	/* Allocate a heap and fill to the default limit */
	heap = binary_heap_new(BINARY_HEAP_TYPE_MIN, int_compare);

	alloc_test_set_limit(0);

	for (i = 0; i < 16; ++i) {
		assert(binary_heap_insert(heap, &values[i]) != 0);
	}

	assert(binary_heap_num_entries(heap) == 16);

	/* Check that we cannot add new values */
	for (i = 0; i < 16; ++i) {
		assert(binary_heap_insert(heap, &values[i]) == 0);
		assert(binary_heap_num_entries(heap) == 16);
	}

	/* Check that we can read the values back out again and they
	 * are in the right order. */
	for (i = 0; i < 16; ++i) {
		value = binary_heap_pop(heap);
		assert(*value == i);
	}

	assert(binary_heap_num_entries(heap) == 0);

	binary_heap_free(heap);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
verify_heap,BinomialHeap *heap,,null,"static void verify_heap(BinomialHeap *heap)
{
	unsigned int num_vals;
	int *val;
	int i;

	num_vals = binomial_heap_num_entries(heap);
	assert(num_vals == NUM_TEST_VALUES - 1);

	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		if (i == TEST_VALUE) {
			continue;
		}

		/* Pop off the next value and check it */
		val = binomial_heap_pop(heap);
		assert(*val == i);

		/* Decrement num values counter */
		--num_vals;
		assert(binomial_heap_num_entries(heap) == num_vals);
	}
}"
test_insert_out_of_memory,,,null,"static void test_insert_out_of_memory(void)
{
	BinomialHeap *heap;
	int i;

	/* There are various memory allocations performed during the insert;
	 * probe at different limit levels to catch them all. */
	for (i = 0; i < 6; ++i) {
		heap = generate_heap();

		/* Insert should fail */
		alloc_test_set_limit(i);
		test_array[TEST_VALUE] = TEST_VALUE;
		assert(binomial_heap_insert(heap, &test_array[TEST_VALUE]) ==
		       0);
		alloc_test_set_limit(-1);

		/* Check that the heap is unharmed */
		verify_heap(heap);

		binomial_heap_free(heap);
	}
}"
test_pop_out_of_memory,,,null,"void test_pop_out_of_memory(void)
{
	BinomialHeap *heap;
	int i;

	/* There are various memory allocations performed as part of the merge
	 * done during the pop.  Probe at different limit levels to catch them
	 * all. */
	for (i = 0; i < 6; ++i) {
		heap = generate_heap();

		/* Pop should fail */
		alloc_test_set_limit(i);
		assert(binomial_heap_pop(heap) == NULL);
		alloc_test_set_limit(-1);

		/* Check the heap is unharmed */
		binomial_heap_free(heap);
	}
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_bloom_filter_mismatch,,,null,"void test_bloom_filter_mismatch(void)
{
	BloomFilter *filter1;
	BloomFilter *filter2;

	/* Create one filter with both values set */
	filter1 = bloom_filter_new(128, string_hash, 4);

	/* Different buffer size. */
	filter2 = bloom_filter_new(64, string_hash, 4);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	/* Different hash function */
	filter2 = bloom_filter_new(128, string_nocase_hash, 4);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	/* Different number of salts */
	filter2 = bloom_filter_new(128, string_hash, 32);
	assert(bloom_filter_intersection(filter1, filter2) == NULL);
	assert(bloom_filter_union(filter1, filter2) == NULL);
	bloom_filter_free(filter2);

	bloom_filter_free(filter1);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_hash_table_new_free,,,null,"void test_hash_table_new_free(void)
{
	HashTable *hash_table;

	hash_table = hash_table_new(int_hash, int_equal);

	assert(hash_table != NULL);

	/* Add some values */
	hash_table_insert(hash_table, &value1, &value1);
	hash_table_insert(hash_table, &value2, &value2);
	hash_table_insert(hash_table, &value3, &value3);
	hash_table_insert(hash_table, &value4, &value4);

	/* Free the hash table */
	hash_table_free(hash_table);

	/* Test out of memory scenario */
	alloc_test_set_limit(0);
	hash_table = hash_table_new(int_hash, int_equal);
	assert(hash_table == NULL);
	assert(alloc_test_get_allocated() == 0);

	alloc_test_set_limit(1);
	hash_table = hash_table_new(int_hash, int_equal);
	assert(hash_table == NULL);
	assert(alloc_test_get_allocated() == 0);
}"
test_hash_table_insert_lookup,,,null,"void test_hash_table_insert_lookup(void)
{
	HashTable *hash_table;
	char buf[10];
	char *value;
	int i;

	/* Generate a hash table */
	hash_table = generate_hash_table();

	assert(hash_table_num_entries(hash_table) == NUM_TEST_VALUES);

	/* Check all values */
	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		sprintf(buf, ""%i"", i);
		value = hash_table_lookup(hash_table, buf);

		assert(strcmp(value, buf) == 0);
	}

	/* Lookup on invalid values returns NULL */
	sprintf(buf, ""%i"", -1);
	assert(hash_table_lookup(hash_table, buf) == NULL);
	sprintf(buf, ""%i"", NUM_TEST_VALUES);
	assert(hash_table_lookup(hash_table, buf) == NULL);

	/* Insert overwrites existing entries with the same key */
	sprintf(buf, ""%i"", 12345);
	hash_table_insert(hash_table, buf, strdup(""hello world""));
	value = hash_table_lookup(hash_table, buf);
	assert(strcmp(value, ""hello world"") == 0);

	hash_table_free(hash_table);
}"
test_hash_table_iterating_remove,,,null,"void test_hash_table_iterating_remove(void)
{
	HashTable *hash_table;
	HashTableIterator iterator;
	char buf[10];
	char *val;
	HashTablePair pair;
	int count;
	unsigned int removed;
	int i;

	hash_table = generate_hash_table();

	/* Iterate over all values in the table */
	count = 0;
	removed = 0;

	hash_table_iterate(hash_table, &iterator);

	while (hash_table_iter_has_more(&iterator)) {

		/* Read the next value */
		pair = hash_table_iter_next(&iterator);
		val = pair.value;

		/* Remove every hundredth entry */
		if ((atoi(val) % 100) == 0) {
			hash_table_remove(hash_table, val);
			++removed;
		}

		++count;
	}

	/* Check counts */
	assert(removed == 100);
	assert(count == NUM_TEST_VALUES);

	assert(hash_table_num_entries(hash_table) == NUM_TEST_VALUES - removed);

	/* Check all entries divisible by 100 were really removed */
	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		sprintf(buf, ""%i"", i);

		if (i % 100 == 0) {
			assert(hash_table_lookup(hash_table, buf) == NULL);
		} else {
			assert(hash_table_lookup(hash_table, buf) != NULL);
		}
	}

	hash_table_free(hash_table);
}"
new_key,int value,,result,"int *new_key(int value)
{
	int *result;

	result = malloc(sizeof(int));
	*result = value;

	++allocated_keys;

	return result;
}"
free_key,void *key,,null,"void free_key(void *key)
{
	free(key);

	--allocated_keys;
}"
new_value,int value,,result,"int *new_value(int value)
{
	int *result;

	result = malloc(sizeof(int));
	*result = value;

	++allocated_values;

	return result;
}"
free_value,void *value,,null,"void free_value(void *value)
{
	free(value);

	--allocated_values;
}"
test_hash_table_free_functions,,,null,"void test_hash_table_free_functions(void)
{
	HashTable *hash_table;
	int *key;
	int *value;
	int i;

	/* Create a hash table, fill it with values */
	hash_table = hash_table_new(int_hash, int_equal);

	hash_table_register_free_functions(hash_table, free_key, free_value);

	allocated_values = 0;

	for (i = 0; i < NUM_TEST_VALUES; ++i) {
		key = new_key(i);
		value = new_value(99);

		hash_table_insert(hash_table, key, value);
	}

	assert(allocated_keys == NUM_TEST_VALUES);
	assert(allocated_values == NUM_TEST_VALUES);

	/* Check that removing a key works */
	i = NUM_TEST_VALUES / 2;
	hash_table_remove(hash_table, &i);

	assert(allocated_keys == NUM_TEST_VALUES - 1);
	assert(allocated_values == NUM_TEST_VALUES - 1);

	/* Check that replacing an existing key works */
	key = new_key(NUM_TEST_VALUES / 3);
	value = new_value(999);

	assert(allocated_keys == NUM_TEST_VALUES);
	assert(allocated_values == NUM_TEST_VALUES);

	hash_table_insert(hash_table, key, value);

	assert(allocated_keys == NUM_TEST_VALUES - 1);
	assert(allocated_values == NUM_TEST_VALUES - 1);

	/* A free of the hash table should free all of the keys and values */
	hash_table_free(hash_table);

	assert(allocated_keys == 0);
	assert(allocated_values == 0);
}"
test_hash_table_out_of_memory,,,null,"void test_hash_table_out_of_memory(void)
{
	HashTable *hash_table;
	int values[66];
	unsigned int i;

	hash_table = hash_table_new(int_hash, int_equal);

	/* Test normal failure */
	alloc_test_set_limit(0);
	values[0] = 0;
	assert(hash_table_insert(hash_table, &values[0], &values[0]) == 0);
	assert(hash_table_num_entries(hash_table) == 0);

	alloc_test_set_limit(-1);

	/* Test failure when increasing table size.
	 * The initial table size is 193 entries.  The table increases in
	 * size when 1/3 full, so the 66th entry should cause the insert
	 * to fail.
	 */
	for (i = 0; i < 65; ++i) {
		values[i] = (int) i;

		assert(hash_table_insert(hash_table, &values[i], &values[i]) !=
		       0);
		assert(hash_table_num_entries(hash_table) == i + 1);
	}

	assert(hash_table_num_entries(hash_table) == 65);

	/* Test the 66th insert */
	alloc_test_set_limit(0);

	values[65] = 65;

	assert(hash_table_insert(hash_table, &values[65], &values[65]) == 0);
	assert(hash_table_num_entries(hash_table) == 65);

	hash_table_free(hash_table);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_list_iterate_bad_remove,,,null,"void test_list_iterate_bad_remove(void)
{
	ListEntry *list;
	ListIterator iter;
	int values[49];
	int i;
	int *val;

	/* Create a list with 49 entries */
	list = NULL;

	for (i = 0; i < 49; ++i) {
		values[i] = i;
		assert(list_prepend(&list, &values[i]) != NULL);
	}

	/* Iterate over the list, removing each element in turn.  We
	 * use an odd number of list elements so that the first and
	 * last entries are removed. */
	list_iterate(&list, &iter);

	while (list_iter_has_more(&iter)) {
		val = list_iter_next(&iter);

		/* Remove all the even numbers. Check that list_iter_remove
		 * can cope with the fact that the current element has
		 * already been removed. */
		if ((*val % 2) == 0) {
			assert(list_remove_data(&list, int_equal, val) != 0);
			list_iter_remove(&iter);
		}
	}

	list_free(list);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_queue_new_free,,,null,"void test_queue_new_free(void)
{
	int i;
	Queue *queue;

	/* Create and destroy a queue */
	queue = queue_new();

	queue_free(queue);

	/* Add lots of values and then destroy */
	queue = queue_new();

	for (i = 0; i < 1000; ++i) {
		queue_push_head(queue, &variable1);
	}

	queue_free(queue);

	/* Test allocation when there is no free memory */
	alloc_test_set_limit(0);
	queue = queue_new();
	assert(queue == NULL);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
print_tree,"RBTreeNode *node, int depth",,null,"static void print_tree(RBTreeNode *node, int depth)
{
	int *value;
	int i;

	if (node == NULL) {
		return;
	}

	print_tree(rb_tree_node_child(node, RB_TREE_NODE_LEFT), depth + 1);

	for (i=0; i<depth*6; ++i) {
		printf("" "");
	}

	value = rb_tree_node_key(node);
	printf(""%i\n"", *value);

	print_tree(rb_tree_node_child(node, RB_TREE_NODE_RIGHT), depth + 1);
}"
find_subtree_height,RBTreeNode *node,,0 | left_height + 1 | right_height + 1,"
int find_subtree_height(RBTreeNode *node)
{
	RBTreeNode *left_subtree;
	RBTreeNode *right_subtree;
	int left_height, right_height;

	if (node == NULL) {
		return 0;
	}

	left_subtree = rb_tree_node_child(node, RB_TREE_NODE_LEFT);
	right_subtree = rb_tree_node_child(node, RB_TREE_NODE_RIGHT);
	left_height = find_subtree_height(left_subtree);
	right_height = find_subtree_height(right_subtree);

	if (left_height > right_height) {
		return left_height + 1;
	} else {
		return right_height + 1;
	}
}"
validate_tree,RBTree *tree,,null,"
void validate_tree(RBTree *tree)
{
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);
	return 0;
}"
test_set_iterating_remove,,,null,"void test_set_iterating_remove(void)
{
	Set *set;
	SetIterator iterator;
	int count;
	unsigned int removed;
	char *value;

	set = generate_set();

	count = 0;
	removed = 0;

	/* Iterate over all values in the set */
	set_iterate(set, &iterator);

	while (set_iter_has_more(&iterator)) {

		value = set_iter_next(&iterator);

		if ((atoi(value) % 100) == 0) {

			/* Remove this value */
			set_remove(set, value);

			++removed;
		}

		++count;
	}

	/* Check final counts */
	assert(count == 10000);
	assert(removed == 100);
	assert(set_num_entries(set) == 10000 - removed);

	set_free(set);
}"
test_set_out_of_memory,,,null,"void test_set_out_of_memory(void)
{
	Set *set;
	int values[66];
	unsigned int i;

	set = set_new(int_hash, int_equal);

	/* Test normal failure */
	alloc_test_set_limit(0);
	values[0] = 0;
	assert(set_insert(set, &values[0]) == 0);
	assert(set_num_entries(set) == 0);

	alloc_test_set_limit(-1);

	/* Test failure when increasing table size.
	 * The initial table size is 193 entries.  The table increases in
	 * size when 1/3 full, so the 66th entry should cause the insert
	 * to fail. */
	for (i = 0; i < 65; ++i) {
		values[i] = (int) i;

		assert(set_insert(set, &values[i]) != 0);
		assert(set_num_entries(set) == i + 1);
	}

	assert(set_num_entries(set) == 65);

	/* Test the 66th insert */
	alloc_test_set_limit(0);

	values[65] = 65;

	assert(set_insert(set, &values[65]) == 0);
	assert(set_num_entries(set) == 65);

	set_free(set);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_slist_iterate_bad_remove,,,null,"void test_slist_iterate_bad_remove(void)
{
	SListEntry *list;
	SListIterator iter;
	int values[49];
	int i;
	int *val;

	/* Create a list with 49 entries */
	list = NULL;

	for (i = 0; i < 49; ++i) {
		values[i] = i;
		slist_prepend(&list, &values[i]);
	}

	/* Iterate over the list, removing each element in turn.  We
	 * use an odd number of list elements so that the first and
	 * last entries are removed. */
	slist_iterate(&list, &iter);

	while (slist_iter_has_more(&iter)) {
		val = slist_iter_next(&iter);

		/* Remove all the even numbers. Check that slist_iter_remove
		 * can cope with the fact that the current element has
		 * already been removed. */
		if ((*val % 2) == 0) {
			assert(slist_remove_data(&list, int_equal, val) != 0);
			slist_iter_remove(&iter);
		}
	}

	slist_free(list);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
test_trie_negative_keys,,,null,"static void test_trie_negative_keys(void)
{
	char my_key[] = {'a', 'b', 'c', -50, -20, '\0'};
	Trie *trie;
	void *value;

	trie = trie_new();

	assert(trie_insert(trie, my_key, ""hello world"") != 0);

	value = trie_lookup(trie, my_key);

	assert(!strcmp(value, ""hello world""));

	assert(trie_remove(trie, my_key) != 0);
	assert(trie_remove(trie, my_key) == 0);
	assert(trie_lookup(trie, my_key) == NULL);

	trie_free(trie);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
	run_tests(tests);

	return 0;
}"
