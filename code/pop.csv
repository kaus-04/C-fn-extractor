fn_name,parameters,description,return_statement,c_implementation
spirograph,"double *x, double *y, double l, double k, size_t N, double rot",,null,"void spirograph(double *x, double *y, double l, double k, size_t N, double rot)
{
    double dt = rot * 2.f * M_PI / N;
    double t = 0.f, R = 1.f;
    const double k1 = 1.f - k;

    for (size_t dk = 0; dk < N; dk++, t += dt)
    {
        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));
        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));
    }
}"
test,,,null,"void test(void)
{
    size_t N = 500;
    double l = 0.3, k = 0.75, rot = 10.;
    char fname[50];
    snprintf(fname, 50, ""spirograph_%.2f_%.2f_%.2f.csv"", l, k, rot);
    FILE *fp = fopen(fname, ""wt"");
    if (!fp)
    {
        perror(fname);
        exit(EXIT_FAILURE);
    }

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l, k, N, rot);

    for (size_t i = 0; i < N; i++)
    {
        fprintf(fp, ""%.5g, %.5g"", x[i], y[i]);
        if (i < N - 1)
        {
            fputc('\n', fp);
        }
    }

    fclose(fp);

    free(x);
    free(y);
}"
display_graph,"const double *x, const double *y, size_t N, double l, double k",,null,"void display_graph(const double *x, const double *y, size_t N, double l,
                   double k)
{
    glClearColor(1.0f, 1.0f, 1.0f,
                 0.0f);            // Set background color to white and opaque
    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)

    if (x && y)
    {
        glBegin(GL_LINES);         // draw line segments
        glColor3f(0.f, 0.f, 1.f);  // blue
        glPointSize(2.f);          // point size in pixels

        for (size_t i = 1; i < N; i++)
        {
            glVertex2f(x[i - 1], y[i - 1]);  // line from
            glVertex2f(x[i], y[i]);          // line to
        }
        glEnd();
    }
    glColor3f(0.f, 0.f, 0.f);
    char buffer[20];
    snprintf(buffer, 20, ""l = %.3f"", l);
    glRasterPos2f(-.85, .85);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);
    snprintf(buffer, 20, ""k = %.3f"", k);
    glRasterPos2f(-.85, .75);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);

    glutSwapBuffers();
}"
test2,,,null,"void test2(void)
{
    const size_t N = 1000;  // number of samples

    static bool direction1 = true;  // increment if true, otherwise decrement
    static bool direction2 = true;  // increment if true, otherwise decrement

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l_ratio, k_ratio, N, num_rot);
    display_graph(x, y, N, l_ratio, k_ratio);

    free(x);  // free dynamic memories
    free(y);

    if (paused)
        // if paused, do not update l_ratio and k_ratio
        return;

    if (direction1)  // increment k_ratio
    {
        if (k_ratio >= (1.f - step))  // maximum limit
            direction1 = false;       // reverse direction of k_ratio
        else
            k_ratio += step;
    }
    else  // decrement k_ratio
    {
        if (k_ratio <= step)  // minimum limit
        {
            direction1 = true;  // reverse direction of k_ratio

            if (direction2)  // increment l_ratio
            {
                if (l_ratio >= (1.f - step))  // max limit of l_ratio
                    direction2 = false;       // reverse direction of l_ratio
                else
                    l_ratio += step;
            }
            else  // decrement l_ratio
            {
                if (l_ratio <= step)    // minimum limit of l_ratio
                    direction2 = true;  // reverse direction of l_ratio
                else
                    l_ratio -= step;
            }
        }
        else  // no min limit of k_ratio
            k_ratio -= step;
    }
}"
timer_cb,int id,,null,"void timer_cb(int id)
{
    glutPostRedisplay();
    glutTimerFunc(animation_speed, timer_cb, 0);
}"
keyboard_cb,"unsigned char key, int x, int y",,null,"void keyboard_cb(unsigned char key, int x, int y)
{
    switch (key)
    {
    case ' ':              // spacebar toggles pause
        paused = !paused;  // toggle
        break;
    case '+':  // up arrow key
        k_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '_':  // down arrow key
        k_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '=':  // left arrow key
        l_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '-':  // right arrow key
        l_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case 0x1B:  // escape key exits
        exit(EXIT_SUCCESS);
    }
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    test();

#ifdef USE_GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutCreateWindow(""Spirograph"");
    glutInitWindowSize(400, 400);
    // glutIdleFunc(glutPostRedisplay);
    glutTimerFunc(animation_speed, timer_cb, 0);
    glutKeyboardFunc(keyboard_cb);
    glutDisplayFunc(test2);
    glutMainLoop();
#endif

    return 0;
}"
longestSub,"int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH",,null,"
void longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)
{  // RESULT and RESULT_LENGTH will be modified by their pointers

    if (ARRAY_LENGTH <= 1)
    {
        *RESULT = ARRAY;
        *RESULT_LENGTH = ARRAY_LENGTH;
    }
    else
    {
        int PIVOT = ARRAY[0];
        int *LONGEST_SUB = NULL;
        int i, j, LONGEST_SUB_LENGTH = 0;
        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;

        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] < PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH = 0;
                TEMPORARY_ARRAY = NULL;

                for (j = i + 1; j < ARRAY_LENGTH; j++)
                {
                    if (ARRAY[j] >= ARRAY[i])
                    {
                        TEMPORARY_ARRAY_LENGTH++;
                        TEMPORARY_ARRAY = (int *)realloc(
                            TEMPORARY_ARRAY,
                            TEMPORARY_ARRAY_LENGTH * sizeof(int));
                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];
                    }
                }

                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,
                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);
                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)
                {
                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
                    LONGEST_SUB = (int *)realloc(
                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
                    LONGEST_SUB[0] = ARRAY[i];

                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
                }
            }
        }

        TEMPORARY_ARRAY = NULL;
        TEMPORARY_ARRAY_LENGTH = 0;
        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] >= PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH++;
                TEMPORARY_ARRAY = (int *)realloc(
                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));
                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];
            }
        }

        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,
                   &TEMPORARY_ARRAY_LENGTH);
        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)
        {
            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
            LONGEST_SUB =
                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
            LONGEST_SUB[0] = PIVOT;
            for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
        }
        *RESULT = LONGEST_SUB;
        *RESULT_LENGTH = LONGEST_SUB_LENGTH;
    }
}"
main,,,0,"
int main()
{
    int EXAMPLE_LENGTH = 8;
    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};

    int *RESULT = NULL;
    int RESULT_LENGTH, i;

    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);

    printf(""Longest Sub Sequence length: %d and it's:\n"", RESULT_LENGTH);
    for (i = 0; i < RESULT_LENGTH; i++) printf(""%d "", RESULT[i]);
    printf(""\n"");

    return 0;
}"
ways,"int n, int *a, int k",,"0 | 1 | ways(n, a, k - 1) + ways(n - a[k - 1], a, k)","
int ways(int n, int *a, int k)
{
    if (n < 0 || k < 0)
        return 0;
    if (n == 0)
        return 1;
    if (k == 0)
        return 0;
    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);
}"
main,,,0,"
int main()
{
    int m;
    int t;
    int n;

    printf(""Number of coins? "");
    scanf(""%d"", &m);
    int *coin = (int *)malloc(m * sizeof(int)), i;
    for (i = 0; i < m; i++)
    {
        printf(""coin? "");
        scanf(""%d"", &coin[i]);
    }

    printf(""---- your requests --- \n"");
    while (1)
    {
        printf(""amount? exit(0) "");
        scanf(""%d"", &n);
        if (!n)
        {
            break;
        }
        printf(""%d\n"", ways(n, coin, m));
    }

    free(coin);
    return 0;
}"
swap,"char *left, char *right",,null,"
void swap(char *left, char *right)
{
    char temp = *left;
    *left = *right;
    *right = temp;
}"
compare,"const void *a, const void *b",,(*(char *)a - *(char *)b),"
int compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }"
PrintSortedPermutations,char *str,,null,"
void PrintSortedPermutations(char *str)
{
    int strSize = strlen(str);
    qsort(str, strSize, sizeof(char), compare);

    int largerPermFound = 1;
    do
    {
        // 1. Print permutation
        printf(""%s\n"", str);
        // 2. Find rightmost char that is smaller than char to its right
        int i;
        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)
        {
        }

        // if we couldn't find one, we're finished, else we can swap
        if (i >= 0)
        {
            // 3. find character at index j such that str[j] = min(str[k]) &&
            // str[k] > str[i] for all k > i
            int j = i + 1, k;
            for (k = j; k < strSize && str[k]; k++)
            {
                if (str[k] > str[i] && str[k] < str[j])
                    j = k;
            }
            // 3. Swap chars at i and j
            swap(&str[i], &str[j]);
            // 4. Sort string to the right of i
            qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);
        }
        else
            largerPermFound = 0;
    } while (largerPermFound);
}"
main,,,-1 | 0,"
int main()
{
    int n;  // size of string
    scanf(""%d\n"", &n);
    if (n <= 0 || n >= 1000)
    {
        perror(""Input number out of range: >0 and <1000\n"");
        return -1;
    }
    char *str = (char *)malloc(n * sizeof(char));
    scanf(""%s"", str);
    PrintSortedPermutations(str);
    free(str);
    return 0;
}"
isLiteral,const char ch,,!(ch == '(' || ch == ')' || ch == '*' || ch == '\n' || ch == '|'),"int isLiteral(const char ch) {
    return !(ch == '(' || ch == ')' || ch == '*' || ch == '\n' || ch == '|');
}"
preProcessing,const char* input,,str,"char* preProcessing(const char* input) {
    const size_t len = strlen(input);
    if(len == 0) {
        char* str = malloc(1);
        str[0] = '\0';
        return str;
    }

    char* str = malloc(len * 2);
    size_t op = 0;

    for (size_t i = 0; i < len - 1; ++i) {
        char c = input[i];
        str[op++] = c;
        // one character lookahead
        char c1 = input[i + 1];

        if( (isLiteral(c) && isLiteral(c1)) ||
            (isLiteral(c) && c1 == '(') ||
            (c == ')' && c1 == '(') ||
            (c == ')' && isLiteral(c1)) ||
            (c == '*' && isLiteral(c1)) ||
            (c == '*' && c1 == '(')
                ) {
            // '\n' is used to represent concatenation
            // in this implementation
            str[op++] = '\n';
        }
    }

    str[op++] = input[len - 1];
    str[op] = '\0';
    return str;
}"
indexOf,"const char* str, char key",,i | 0,"size_t indexOf(const char* str, char key) {
    int depth = 0;

    for (size_t i = 0; i < strlen(str); ++i) {
        const char c = str[i];

        if(depth == 0 && c == key) {
            return i;
        }
        if(c == '(') depth++;
        if(c == ')') depth--;
    }
    // Due to the way this function is intended to be used,
    // it's safe to assume the character will not appear as
    // the string's first character
    // thus `0` is used as the `not found` value
    return 0;
}"
subString,"const char* str, size_t begin, size_t end",,res,"char* subString(const char* str, size_t begin, size_t end) {
    char* res = malloc(end - begin + 2);
    strncpy(res, str + begin, end - begin + 1);
    res[end - begin + 1] = '\0';
    return res;
}"
buildAST,const char* input,,node,"struct ASTNode* buildAST(const char* input) {

    struct ASTNode* node = createNode('\0');
    node->left = NULL;
    node->right = NULL;
    const size_t len = strlen(input);
    size_t index;

    // Empty input
    if(len == 0) return node;

    // Character literals
    if(len == 1) {
        node->content = input[0];
        return node;
    }

    // Discard parentheses
    if(input[0] == '(' && input[len - 1] == ')') {
        char* temp = subString(input, 1, len - 2);
        destroyNode(node);
        node = buildAST(temp);

        free(temp);
        return node;
    }

    // Union
    index = indexOf(input, '|');
    if(index) {
        node->content = '|';

        char* temp1 = subString(input, 0, index - 1);
        char* temp2 = subString(input, index + 1, len - 1);
        node->left = buildAST(temp1);
        node->right = buildAST(temp2);

        free(temp2);
        free(temp1);
        return node;
    }

    // Concatenation
    index = indexOf(input, '\n');
    if(index) {
        node->content = '\n';

        char* temp1 = subString(input, 0, index - 1);
        char* temp2 = subString(input, index + 1, len - 1);
        node->left = buildAST(temp1);
        node->right = buildAST(temp2);

        free(temp2);
        free(temp1);
        return node;
    }

    // Kleene star
    // Testing with indexOf() is unnecessary here,
    // Since all other possibilities have been exhausted
    node->content = '*';
    char* temp = subString(input, 0, len - 2);
    node->left = buildAST(temp);
    node->right = NULL;

    free(temp);
    return node;
}"
redirect,"struct NFA* nfa, struct NFAState* src, struct NFAState* dest",,null,"void redirect(struct NFA* nfa, struct NFAState* src, struct NFAState* dest) {
    for (int i = 0; i < nfa->subCount; ++i) {
        redirect(nfa->subs[i], src, dest);
    }
    for (int i = 0; i < nfa->ruleCount; ++i) {
        struct transRule* rule = nfa->rulePool[i];
        if (rule->target == src) {
            rule->target = dest;
        }
    }
}"
compileFromAST,struct ASTNode* root,,nfa | wrapper | NULL | f | 1 | 0,"
struct NFA* compileFromAST(struct ASTNode* root) {

    struct NFA* nfa = createNFA();

    // Empty input
    if (root->content == '\0') {
        addRule(nfa, createRule(nfa->statePool[1], '\0'), 0);
        return nfa;
    }

    // Character literals
    if (isLiteral(root->content)) {
        addRule(nfa, createRule(nfa->statePool[1], root->content), 0);
        return nfa;
    }

    switch (root->content) {

        case '\n': {
            struct NFA* ln = compileFromAST(root->left);
            struct NFA* rn = compileFromAST(root->right);

            // Redirects all rules targeting ln's accepting state to
            // target rn's starting state
            redirect(ln, ln->statePool[1], rn->statePool[0]);

            // Manually creates and initializes a special
            // ""wrapper"" NFA
            destroyNFA(nfa);
            struct NFA* wrapper = malloc(sizeof(struct NFA));
            wrapper->stateCount = 2;
            wrapper->statePool = malloc(sizeof(struct NFAState*) * 2);
            wrapper->subCount = 0;
            wrapper->subs = malloc(sizeof(struct NFA*) * 2);
            wrapper->ruleCount = 0;
            wrapper->rulePool = malloc(sizeof(struct transRule*) * 3);
            wrapper->CSCount = 0;
            wrapper->currentStates = malloc(sizeof(struct NFAState*) * 2);
            wrapper->wrapperFlag = 1;
            wrapper->subs[wrapper->subCount++] = ln;
            wrapper->subs[wrapper->subCount++] = rn;

            // Maps the wrapper NFA's starting and ending states
            // to its sub NFAs
            wrapper->statePool[0] = ln->statePool[0];
            wrapper->statePool[1] = rn->statePool[1];

            return wrapper;
        }
        case '|': {

            struct NFA* ln = compileFromAST(root->left);
            struct NFA* rn = compileFromAST(root->right);
            nfa->subs[nfa->subCount++] = ln;
            nfa->subs[nfa->subCount++] = rn;

            // Adds empty character transition rules
            addRule(nfa, createRule(ln->statePool[0], '\0'), 0);
            addRule(ln, createRule(nfa->statePool[1], '\0'), 1);
            addRule(nfa, createRule(rn->statePool[0], '\0'), 0);
            addRule(rn, createRule(nfa->statePool[1], '\0'), 1);

            return nfa;
        }
        case '*': {
            struct NFA* ln = compileFromAST(root->left);
            nfa->subs[nfa->subCount++] = ln;

            addRule(ln, createRule(ln->statePool[0], '\0'), 1);
            addRule(nfa, createRule(ln->statePool[0], '\0'), 0);
            addRule(ln, createRule(nfa->statePool[1], '\0'), 1);
            addRule(nfa, createRule(nfa->statePool[1], '\0'), 0);

            return nfa;
        }
    }

    // Fallback, shouldn't happen in normal operation
    destroyNFA(nfa);
    return NULL;
}

/* Ends the algorithm, begins NFA utility functions*/

/**
 * @brief adds a state to a NFA
 * @param nfa target NFA
 * @param state the NFA state to be added
 * @returns void
 */
void addState(struct NFA* nfa, struct NFAState* state) {
    nfa->statePool[nfa->stateCount++] = state;
}

/**
 * @brief adds a transition rule to a NFA
 * @param nfa target NFA
 * @param rule the rule to be added
 * @param loc which state this rule should be added to
 * @returns void
 */
void addRule(struct NFA* nfa, struct transRule* rule, int loc) {
    nfa->rulePool[nfa->ruleCount++] = rule;
    struct NFAState* state = nfa->statePool[loc];
    state->rules[state->ruleCount++] = rule;
}

/**
 * @brief performs postprocessing on a compiled NFA,
 *        add circular empty character transition rules where
 *        it's needed for the NFA to function correctly
 * @param nfa target NFA
 * @returns void
 */
void postProcessing(struct NFA* nfa) {
    // Since the sub NFA's states and rules are managed
    // through their own pools, recursion is necessary
    for (int i = 0; i < nfa->subCount; ++i) {
        postProcessing(nfa->subs[i]);
    }

    // If a state does not have any empty character accepting rule,
    // we add a rule that circles back to itself
    // So this state will be preserved when
    // empty characters are inputted
    for (int i = 0; i < nfa->stateCount; ++i) {

        struct NFAState* pState = nfa->statePool[i];
        int f = 0;
        for (int j = 0; j < pState->ruleCount; ++j) {
            if(pState->rules[j]->cond == '\0') {
                f = 1;
                break;
            }
        }

        if (!f) {
            addRule(nfa, createRule(pState, '\0'), i);
        }
    }
}

/**
 * @brief helper function to determine an element's presence in an array
 * @param states target array
 * @param len length of the target array
 * @param state the element to search for
 * @returns `1` if the element is present, `0` otherwise
 */
int contains(struct NFAState** states, int len, struct NFAState* state) {
    int f = 0;
    for (int i = 0; i < len; ++i) {
        if(states[i] == state) {
            f = 1;
            break;
        }
    }
    return f;
}

/**
 * @brief helper function to manage empty character transitions
 * @param target target NFA
 * @param states pointer to results storage location
 * @param sc pointer to results count storage location
 * @returns void
 */
void findEmpty(struct NFAState* target, struct NFAState** states, int *sc) {
    for (int i = 0; i < target->ruleCount; ++i) {
        const struct transRule *pRule = target->rules[i];

        if (pRule->cond == '\0' && !contains(states, *sc, pRule->target)) {
            states[(*sc)++] = pRule->target;
            // the use of `states` and `sc` is necessary
            // to sync data across recursion levels
            findEmpty(pRule->target, states, sc);
        }
    }
}

/**
 * @brief moves a NFA forward
 * @param nfa target NFA
 * @param input the character to be fed into the NFA
 * @returns void
 */
void transit(struct NFA* nfa, char input) {
    struct NFAState** newStates = malloc(sizeof(struct NFAState*) * 10);
    int NSCount = 0;

    if (input == '\0') {
        // In case of empty character input, it's possible for
        // a state to transit to another state that's more than
        // one rule away, we need to take that into account
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            nfa->CSCount--;

            struct NFAState** states = malloc(sizeof(struct NFAState*) * 10);
            int sc = 0;
            findEmpty(pState, states, &sc);

            for (int j = 0; j < sc; ++j) {
                if(!contains(newStates,NSCount, states[j])) {
                    newStates[NSCount++] = states[j];
                }
            }
            free(states);
        }
    } else {
        // Iterates through all current states
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            // Gradually empties the current states pool, so
            // it can be refilled
            nfa->CSCount--;

            // Iterates through rules of this state
            for (int j = 0; j < pState->ruleCount; ++j) {
                const struct transRule *pRule = pState->rules[j];

                if(pRule->cond == input) {
                    if(!contains(newStates, NSCount, pRule->target)) {
                        newStates[NSCount++] = pRule->target;
                    }
                }
            }
        }
    }

    nfa->CSCount = NSCount;
    for (int i = 0; i < NSCount; ++i) {
        nfa->currentStates[i] = newStates[i];
    }
    free(newStates);
}

/**
 * @brief determines whether the NFA is currently in its accepting state
 * @param nfa target NFA
 * @returns `1` if the NFA is in its accepting state
 * @returns `0` otherwise
 */
int isAccepting(const struct NFA* nfa) {
    for (int i = 0; i < nfa->CSCount; ++i) {
        if(nfa->currentStates[i] == nfa->statePool[1]) {
            return 1;
        }
    }
    return 0;
}

/* Ends NFA utilities, begins testing function*/

/**
 * @brief Testing helper function
 * @param regex the regular expression to be used
 * @param string the string to match against
 * @param expected expected results
 * @returns void
 */
void testHelper(const char* regex, const char* string, const int expected) {
    char* temp = preProcessing(regex);
    struct ASTNode* node = buildAST(temp);

    struct NFA* nfa = compileFromAST(node);
    postProcessing(nfa);

    // reallocates the outermost NFA's current states pool
    // because it will actually be used to store all the states
    nfa->currentStates = realloc(nfa->currentStates, sizeof(struct NFAState*) * 100);
    // Starts the NFA by adding its starting state to the pool
    nfa->currentStates[nfa->CSCount++] = nfa->statePool[0];

    // feeds empty characters into the NFA before and after
    // every normal character
    for (size_t i = 0; i < strlen(string); ++i) {
        transit(nfa, '\0');
        transit(nfa, string[i]);
    }
    transit(nfa, '\0');

    assert(isAccepting(nfa) == expected);

    destroyNFA(nfa);
    destroyNode(node);
    free(temp);
}"
addState,"struct NFA* nfa, struct NFAState* state",,null,"void addState(struct NFA* nfa, struct NFAState* state) {
    nfa->statePool[nfa->stateCount++] = state;
}"
addRule,"struct NFA* nfa, struct transRule* rule, int loc",,null,"void addRule(struct NFA* nfa, struct transRule* rule, int loc) {
    nfa->rulePool[nfa->ruleCount++] = rule;
    struct NFAState* state = nfa->statePool[loc];
    state->rules[state->ruleCount++] = rule;
}"
postProcessing,struct NFA* nfa,,f | 1 | 0 | node | rule | state | nfa,"void postProcessing(struct NFA* nfa) {
    // Since the sub NFA's states and rules are managed
    // through their own pools, recursion is necessary
    for (int i = 0; i < nfa->subCount; ++i) {
        postProcessing(nfa->subs[i]);
    }

    // If a state does not have any empty character accepting rule,
    // we add a rule that circles back to itself
    // So this state will be preserved when
    // empty characters are inputted
    for (int i = 0; i < nfa->stateCount; ++i) {

        struct NFAState* pState = nfa->statePool[i];
        int f = 0;
        for (int j = 0; j < pState->ruleCount; ++j) {
            if(pState->rules[j]->cond == '\0') {
                f = 1;
                break;
            }
        }

        if (!f) {
            addRule(nfa, createRule(pState, '\0'), i);
        }
    }
}

/**
 * @brief helper function to determine an element's presence in an array
 * @param states target array
 * @param len length of the target array
 * @param state the element to search for
 * @returns `1` if the element is present, `0` otherwise
 */
int contains(struct NFAState** states, int len, struct NFAState* state) {
    int f = 0;
    for (int i = 0; i < len; ++i) {
        if(states[i] == state) {
            f = 1;
            break;
        }
    }
    return f;
}

/**
 * @brief helper function to manage empty character transitions
 * @param target target NFA
 * @param states pointer to results storage location
 * @param sc pointer to results count storage location
 * @returns void
 */
void findEmpty(struct NFAState* target, struct NFAState** states, int *sc) {
    for (int i = 0; i < target->ruleCount; ++i) {
        const struct transRule *pRule = target->rules[i];

        if (pRule->cond == '\0' && !contains(states, *sc, pRule->target)) {
            states[(*sc)++] = pRule->target;
            // the use of `states` and `sc` is necessary
            // to sync data across recursion levels
            findEmpty(pRule->target, states, sc);
        }
    }
}

/**
 * @brief moves a NFA forward
 * @param nfa target NFA
 * @param input the character to be fed into the NFA
 * @returns void
 */
void transit(struct NFA* nfa, char input) {
    struct NFAState** newStates = malloc(sizeof(struct NFAState*) * 10);
    int NSCount = 0;

    if (input == '\0') {
        // In case of empty character input, it's possible for
        // a state to transit to another state that's more than
        // one rule away, we need to take that into account
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            nfa->CSCount--;

            struct NFAState** states = malloc(sizeof(struct NFAState*) * 10);
            int sc = 0;
            findEmpty(pState, states, &sc);

            for (int j = 0; j < sc; ++j) {
                if(!contains(newStates,NSCount, states[j])) {
                    newStates[NSCount++] = states[j];
                }
            }
            free(states);
        }
    } else {
        // Iterates through all current states
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            // Gradually empties the current states pool, so
            // it can be refilled
            nfa->CSCount--;

            // Iterates through rules of this state
            for (int j = 0; j < pState->ruleCount; ++j) {
                const struct transRule *pRule = pState->rules[j];

                if(pRule->cond == input) {
                    if(!contains(newStates, NSCount, pRule->target)) {
                        newStates[NSCount++] = pRule->target;
                    }
                }
            }
        }
    }

    nfa->CSCount = NSCount;
    for (int i = 0; i < NSCount; ++i) {
        nfa->currentStates[i] = newStates[i];
    }
    free(newStates);
}

/**
 * @brief determines whether the NFA is currently in its accepting state
 * @param nfa target NFA
 * @returns `1` if the NFA is in its accepting state
 * @returns `0` otherwise
 */
int isAccepting(const struct NFA* nfa) {
    for (int i = 0; i < nfa->CSCount; ++i) {
        if(nfa->currentStates[i] == nfa->statePool[1]) {
            return 1;
        }
    }
    return 0;
}

/* Ends NFA utilities, begins testing function*/

/**
 * @brief Testing helper function
 * @param regex the regular expression to be used
 * @param string the string to match against
 * @param expected expected results
 * @returns void
 */
void testHelper(const char* regex, const char* string, const int expected) {
    char* temp = preProcessing(regex);
    struct ASTNode* node = buildAST(temp);

    struct NFA* nfa = compileFromAST(node);
    postProcessing(nfa);

    // reallocates the outermost NFA's current states pool
    // because it will actually be used to store all the states
    nfa->currentStates = realloc(nfa->currentStates, sizeof(struct NFAState*) * 100);
    // Starts the NFA by adding its starting state to the pool
    nfa->currentStates[nfa->CSCount++] = nfa->statePool[0];

    // feeds empty characters into the NFA before and after
    // every normal character
    for (size_t i = 0; i < strlen(string); ++i) {
        transit(nfa, '\0');
        transit(nfa, string[i]);
    }
    transit(nfa, '\0');

    assert(isAccepting(nfa) == expected);

    destroyNFA(nfa);
    destroyNode(node);
    free(temp);
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(void) {
    testHelper(""(c|a*b)"", ""c"", 1);
    testHelper(""(c|a*b)"", ""aab"", 1);
    testHelper(""(c|a*b)"", ""ca"", 0);
    testHelper(""(c|a*b)*"", ""caaab"", 1);
    testHelper(""(c|a*b)*"", ""caba"", 0);
    testHelper("""", """", 1);
    testHelper("""", ""1"", 0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""11"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""110"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""1100"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""10000"",0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""00000"",1);

    printf(""All tests have successfully passed!\n"");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(void) {
    test(); // run self-test implementations
    return 0;
}

/* I opted to place these more-or-less boilerplate code and their docs
 * at the end of file for better readability */

/**
 * @brief creates and initializes a AST node
 * @param content data to initializes the node with
 * @returns pointer to the newly created node
 */
struct ASTNode* createNode(const char content) {
    struct ASTNode* node = malloc(sizeof(struct ASTNode));
    node->content = content;
    node->left = NULL;
    node->right = NULL;
    return node;
}

/**
 * @brief recursively destroys a AST
 * @param node the root node of the tree to be deleted
 * @returns void
 */
void destroyNode(struct ASTNode* node) {
    if(node->left != NULL) {
        destroyNode(node->left);
    }

    if(node->right != NULL) {
        destroyNode(node->right);
    }

    free(node);
}

/**
 * @brief creates and initializes a transition rule
 * @param state transition target
 * @param c transition condition
 * @returns pointer to the newly created rule
 */
struct transRule* createRule(struct NFAState* state, char c) {
    struct transRule* rule = malloc(sizeof(struct transRule));
    rule->target = state;
    rule->cond = c;
    return rule;
}

/**
 * @brief destroys a transition rule object
 * @param rule pointer to the object to be deleted
 * @returns void
 */
void destroyRule(struct transRule* rule) {
    free(rule);
}

/**
 * @brief creates and initializes a NFA state
 * @returns pointer to the newly created NFA state
 */
struct NFAState* createState(void) {
    struct NFAState* state = malloc(sizeof(struct NFAState));
    state->ruleCount = 0;
    state->rules = malloc(sizeof(struct transRule*) * 3);
    return state;
}

/**
 * @brief destroys a NFA state
 * @param state pointer to the object to be deleted
 * @returns void
 */
void destroyState(struct NFAState* state) {
    free(state->rules);
    free(state);
}

/**
 * @brief creates and initializes a NFA
 * @returns pointer to the newly created NFA
 */
struct NFA* createNFA(void) {
    struct NFA* nfa = malloc(sizeof(struct NFA));

    nfa->stateCount = 0;
    nfa->statePool = malloc(sizeof(struct NFAState*) * 5);
    nfa->ruleCount = 0;
    nfa->rulePool = malloc(sizeof(struct transRule*) * 10);
    nfa->CSCount = 0;
    nfa->currentStates = malloc(sizeof(struct NFAState*) * 5);
    nfa->subCount = 0;
    nfa->subs = malloc(sizeof(struct NFA*) * 5);
    nfa->wrapperFlag = 0;

    addState(nfa, createState());
    addState(nfa, createState());
    return nfa;
}

/**
 * @brief recursively destroys a NFA
 * @param nfa pointer to the object to be deleted
 * @returns void
 */
void destroyNFA(struct NFA* nfa) {
    for (int i = 0; i < nfa->subCount; ++i) {
        destroyNFA(nfa->subs[i]);
    }

    // In case of a wrapper NFA, do not free its states
    // because it doesn't really have any states of its own
    if (!nfa->wrapperFlag) {
        for (int i = 0; i < nfa->stateCount; ++i) {
            destroyState(nfa->statePool[i]);
        }
    }
    for (int i = 0; i < nfa->ruleCount; ++i) {
        destroyRule(nfa->rulePool[i]);
    }
    free(nfa->statePool);
    free(nfa->currentStates);
    free(nfa->rulePool);
    free(nfa->subs);
    free(nfa);
}"
contains,"struct NFAState** states, int len, struct NFAState* state",,f,"int contains(struct NFAState** states, int len, struct NFAState* state) {
    int f = 0;
    for (int i = 0; i < len; ++i) {
        if(states[i] == state) {
            f = 1;
            break;
        }
    }
    return f;
}"
findEmpty,"struct NFAState* target, struct NFAState** states, int *sc",,null,"void findEmpty(struct NFAState* target, struct NFAState** states, int *sc) {
    for (int i = 0; i < target->ruleCount; ++i) {
        const struct transRule *pRule = target->rules[i];

        if (pRule->cond == '\0' && !contains(states, *sc, pRule->target)) {
            states[(*sc)++] = pRule->target;
            // the use of `states` and `sc` is necessary
            // to sync data across recursion levels
            findEmpty(pRule->target, states, sc);
        }
    }
}"
transit,"struct NFA* nfa, char input",,null,"void transit(struct NFA* nfa, char input) {
    struct NFAState** newStates = malloc(sizeof(struct NFAState*) * 10);
    int NSCount = 0;

    if (input == '\0') {
        // In case of empty character input, it's possible for
        // a state to transit to another state that's more than
        // one rule away, we need to take that into account
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            nfa->CSCount--;

            struct NFAState** states = malloc(sizeof(struct NFAState*) * 10);
            int sc = 0;
            findEmpty(pState, states, &sc);

            for (int j = 0; j < sc; ++j) {
                if(!contains(newStates,NSCount, states[j])) {
                    newStates[NSCount++] = states[j];
                }
            }
            free(states);
        }
    } else {
        // Iterates through all current states
        for (int i = nfa->CSCount - 1; i > -1; --i) {
            struct NFAState *pState = nfa->currentStates[i];
            // Gradually empties the current states pool, so
            // it can be refilled
            nfa->CSCount--;

            // Iterates through rules of this state
            for (int j = 0; j < pState->ruleCount; ++j) {
                const struct transRule *pRule = pState->rules[j];

                if(pRule->cond == input) {
                    if(!contains(newStates, NSCount, pRule->target)) {
                        newStates[NSCount++] = pRule->target;
                    }
                }
            }
        }
    }

    nfa->CSCount = NSCount;
    for (int i = 0; i < NSCount; ++i) {
        nfa->currentStates[i] = newStates[i];
    }
    free(newStates);
}"
isAccepting,const struct NFA* nfa,,1 | 0,"int isAccepting(const struct NFA* nfa) {
    for (int i = 0; i < nfa->CSCount; ++i) {
        if(nfa->currentStates[i] == nfa->statePool[1]) {
            return 1;
        }
    }
    return 0;
}"
testHelper,"const char* regex, const char* string, const int expected",,0 | node | rule | state | nfa,"void testHelper(const char* regex, const char* string, const int expected) {
    char* temp = preProcessing(regex);
    struct ASTNode* node = buildAST(temp);

    struct NFA* nfa = compileFromAST(node);
    postProcessing(nfa);

    // reallocates the outermost NFA's current states pool
    // because it will actually be used to store all the states
    nfa->currentStates = realloc(nfa->currentStates, sizeof(struct NFAState*) * 100);
    // Starts the NFA by adding its starting state to the pool
    nfa->currentStates[nfa->CSCount++] = nfa->statePool[0];

    // feeds empty characters into the NFA before and after
    // every normal character
    for (size_t i = 0; i < strlen(string); ++i) {
        transit(nfa, '\0');
        transit(nfa, string[i]);
    }
    transit(nfa, '\0');

    assert(isAccepting(nfa) == expected);

    destroyNFA(nfa);
    destroyNode(node);
    free(temp);
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(void) {
    testHelper(""(c|a*b)"", ""c"", 1);
    testHelper(""(c|a*b)"", ""aab"", 1);
    testHelper(""(c|a*b)"", ""ca"", 0);
    testHelper(""(c|a*b)*"", ""caaab"", 1);
    testHelper(""(c|a*b)*"", ""caba"", 0);
    testHelper("""", """", 1);
    testHelper("""", ""1"", 0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""11"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""110"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""1100"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""10000"",0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""00000"",1);

    printf(""All tests have successfully passed!\n"");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(void) {
    test(); // run self-test implementations
    return 0;
}

/* I opted to place these more-or-less boilerplate code and their docs
 * at the end of file for better readability */

/**
 * @brief creates and initializes a AST node
 * @param content data to initializes the node with
 * @returns pointer to the newly created node
 */
struct ASTNode* createNode(const char content) {
    struct ASTNode* node = malloc(sizeof(struct ASTNode));
    node->content = content;
    node->left = NULL;
    node->right = NULL;
    return node;
}

/**
 * @brief recursively destroys a AST
 * @param node the root node of the tree to be deleted
 * @returns void
 */
void destroyNode(struct ASTNode* node) {
    if(node->left != NULL) {
        destroyNode(node->left);
    }

    if(node->right != NULL) {
        destroyNode(node->right);
    }

    free(node);
}

/**
 * @brief creates and initializes a transition rule
 * @param state transition target
 * @param c transition condition
 * @returns pointer to the newly created rule
 */
struct transRule* createRule(struct NFAState* state, char c) {
    struct transRule* rule = malloc(sizeof(struct transRule));
    rule->target = state;
    rule->cond = c;
    return rule;
}

/**
 * @brief destroys a transition rule object
 * @param rule pointer to the object to be deleted
 * @returns void
 */
void destroyRule(struct transRule* rule) {
    free(rule);
}

/**
 * @brief creates and initializes a NFA state
 * @returns pointer to the newly created NFA state
 */
struct NFAState* createState(void) {
    struct NFAState* state = malloc(sizeof(struct NFAState));
    state->ruleCount = 0;
    state->rules = malloc(sizeof(struct transRule*) * 3);
    return state;
}

/**
 * @brief destroys a NFA state
 * @param state pointer to the object to be deleted
 * @returns void
 */
void destroyState(struct NFAState* state) {
    free(state->rules);
    free(state);
}

/**
 * @brief creates and initializes a NFA
 * @returns pointer to the newly created NFA
 */
struct NFA* createNFA(void) {
    struct NFA* nfa = malloc(sizeof(struct NFA));

    nfa->stateCount = 0;
    nfa->statePool = malloc(sizeof(struct NFAState*) * 5);
    nfa->ruleCount = 0;
    nfa->rulePool = malloc(sizeof(struct transRule*) * 10);
    nfa->CSCount = 0;
    nfa->currentStates = malloc(sizeof(struct NFAState*) * 5);
    nfa->subCount = 0;
    nfa->subs = malloc(sizeof(struct NFA*) * 5);
    nfa->wrapperFlag = 0;

    addState(nfa, createState());
    addState(nfa, createState());
    return nfa;
}

/**
 * @brief recursively destroys a NFA
 * @param nfa pointer to the object to be deleted
 * @returns void
 */
void destroyNFA(struct NFA* nfa) {
    for (int i = 0; i < nfa->subCount; ++i) {
        destroyNFA(nfa->subs[i]);
    }

    // In case of a wrapper NFA, do not free its states
    // because it doesn't really have any states of its own
    if (!nfa->wrapperFlag) {
        for (int i = 0; i < nfa->stateCount; ++i) {
            destroyState(nfa->statePool[i]);
        }
    }
    for (int i = 0; i < nfa->ruleCount; ++i) {
        destroyRule(nfa->rulePool[i]);
    }
    free(nfa->statePool);
    free(nfa->currentStates);
    free(nfa->rulePool);
    free(nfa->subs);
    free(nfa);
}"
test,,,null,"static void test(void) {
    testHelper(""(c|a*b)"", ""c"", 1);
    testHelper(""(c|a*b)"", ""aab"", 1);
    testHelper(""(c|a*b)"", ""ca"", 0);
    testHelper(""(c|a*b)*"", ""caaab"", 1);
    testHelper(""(c|a*b)*"", ""caba"", 0);
    testHelper("""", """", 1);
    testHelper("""", ""1"", 0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""11"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""110"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""1100"",1);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""10000"",0);
    testHelper(""(0|(1(01*(00)*0)*1)*)*"",""00000"",1);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main(void) {
    test(); // run self-test implementations
    return 0;
}"
createNode,const char content,,node,"struct ASTNode* createNode(const char content) {
    struct ASTNode* node = malloc(sizeof(struct ASTNode));
    node->content = content;
    node->left = NULL;
    node->right = NULL;
    return node;
}"
destroyNode,struct ASTNode* node,,null,"void destroyNode(struct ASTNode* node) {
    if(node->left != NULL) {
        destroyNode(node->left);
    }

    if(node->right != NULL) {
        destroyNode(node->right);
    }

    free(node);
}"
createRule,"struct NFAState* state, char c",,rule,"struct transRule* createRule(struct NFAState* state, char c) {
    struct transRule* rule = malloc(sizeof(struct transRule));
    rule->target = state;
    rule->cond = c;
    return rule;
}"
destroyRule,struct transRule* rule,,null,"void destroyRule(struct transRule* rule) {
    free(rule);
}"
createState,,,state,"struct NFAState* createState(void) {
    struct NFAState* state = malloc(sizeof(struct NFAState));
    state->ruleCount = 0;
    state->rules = malloc(sizeof(struct transRule*) * 3);
    return state;
}"
destroyState,struct NFAState* state,,null,"void destroyState(struct NFAState* state) {
    free(state->rules);
    free(state);
}"
createNFA,,,nfa,"struct NFA* createNFA(void) {
    struct NFA* nfa = malloc(sizeof(struct NFA));

    nfa->stateCount = 0;
    nfa->statePool = malloc(sizeof(struct NFAState*) * 5);
    nfa->ruleCount = 0;
    nfa->rulePool = malloc(sizeof(struct transRule*) * 10);
    nfa->CSCount = 0;
    nfa->currentStates = malloc(sizeof(struct NFAState*) * 5);
    nfa->subCount = 0;
    nfa->subs = malloc(sizeof(struct NFA*) * 5);
    nfa->wrapperFlag = 0;

    addState(nfa, createState());
    addState(nfa, createState());
    return nfa;
}"
destroyNFA,struct NFA* nfa,,null,"void destroyNFA(struct NFA* nfa) {
    for (int i = 0; i < nfa->subCount; ++i) {
        destroyNFA(nfa->subs[i]);
    }

    // In case of a wrapper NFA, do not free its states
    // because it doesn't really have any states of its own
    if (!nfa->wrapperFlag) {
        for (int i = 0; i < nfa->stateCount; ++i) {
            destroyState(nfa->statePool[i]);
        }
    }
    for (int i = 0; i < nfa->ruleCount; ++i) {
        destroyRule(nfa->rulePool[i]);
    }
    free(nfa->statePool);
    free(nfa->currentStates);
    free(nfa->rulePool);
    free(nfa->subs);
    free(nfa);
}"
main,,,0,"
int main()
{
    int a[10], n, i, j, temp;
    float q1, q3, iqr;

    printf(""Enter no. for Random Numbers :"");
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf(""Random Numbers Generated are :\n"");
    for (i = 0; i < n; i++)
    {
        printf(""\n%d"", a[i]);
    }
    printf(""\n"");
    printf(""\nSorted Data:"");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf(""\n%d"", a[i]);
    }
    q1 = a[n / 4];
    printf(""\nFirst Quartile : %f"", q1);
    q3 = a[(3 * n) / 4];
    printf(""\nThird Quartile : %f"", q3);
    iqr = q3 - q1;
    printf(""\nInterQuartile Range is : %f"", iqr);

    return 0;
}"
main,"int argc, char *argv[]",,,"
int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf(""miroir est %s"", miroir(chaine));
}"
saisie,char *cpointeur,,null,"
void saisie(char *cpointeur)
{
    printf(""saisir une chaine\n"");
    scanf(""%s"", cpointeur);
}"
miroir,char *s,,s,"char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}"
compte,char *s,compte plays the role of strlen so we can change it by an strlen function if,k,"
int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}"
hamming_distance,"char* str1, char* str2",,distance,"int hamming_distance(char* str1, char* str2)
{
    int i = 0, distance = 0;

    while (str1[i] != '\0')
    {
        if (str1[i] != str2[i])
        {
            distance++;
        }
        i++;
    }

    return distance;
}"
test,,,null,"static void test()
{
    char str1[] = ""karolin"";
    char str2[] = ""kathrin"";

    assert(hamming_distance(str1, str2) == 3);

    char str3[] = ""00000"";
    char str4[] = ""11111"";

    assert(hamming_distance(str3, str4) == 5);
    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
hanoi,"int noOfDisks, char where, char to, char extra",,null,"
void hanoi(int noOfDisks, char where, char to, char extra)
{
    if (noOfDisks != 0)
    {
        hanoi(noOfDisks - 1, where, extra, to);
        printf(""Move disk : %d from %c to %c\n"", noOfDisks, where, to);
        hanoi(noOfDisks - 1, extra, to, where);
    }
}"
main,,,0,"
int main(void)
{
    int noOfDisks;

    // Asks the number of disks in the tower
    printf(""Number of disks: \n"");
    scanf(""%d"", &noOfDisks);

    hanoi(noOfDisks, 'A', 'B', 'C');

    return 0;
}"
pid_step,"struct pid *controller, float dt, float error",,p + controller->integral + d,"
float pid_step(struct pid *controller, float dt, float error)
{
    // Calculate p term
    float p = error * controller->kP;

    // Calculate i term
    controller->integral += error * dt * controller->kI;

    // Calculate d term, taking care to not divide by zero
    float d =
        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;
    controller->lastError = error;

    return p + controller->integral + d;
}"
main,,,,"
int main()
{
    printf(""PID Controller Example\n"");

    struct pid controller = {.lastError = 0, .integral = 0};

    // Take the controller gains from the user
    printf(
        ""Please enter controller gains in format kP, kI, KD. For example, ""
        ""\""1.2 2.1 3.2\""\n> "");
    scanf(""%f %f %f"", &controller.kP, &controller.kI, &controller.kD);
    printf(""Using kP: %f, kI: %f, kD: %f\n"", controller.kP, controller.kI,
           controller.kD);

    // How often the pid_step algorithm expects to be called. In a real life
    // scenario this would be provided by calling time(NULL) - last_time, or by
    // calling the function reliably at X Hz (using a timer or RTOS etc) For
    // demonstration of this algorithm though, it is defined below as 1 second,
    // allowing easy testing of integral and derivative terms.
    float time_step = 1;

    float error_value;
    while (1)
    {
        printf(""Enter error value\n>"");
        scanf(""%f"", &error_value);

        float output = pid_step(&controller, time_step, error_value);
        printf(""Output: %f\n"", output);
    }
}"
getPrecedence,char operator,,1 | 2 | 3 | -1,"int getPrecedence(char operator) {
    switch (operator) {
        case '+':
        case '-': {
            return 1;
        }
        case '*':
        case '/': {
            return 2;
        }
        case '^': {
            return 3;
        }
        default:{
            fprintf(stderr,""Error: Invalid operator\n"");
            return -1;
        }
    }
}"
getAssociativity,char operator,,0 | 1 | -1,"int getAssociativity(char operator) {
    switch (operator) {
        case '^': {
            return 0;
        }
        case '+':
        case '-':
        case '*':
        case '/': {
            return 1;
        }
        default: {
            fprintf(stderr,""Error: Invalid operator\n"");
            return -1;
        }
    }
}"
shuntingYard,"const char *input, char *output",,1,"int shuntingYard(const char *input, char *output) {
    const unsigned int inputLength = strlen(input);
    char* operatorStack = (char*) malloc(sizeof(char) * inputLength);

    // This pointer points at where we should insert the next element,
    // Hence stackPointer - 1 is used when accessing elements
    unsigned int stackPointer = 0;

    // We will parse the input with strtok(),
    // Since strtok() is destructive, we make a copy of the input to preserve the original string
    char* str = malloc(sizeof(char) * inputLength + 1);
    strcpy(str,input);
    char* token = strtok(str,"" "");

    // We will push to output with strcat() and strncat(),
    // This initializes output to be a string with a length of zero
    output[0] = '\0';

    while (token != NULL) {
        // If it's a number, push it to the output directly
        if (isdigit(token[0])) {
            strcat(output,token);
            strcat(output,"" "");

            token = strtok(NULL,"" "");
            continue;
        }

        switch (token[0]) {
            // If it's a left parenthesis, push it to the operator stack for later matching
            case '(': {
                operatorStack[stackPointer++] = token[0];
                break;
            }

            // If it's a right parenthesis, search for a left parenthesis to match it
            case ')': {
                // Guard statement against accessing an empty stack
                if(stackPointer < 1) {
                    fprintf(stderr,""Error: Mismatched parentheses\n"");
                    free(operatorStack);
                    free(str);
                    return 1;
                }

                while (operatorStack[stackPointer - 1] != '(') {
                    // strncat() with a count of 1 is used to append characters to output
                    const unsigned int i = (stackPointer--) - 1;
                    strncat(output, &operatorStack[i], 1);
                    strcat(output,"" "");

                    // If the operator stack is exhausted before a match can be found,
                    // There must be a mismatch
                    if(stackPointer == 0) {
                        fprintf(stderr,""Error: Mismatched parentheses\n"");
                        free(operatorStack);
                        free(str);
                        return 1;
                    }
                }

                // Discards the parentheses now the matching is complete,
                // Simply remove the left parenthesis from the stack is enough,
                // Since the right parenthesis didn't enter the stack in the first place
                stackPointer--;
                break;
            }

            // If it's an operator(o1), we compare it to whatever is at the top of the operator stack(o2)
            default: {
                // Places the operator into the stack directly if it's empty
                if(stackPointer < 1) {
                    operatorStack[stackPointer++] = token[0];
                    break;
                }

                // We need to check if there's actually a valid operator at the top of the stack
                if((stackPointer - 1 > 0) && operatorStack[stackPointer - 1] != '(') {
                    const int precedence1 = getPrecedence(token[0]);
                    const int precedence2 = getPrecedence(operatorStack[stackPointer - 1]);
                    const int associativity = getAssociativity(token[0]);

                    // We pop operators from the stack, if...
                    while ( // ... their precedences are equal, and o1 is left associative, ...
                            ((associativity && precedence1 == precedence2) ||
                             // ... or o2 simply have a higher precedence, ...
                             precedence2 > precedence1) &&
                            // ... and there are still operators available to be popped.
                            ((stackPointer - 1 > 0) && operatorStack[stackPointer - 1] != '(')) {

                        strncat(output,&operatorStack[(stackPointer--) - 1],1);
                        strcat(output,"" "");
                    }
                }

                // We'll save o1 for later
                operatorStack[stackPointer++] = token[0];
                break;
            }"
test,,,null,"static void test() {
    char* in = malloc(sizeof(char) * 50);
    char* out = malloc(sizeof(char) * 50);
    int i;

    strcpy(in,""3 + 4 * ( 2 - 1 )"");
    printf(""Infix: %s\n"",in);
    i = shuntingYard(in, out);
    printf(""RPN: %s\n"",out);
    printf(""Return code: %d\n\n"",i);
    assert(strcmp(out,""3 4 2 1 - * +"") == 0);
    assert(i == 0);

    strcpy(in,""3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3"");
    printf(""Infix: %s\n"",in);
    i = shuntingYard(in, out);
    printf(""RPN: %s\n"",out);
    printf(""Return code: %d\n\n"",i);
    assert(strcmp(out,""3 4 2 * 1 5 - 2 3 ^ ^ / +"") == 0);
    assert(i == 0);

    printf(""Testing successfully completed!\n"");
    free(in);
    free(out);
}"
main,,,0,"int main() {
    test(); // Run self-test implementations
    return 0;
}"
swap,"int *a, int *b",,null,"
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}"
part,"int a[], int l, int r, int n, int pivot, int pindex",,p2,"
int part(int a[], int l, int r, int n, int pivot, int pindex)
{
    int p1 = l, p2 = r;
    while (p2 > p1)
    {
        if (a[p1] > pivot && a[p2] < pivot)
        {
            swap(&a[p1], &a[p2]);
        }
        else
        {
            if (a[p1] <= pivot)
            {
                p1++;
            }
            if (a[p2] >= pivot)
            {
                p2--;
            }
        }
    }
    swap(&a[pindex], &a[p2]);
    return p2;
}"
rselect,"int a[], int l, int r, int n, int o",,a[pactual] | a[l] | -1,"
int rselect(int a[], int l, int r, int n, int o)
{
    int pivot, pindex, pactual;
    if (r > l)
    {
        pindex = rand() % (r - l + 1);
        pivot = a[pindex];
        pactual = part(a, l, r, n, pivot, pindex);

        if (pactual == o)
        {
            return a[pactual];
        }

        if (o < pactual)
        {
            rselect(a, l, pactual - 1, n, o);
        }

        if (o > pactual)
        {
            rselect(a, pactual + 1, r, n, o - pactual);
        }
    }
    if (r == l)
    {
        return a[l];
    }
    return -1;
}"
main,,,0,"
int main()
{
    srand(time(NULL));
    int n, o, i, *a;
    scanf(""%d %d"", &n, &o);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", a + i);
    }
    printf(""\n\n%d"", rselect(a, 0, n - 1, n, o));
    return 0;
}"
free_poly,struct term *poly,,null,"void free_poly(struct term *poly)
{
    while (poly)
    {
        struct term *next = poly->next;
        free(poly);
        poly = next;
    }
}"
create_polynomial,"struct term **poly, int coef, int pow",,null,"void create_polynomial(struct term **poly, int coef, int pow)
{
    // Creating the polynomial using temporary linked lists
    struct term **temp1 = poly;

    while (*temp1)
    {
        temp1 = &(*temp1)->next;
    }

    // Now temp1 reaches to the end of the list
    *temp1 = (struct term *)malloc(
        sizeof(struct term));  // Create the term and linked as the tail
    (*temp1)->coef = coef;
    (*temp1)->pow = pow;
    (*temp1)->next = NULL;
}"
poly_add,"struct term **pol, struct term *poly1, struct term *poly2",,null,"void poly_add(struct term **pol, struct term *poly1, struct term *poly2)
{
    // Creating a temporary linked list to store the resultant polynomial
    struct term *temp = (struct term *)malloc(sizeof(struct term));
    temp->next = NULL;
    *pol =
        temp;  //*pol always points to the 1st node of the resultant polynomial

    // Comparing the powers of the nodes of both the polynomials
    // until one gets exhausted
    while (poly1 && poly2)
    {
        /* If the power of the first polynomial is greater than the power of the
       second one place the power and coefficient of that node of the first
       polynomial in temp and increase the pointer poly1
       */
        if (poly1->pow > poly2->pow)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If the power of the second polynomial is greater than the power of
          the first one place the power and coefficient of that node of the
          second polynomial in temp and increase the pointer poly2
        */
        else if (poly1->pow < poly2->pow)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
        /* If both of them have same power then sum the coefficients
          place both the summed coefficient and the power in temp
          increase both the pointers poly1 and poly2
        */
        else
        {
            temp->coef = poly1->coef + poly2->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
            poly2 = poly2->next;
        }
        /* If none of the polynomials are exhausted
         dynamically create a node in temp
         */
        if (poly1 && poly2)
        {
            temp->next = (struct term *)malloc(
                sizeof(struct term));  // Dynamic node creation
            temp = temp->next;         // Increase the pointer temp
            temp->next = NULL;
        }
    }
    /* If one of the polynomials is exhausted
    place the rest of the other polynomial as it is in temp
    by creating nodes dynamically
    */
    while (poly1 || poly2)
    {
        temp->next = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp = temp->next;         // Increasing the pointer
        temp->next = NULL;

        /* If poly1 is not exhausted
        place rest of that polynomial in temp
        */
        if (poly1)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If poly2 is not exhausted
       place rest of that polynomial in temp
       */
        else if (poly2)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
    }
}"
display_polynomial,struct term *poly,,null,"void display_polynomial(struct term *poly)
{
    while (poly != NULL)
    {
        printf(""%d x^%d"", poly->coef, poly->pow);
        poly = poly->next;
        if (poly != NULL)
        {
            printf("" + "");
        }
    }
}"
test1,"struct term *poly1, struct term *poly2, struct term *poly3",,null,"static void test1(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf(""\n----Test 1----\n"");
    printf(""\nFirst Polynomial:\n"");  // Defining the 1st polynomial
    create_polynomial(&poly1, 5, 2);
    create_polynomial(&poly1, 3, 1);
    create_polynomial(&poly1, 2, 0);
    display_polynomial(poly1);

    printf(""\nSecond Polynomial:\n"");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 7, 3);
    create_polynomial(&poly2, 9, 1);
    create_polynomial(&poly2, 10, 0);
    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf(""\nResultant polynomial:\n"");
    display_polynomial(poly3);
    printf(""\n"");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}"
test2,"struct term *poly1, struct term *poly2, struct term *poly3",,null,"static void test2(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf(""\n----Test 2----\n"");
    printf(""\nFirst Polynomial:\n"");  // Defining the 1st polynomial
    create_polynomial(&poly1, 3, 5);
    create_polynomial(&poly1, 1, 4);
    create_polynomial(&poly1, 2, 3);
    create_polynomial(&poly1, -2, 1);
    create_polynomial(&poly1, 5, 0);

    display_polynomial(poly1);

    printf(""\nSecond Polynomial:\n"");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 2, 5);
    create_polynomial(&poly2, 3, 3);
    create_polynomial(&poly2, 7, 1);
    create_polynomial(&poly2, 2, 0);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf(""\nResultant polynomial:\n"");
    display_polynomial(poly3);
    printf(""\n"");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}"
test3,"struct term *poly1, struct term *poly2, struct term *poly3",,null,"static void test3(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf(""\n----Test 3----\n"");
    printf(""\nFirst Polynomial:\n"");  // Defining the 1st polynomial
    create_polynomial(&poly1, -12, 0);
    create_polynomial(&poly1, 8, 1);
    create_polynomial(&poly1, 4, 3);

    display_polynomial(poly1);

    printf(""\nSecond Polynomial:\n"");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 5, 0);
    create_polynomial(&poly2, -13, 1);
    create_polynomial(&poly2, 3, 3);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf(""\nResultant polynomial:\n"");
    display_polynomial(poly3);
    printf(""\n"");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}"
main,,,0,"int main(void)
{
    struct term *poly1 = NULL, *poly2 = NULL, *poly3 = NULL;
    test1(poly1, poly2, poly3);
    test2(poly1, poly2, poly3);
    test3(poly1, poly2, poly3);

    return 0;
}"
push,int8_t opd,,null,"void push(int8_t opd) {
	if(st.top == 19)	{		// overflow condition
		printf(""Stack overflow..."");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}"
pop,,,item,"int8_t pop() {
	int8_t item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf(""Stack underflow..."");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}"
evaluate,char post[],,pop(),"int8_t evaluate(char post[]) {
	int8_t it1;
	int8_t it2;
	int8_t temp;
	int8_t number;
    int i;
    for(i = 0; i < strlen(post); i++) {
		if(post[i] == ' ') {
			continue;			// ignore delimiter
		}
		else if(isdigit(post[i])) {
			number = 0;
			do {
				number = number * 10 + (post[i]-'0');
				i++;
			} while(i < strlen(post) && isdigit(post[i]));
			push(number);
		}
		else {
			it2 = pop();
			it1 = pop();
			switch(post[i]) {
				case '+':
				temp = it1 + it2; break;
				case '-':
				temp = it1 - it2; break;
				case '*':
				temp = it1 * it2; break;
				case '/':
				temp = it1 / it2; break;
				case '%':
				temp = it1 % it2; break;
				default:
				printf(""Invalid operator""); exit(1);
			}
			push(temp);
		}
	}
	return pop();
}"
test,,,null,"static void test() {
    /* check sample test case
	   input: ""2 10 + 9 6 - /""
	   expected output: 4
	 */
	char temp1[50] = ""2 10 + 9 6 - /"";
	assert(evaluate(temp1) == 4); 			/// this ensures that the algorithm works as expected
	/* input: ""4 2 + 3 5 1 - * +""
	   expected output: 18
	 */
	char temp2[50] = ""4 2 + 3 5 1 - * +"";
	assert(evaluate(temp2) == 18); 			/// this ensures that the algorithm works as expected
	printf(""All tests have successfully passed!\n"");
}"
main,,"@brief Self-test implementations
@returns void",0,"int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	return 0;
}"
run_length_encode,char* str,,compacted_string,"char* run_length_encode(char* str) {
    int str_length = strlen(str);
    int encoded_index = 0;

    //allocate space for worst-case scenario
    char* encoded = malloc(2 * strlen(str));
    
    //temp space for int to str conversion
    char int_str[20];

    for(int i = 0; i < str_length; ++i) {
        int count = 0;
        char current = str[i];

        //count occurences
        while(current == str[i + count]) count++;

        i += count - 1;

        //convert occurrence amount to string and write to encoded string
        sprintf(int_str, ""%d"", count);
        int int_str_length = strlen(int_str);
        strncpy(&encoded[encoded_index], int_str, strlen(int_str));

        //write current char to encoded string
        encoded_index += strlen(int_str);
        encoded[encoded_index] = current;
        ++encoded_index;
    }

    //null terminate string and move encoded string to compacted memory space 
    encoded[encoded_index] = '\0';
    char* compacted_string = malloc(strlen(encoded) + 1);
    strcpy(compacted_string, encoded);
    
    free(encoded);

    return compacted_string;
}"
test,,,null,"static void test() {
    char* test;
    test = run_length_encode(""aaaaaaabbbaaccccdefaadr"");
    assert(!strcmp(test, ""7a3b2a4c1d1e1f2a1d1r""));
    free(test);
    test = run_length_encode(""lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb"");
    assert(!strcmp(test, ""1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1bq""));
    free(test);
    test = run_length_encode(""htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw"");
    assert(!strcmp(test, ""1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w""));
    free(test);
}"
main,,,0,"int main() {
    test();  // run self-test implementations
    printf(""All tests have passed!\n"");
    return 0;
}"
find,"int *p, int x",,x | p[x],"int find(int *p, int x)
{
    if (x >= MAX_SIZE)
    {
        fprintf(stderr, ""Out-of bounds value\n"");
        exit(EXIT_FAILURE);
    }

    if (p[x] == x)
    {
        return x;
    }
    else
    {
        p[x] = find(p, p[x]);
        return p[x];
    }
}"
join,"int *p, int x, int y",,null,"void join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }"
main,,"@brief Function to join
@param [in,out] p array to join in
@param x value or index to join to
@param y value or index to join from",0,"int main()
{
    int union_set[MAX_SIZE];

    // Have all array indexes that you need to use reference themselves
    for (int i = 0; i < 10; i++)
    {
        union_set[i] = i;
    }
    // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 5);
    printf(""The array is now: "");
    for (int i = 0; i < 10; i++)
    {
        printf(""%d "", union_set[i]);
    }
    printf(""\n"");
    // Now 3 and 5 are groupped together, that is find(3) = find(5)
    // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 8);
    printf(""The array is now: "");
    for (int i = 0; i < 10; i++)
    {
        printf(""%d "", union_set[i]);
    }
    printf(""\n"");

    // Now 3, 5 and are groupped together, find(3) = find(5) = find(8)
    // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9}
    join(union_set, 0, 5);
    if (find(union_set, 0) == find(union_set, 3))
    {
        printf(""0 and 3 are groupped together\n"");
    }
    printf(""The array is now: "");
    for (int i = 0; i < 10; i++)
    {
        printf(""%d "", union_set[i]);
    }
    printf(""\n"");

    return 0;
}"
print,const struct sudoku *a,,null,"void print(const struct sudoku *a)
{
    int i, j;
    for (i = 0; i < a->N; i++)
        for (j = 0; j < a->N; j++)
            printf(""%"" SCNu8 ""%c"", a->a[i * a->N + j],
                   (j == a->N - 1 ? '\n' : ' '));
}"
test,,,null,"void test()
{
    printf(""Test begin...\n"");

    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,
                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,
                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,
                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,
                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};
    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};
    assert(solve(&a));  // ensure that solution is obtained

    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,
                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,
                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,
                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,
                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};
    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++)
            assert(a.a[i * a.N + j] == expected[i * a.N + j]);

    printf(""Test passed\n"");
}"
main,,,0,"int main()
{
    test();

    struct sudoku a;  // store the matrix as a 1D array
    scanf(""%"" SCNu8, &(a.N));
    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));
    a.N2 = (uint8_t)sqrt(a.N);

    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++) scanf(""%"" SCNu8, &(a.a[i * a.N + j]));

    printf(""Entered a %udx%ud matrix with block size: %"" SCNu8 ""\n"", a.N, a.N,
           a.N2);
    // print(&a);
    printf(""\n\n"");
    if (solve(&a))
        printf(""Valid solution found!\n"");
    else
        printf(""Invalid\n"");
    print(&a);

    free(a.a);
    return 0;
}"
test,,,null,"static void test()
{
    quaternion quat = {0.7071f, 0.7071f, 0.f, 0.f};
    euler eul = euler_from_quat(&quat);
    printf(""Euler: %.4g, %.4g, %.4g\n"", eul.pitch, eul.roll, eul.yaw);

    quaternion test_quat = quat_from_euler(&eul);
    printf(""Quaternion: %.4g %+.4g %+.4g %+.4g\n"", test_quat.w,
           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);

    assert(fabsf(test_quat.w - quat.w) < .01);
    assert(fabsf(test_quat.q1 - quat.q1) < .01);
    assert(fabsf(test_quat.q2 - quat.q2) < .01);
    assert(fabsf(test_quat.q3 - quat.q3) < .01);
}"
main,,,0,"
int main()
{
    test();
    return 0;
}"
dot_prod,"const vec_3d *a, const vec_3d *b",,dot,"float dot_prod(const vec_3d *a, const vec_3d *b)
{
    float dot;
#ifdef LIBQUAT_ARM
    arm_dot_prod_f32((float *)a, (float *)b, &dot);
#else
    dot = a->x * b->x;
    dot += a->y * b->y;
    dot += a->z * b->z;
#endif

    return dot;
}"
vector_norm,const vec_3d *a,,n,"float vector_norm(const vec_3d *a)
{
    float n = dot_prod(a, a);
#ifdef LIBQUAT_ARM
    arm_sqrt_f32(*n, n);
#else
    n = sqrtf(n);
#endif

    return n;
}"
get_angle,"const vec_3d *a, const vec_3d *b",,NAN | alpha,"double get_angle(const vec_3d *a, const vec_3d *b)
{
    double alpha, cos_alpha;
    float norm_a = vector_norm(a); ///< The norm of vector a
    float norm_b = vector_norm(b); ///< The norm of vector b
    if (fabsf(norm_a) < EPSILON || fabsf(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case
    {  
        return NAN; 
    }

    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);
    alpha = acos(cos_alpha); // delivers the radian
    return alpha; // in range from -1 to 1
}"
test,,,null,"static void test()
{
    vec_3d a = {1., 2., 3.};
    vec_3d b = {1., 1., 1.};
    float d;

    // printf(""%s"", print_vector(&a, ""a""));
    // printf(""%s"", print_vector(&b, ""b""));

    d = vector_norm(&a);
    // printf(""|a| = %.4g\n"", d);
    assert(fabsf(d - 3.742f) < 0.01);
    d = vector_norm(&b);
    // printf(""|b| = %.4g\n"", d);
    assert(fabsf(d - 1.732f) < 0.01);

    d = dot_prod(&a, &b);
    // printf(""Dot product: %f\n"", d);
    assert(fabsf(d - 6.f) < 0.01);

    vec_3d c = vector_prod(&a, &b);
    // printf(""Vector product "");
    // printf(""%s"", print_vector(&c, ""c""));
    assert(fabsf(c.x - (-1.f)) < 0.01);
    assert(fabsf(c.y - (2.f)) < 0.01);
    assert(fabsf(c.z - (-1.f)) < 0.01);

    double alpha = get_angle(&a, &b);
    // printf(""The angle is %f\n"", alpha);
    assert(fabsf(alpha - 0.387597) < 0.01);
}"
main,,,0,"int main(void)
{
    test();

    return 0;
}"
abbreviate,const char *phrase,,acr,"
char *abbreviate(const char *phrase)
{
    char str[80];
    strcpy(str, phrase);
    char *p_str = str;
    static char acr[80];
    strcpy(acr, """");

    /* for counting the words */
    int counter = 0;

    /* for position the words */
    int index = 0;

    /* for -loop variable */
    int i = 0;

    /*
        counts the empty-characters.
        for determine the number of words
    */
    while (p_str && (i < 80))
    {
        if (*p_str == ' ')
        {
            counter++;
        }
        if (i < 80)
        {
            p_str++;
            i++;
        }
    }

    i = 0;
    counter++;
    char **words = (char **)malloc(counter * sizeof(char *));

    /* initalizes words-array with empty strings */
    for (i = 0; i < counter; i++)
    {
        words[i] = (char *)malloc(80 * sizeof(char));
        strcpy(words[i], """");
    }

    /* rewind string */
    p_str = str;

    char *p_start = p_str;

    /* collects each word in array 'words' */
    while (p_str && (i <= 80))
    {
        if (*p_str == ' ')
        {
            *p_str = '\0';
            strncat(words[index], p_start, 80);
            index++;
            p_start = p_str + 1;
        }

        if (i <= 80)
        {
            p_str++;
            i++;
        }
    }

    /* adds the last word */
    *p_str = '\0';
    strncat(words[index], p_start, 80);
    index++;

    /* builds the actual acronym */
    for (i = 0; i < index; i++)
    {
        /* capitalize the first character */
        words[i][0] = toupper(words[i][0]);
        words[i][1] = '\0';
        strcat(acr, words[i]);
    }

    for (i = 0; i < counter; i++) free(words[i]);
    free(words);

    return acr;
}"
to_rna,const char s[],,"string */
    char *ans = malloc(sizeof(char) * len) | ans","
char *to_rna(const char s[])
{
    /* determines the length of the given string */
    int len = strlen(s);

    /* creates a return string */
    char *ans = malloc(sizeof(char) * len);

    /* for the loop */
    int i = 0;

    /* actual compile process */
    for (i = 0; i < len; i++)
    {
        switch (s[i])
        {
        case 'G':
            ans[i] = 'C';
            break;
        case 'C':
            ans[i] = 'G';
            break;
        case 'T':
            ans[i] = 'A';
            break;
        case 'A':
            ans[i] = 'U';
            break;
        }
    }

    return ans;
}"
word_count,"const char *input_text, word_count_word_t *words",,count_all,"int word_count(const char *input_text, word_count_word_t *words)
{
    char word_list[MAX_WORDS][MAX_WORD_LENGTH];
    char input[1000];
    strcpy(input, input_text);
    char *p_str = input;

    /* index for iteration over input string */
    int index = 0;

    /* index for word_list */
    int index_list = 0;

    /* counts all words */
    int count_all = 0;

    /* for controlling the while loop */
    int loop = 1;

    /* for the for-loop */
    int i = 0;

    /* collects all words in the word_list */
    while (input[index] && loop)
    {
        if (input[index] == ' ')
        {
            input[index] = '\0';
            if (strlen(p_str) <= MAX_WORD_LENGTH)
            {
                if (index_list <= MAX_WORDS)
                {
                    strcpy(word_list[index_list], p_str);

                    /* sets pointer to the next position */
                    p_str = input + index + 1;
                    index_list++;

                    /* counts the word */
                    count_all++;
                }
                else /* error case too many words */
                {
                    count_all = EXCESSIVE_NUMBER_OF_WORDS;
                    loop = 0;
                }
            }
            else /* error case: word is too long */
            {
                count_all = EXCESSIVE_LENGTH_WORD;
                loop = 0;
            }
        }

        index++;
    }

    words->count = 0;

    /* make sure none error is occurred */
    if (loop)
    {
        /* collects the last word up to the \0-character. and counts it.*/
        strcpy(word_list[index_list], p_str);
        count_all++;

        for (i = 0; i <= index_list; i++)
        {
            if (strcmp(word_list[i], words->text) == 0)
            {
                words->count++;
            }
        }
    }

    /* returns the number of words or an error code */
    return count_all;
}"
main,,,0,"
int main()
{
    int n, sum = 0, i, num;
    printf(""Enter number: "");
    scanf(""%d"", &n);
    num = n;
    while (n != 0)
    {
        i = n % 10;
        sum = sum + (i * i * i);
        n = n / 10;
    }
    if (sum == num)
    {
        printf(""%d is an armstrong number!\n"", num);
    }
    else
    {
        printf(""%d is not an armstrong number!\n"", num);
    }
    return 0;
}"
main,,,0,"
int main()
{
    int a[200], n, counter, temp, i;
    a[0] = 1;
    counter = 0;
    printf(""Enter a whole number to Find its Factorial: "");
    scanf(""%d"", &n);
    if (n < 0)
        printf(""Cannot Calculate factorials for negative numbers."");
    else
    {
        for (; n >= 2; n--)
        {
            temp = 0;
            for (i = 0; i <= counter; i++)
            {
                temp = (a[i] * n) + temp;
                a[i] = temp % 10;
                temp = temp / 10;
            }
            while (temp > 0)
            {
                a[++counter] = temp % 10;
                temp = temp / 10;
            }
        }
        for (i = counter; i >= 0; i--) printf(""%d"", a[i]);
    }
    return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    unsigned long long n, curr_no, num_steps = 0;
    if (argc == 2)
        n = strtoull(argv[1], NULL, 10);
    else
    {
        printf(""Enter starting number: "");
        scanf(""%lu"", &n);  // input number
    }

    curr_no = n;          // curr_no stores input number n
    while (curr_no != 1)  // loop till series reaches 1
    {
        num_steps++;
        printf(""%llu->"", curr_no);
        if (curr_no % 2 == 0)  // condition   for even number
            curr_no = curr_no / 2;
        else
            curr_no = (curr_no * 3) + 1;  // condition for odd number
    }
    printf(""1\nNumber of steps: %llu\n"", num_steps);
    return 0;
}"
main,,,0,"
int main()
{
    long int f1, f2, f3;  // long int for more than 10 factorial
    int n;
    float C;  // C is catalan number for n;
    scanf(""%d"", &n);
    f1 = factorial(2 * n);
    f2 = factorial(n + 1);
    f3 = factorial(n);
    C = f1 / (f2 * f3);  // formula for catalan number for n
    printf(""%0.2f"", C);
    return 0;
}"
main,,,0,"int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}"
main,,,0,"
int main()
{
    int a[16500], T;
    long long int i, j;

    printf(""Enter number of test cases : "");
    scanf(""%d"", &T);

    while (T--)
    {
        for (i = 0; i < 16500; i++)
        {
            a[i] = 0;
        }

        a[1] = 1;
        int N, carry = 0, count = 0;
        printf(""Enter a number : "");
        scanf(""%d"", &N);

        for (i = 1; i <= N; i++)
        {
            carry = 0;
            for (j = 0; j < 16500; j++)
            {
                a[j] = a[j] * i + carry;
                carry = a[j] / 10;
                a[j] = a[j] % 10;
            }
        }

        for (i = 0; i < 16500; i++)
        {
            if (a[i] != 0)
            {
                count = i;
            }
        }

        for (i = count; i > 0; i--)
        {
            printf(""%d"", a[i]);
        }
        printf(""\n"");
    }

    return 0;
}"
lerp,"float k0, float k1, float t",,k0 + t * (k1 - k0),"
float lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }"
lerp_precise,"int k0, int k1, float t",,(1 - t) * k0 + t * k1,"
float lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }"
main,,,0,"
int main()
{
    float start = 0;
    float finish = 5;
    float steps = 0;

    printf(""Input a number, this is the bigger bound of the lerp:\n"");
    scanf(""%f"", &finish);

    printf(
        ""Input a number, this is in how many steps you want to divide the ""
        ""lerp:\n"");
    scanf(""%f"", &steps);

    for (int i = 0; i < steps + 1; i++)
    {
        printf(""%f\n"", lerp(start, finish, i / steps));
    }

    return 0;
}"
main,,,0,"
int main()
{
    int i, n, test = 0, count = 0;
    // taking input number n
    scanf(""%d"", &n);

    // looping from 1 till loop break
    for (i = 1;; i++)
    {
        test =
            n /
            pow(5,
                i);  // division of n by ith power of 5(storing in integer form)
        if (test !=
            0)  // condition for zeroes at end corresponding individual ith case
        {
            count = count + test;
        }
        else
            break;  // break the loop for if test=0
    }
    printf(""%d\n"", count);
    return 0;
}"
test,,,null,"void test()
{
    assert(isStrong(145));  /* 145 = 1! + 4! + 5! */
    assert(!isStrong(543)); /* 543 != 5!+ 4! + 3! */
}"
main,,"Test function
@return void",0,"int main()
{
    test();
    return 0;
}"
fib,unsigned int n,,seq,"int fib(unsigned int n) {
    float seq = (1 / sqrt(5) * pow(((1 + sqrt(5)) / 2), n + 1)) - (1 / sqrt(5) * pow(((1 - sqrt(5)) / 2), n + 1));

    // removing unnecessary fractional part by implicitly converting float to int
    return seq;
}"
test,,,null,"static void test () {
    /* this ensures that the first 10 number of fibonacci sequence
     * (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89)
     * matches with algorithm
    */
    assert(fib(0) == 1);
    assert(fib(1) == 1);
    assert(fib(2) == 2);
    assert(fib(3) == 3);
    assert(fib(4) == 5);
    assert(fib(5) == 8);
    assert(fib(6) == 13);
    assert(fib(7) == 21);
    assert(fib(8) == 34);
    assert(fib(9) == 55);
    assert(fib(10) == 89);
    
    printf(""All tests have successfully passed!\n"");
}"
main,,"@brief Self-test implementations
@returns void",0,"int main() {
    test();  // run self-test implementations

    for(int i = 0; i <= 10; i++){
        printf(""%d. fibonacci number is: %d\n"", i, fib(i));
    }
    return 0;
}"
getInput,,,num,"int getInput(void)
{
    int num, excess_len;
    char buffer[3], *endPtr;

    while (1)
    {  // Repeat until a valid number is entered
        printf(""Please enter a valid number:"");
        fgets(buffer, 3, stdin);  // Inputs the value from user

        excess_len = 0;
        if (!(buffer[0] == '\n' ||
            buffer[1] == '\n' ||
            buffer[2] == '\n')) {
            while (getchar() != '\n') excess_len++;
        }

        num = strtol(buffer, &endPtr,
                     10);  // Attempts to convert the string to integer

        // Checking the input
        if (  // The number is too large
            (excess_len > 0 || num > 48) ||
            // Characters other than digits are included in the input
            (*endPtr != '\0' && *endPtr != '\n') ||
            // No characters are entered
            endPtr == buffer)
        {
            continue;
        }

        break;
    }

    printf(""\nEntered digit: %d (it might take sometime)\n"", num);
    return num;
}"
test,,,null,"static void test()
{
    assert(fib(5) == 3);
    assert(fib(2) == 1);
    assert(fib(9) == 21);
}"
main,,,0,"int main()
{
    // Performing the test
    test();
    printf(""Tests passed...\n"");

    // Getting n
    printf(
        ""Enter n to find nth fibonacci element...\n""
        ""Note: You would be asked to enter input until valid number ( less ""
        ""than or equal to 48 ) is entered.\n"");

    int number = getInput();
    clock_t start, end;

    start = clock();
    printf(""Fibonacci element %d is %u "", number, fib(number));
    end = clock();

    printf(""in %.3f seconds.\n"", ((double)(end - start)) / CLOCKS_PER_SEC );
    return 0;
}"
power,"int x, unsigned int y",,"1 | power(x, y / 2) * power(x, y / 2) | x * power(x, y / 2) * power(x, y / 2)","
int power(int x, unsigned int y)
{
    if (y == 0)
        return 1;
    if (y % 2 == 0)
        return power(x, y / 2) * power(x, y / 2);
    return x * power(x, y / 2) * power(x, y / 2);
}"
order,int x,,n,"
int order(int x)
{
    int n = 0;
    while (x)
    {
        n++;
        x = x / 10;
    }
    return n;
}"
isArmstrong,int x,Function to check whether the given number is,1 | 0,"
int isArmstrong(int x)
{
    // Calling order function
    int n = order(x);
    int temp = x, sum = 0;
    while (temp)
    {
        int r = temp % 10;
        sum += power(r, n);
        temp = temp / 10;
    }

    // If satisfies Armstrong condition
    if (sum == x)
        return 1;
    else
        return 0;
}"
main,,,0,"
int main()
{
    int x = 153;
    if (isArmstrong(x) == 1)
        printf(""True\n"");
    else
        printf(""False\n"");

    x = 1253;
    if (isArmstrong(x) == 1)
        printf(""True\n"");
    else
        printf(""False\n"");

    return 0;
}"
extended_euclidean_algorithm,"int a, int b",,result,"euclidean_result_t extended_euclidean_algorithm(int a, int b)
{
    int previous_remainder = 1;
    int previous_x_values[2] = {0, 1};
    int previous_y_values[2] = {1, 0};
    div_t div_result;
    euclidean_result_t result;

    /* swap values of a and b */
    if (abs(a) < abs(b))
    {
        a ^= b;
        b ^= a;
        a ^= b;
    }

    div_result.rem = b;

    while (div_result.rem > 0)
    {
        div_result = div(a, b);

        previous_remainder = b;

        a = b;
        b = div_result.rem;

        calculate_next_xy(div_result.quot, previous_x_values);
        calculate_next_xy(div_result.quot, previous_y_values);
    }

    result.gcd = previous_remainder;
    result.x = previous_x_values[1];
    result.y = previous_y_values[1];

    return result;
}"
test,,,null,"static void test()
{
    single_test(40, 27, 1, -2, 3);
    single_test(71, 41, 1, -15, 26);
    single_test(48, 18, 6, -1, 3);
    single_test(99, 303, 3, -16, 49);
    single_test(14005, 3507, 1, -305, 1218);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
gcd,"int a, int b",,"b | gcd(b % a, a)","
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}"
lcm,"int a, int b",,"(a * b) / gcd(a, b)","
int lcm(int a, int b) { return (a * b) / gcd(a, b); }"
main,,,0,"
int main()
{
    int a, b;
    printf(""Enter two numbers to find their LCM \n"");
    scanf(""%d%d"", &a, &b);
    printf(""LCM of %d and %d is %d "", a, b, lcm(a, b));
    return 0;
}"
fib,int n,,out,"
int fib(int n)
{
    // Out of Range checking
    if (n < 0)
    {
        printf(""\nNo Such term !\n"");
        exit(0);
    }
    // declaring array to store fibonacci numbers -- memoization
    int *f = (int *)malloc(
        (n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0
    int i;

    /* let 0th and 1st number of the series be 0 and 1*/
    f[0] = 0;
    f[1] = 1;

    for (i = 2; i <= n; i++)
    {
        // Adding the previous 2 terms to make the 3rd term
        f[i] = f[i - 1] + f[i - 2];
    }

    int out = f[n];
    free(f);
    return out;
}"
main,"int argc, char *argv[]",,0,"
int main(int argc, char *argv[])
{
    int number;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf(""Enter the value of n(n starts from 0 ): "");
        scanf(""%d"", &number);
    }

    printf(""The nth term is : %d \n"", fib(number));

    return 0;
}"
propagate,CantorSet *head,,null,"void propagate(CantorSet *head)
{
    // if input is NULL, ignore the process
    if (head == NULL)
        return;

    CantorSet *temp = head;  // local pointer to track propagation

    // create new node for the new set
    CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));

    // get 1/3rd of interval
    double diff = (((temp->end) - (temp->start)) / 3);

    // update interval ranges
    newNode->end = temp->end;
    temp->end = ((temp->start) + diff);
    newNode->start = (newNode->end) - diff;

    // update pointer to next set in this level
    newNode->next = temp->next;

    // point to next set
    temp->next = newNode;

    // create next set
    propagate(temp->next->next);
}"
print,CantorSet *head,,null,"void print(CantorSet *head)
{
    CantorSet *temp = head;
    while (temp != NULL)  // print while a valid set is found
    {
        printf(""\t"");
        printf(""[%lf] -- "", temp->start);
        printf(""[%lf]"", temp->end);
        temp = temp->next;
    }

    printf(""\n"");
}"
free_memory,CantorSet *head,,null,"void free_memory(CantorSet *head)
{
    if (!head)
        return;

    if (head->next)
        free_memory(head->next);

    free(head);
}"
main,"int argc, char const *argv[]",,-1 | 0,"int main(int argc, char const *argv[])
{
    int start_num, end_num, levels;

    if (argc < 2)
    {
        printf(""Enter 3 arguments: start_num \t end_num \t levels\n"");
        scanf(""%d %d %d"", &start_num, &end_num, &levels);
    }
    else
    {
        start_num = atoi(argv[1]);
        end_num = atoi(argv[2]);
        levels = atoi(argv[3]);
    }

    if (start_num < 0 || end_num < 0 || levels < 0)
    {
        fprintf(stderr, ""All numbers must be positive\n"");
        return -1;
    }

    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};

    // loop to propagate each level from top to bottom
    for (int i = 0; i < levels; i++)
    {
        printf(""Level %d\t"", i);
        print(&head);
        propagate(&head);
        printf(""\n"");
    }
    printf(""Level %d\t"", levels);
    print(&head);

    // delete all memory allocated
    free_memory(head.next);

    return 0;
}"
fib,"unsigned long n, unsigned long *C, unsigned long *D",,null,"void fib(unsigned long n, unsigned long *C, unsigned long *D)
{
    // Out of Range checking
    // commented out since `n` is unsigned integer
    // if (n < 0)
    // {
    //     printf(""\nNo Such term !\n"");
    //     exit(0);
    // }

    unsigned long a, b, c, d;

    if (n == 0)
    {
        C[0] = 0;
        if (D) /* if D is not NULL */
            D[0] = 1;
        return;
    }

    fib(n >> 1, &c, &d); /* Compute F(n/2) */

    a = c * ((d << 1) - c);
    b = c * c + d * d;
    if (n % 2 == 0) /* If n is even */
    {
        C[0] = a;
        if (D)
            D[0] = b;
        return;
    }

    /**< If n is odd */
    C[0] = b;
    if (D) /* if D is not NULL */
        D[0] = a + b;
    return;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    unsigned long number, result;

    setlocale(LC_NUMERIC, """");  // format the printf output

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf(""Enter the value of n(n starts from 0 ): "");
        scanf(""%lu"", &number);
    }

    fib(number, &result, NULL);

    printf(""The nth term is : %'lu \n"", result);

    return 0;
}"
main,,,0,"int main()
{
    int n = 0; /* for user input */

    printf(""\t\tPrim factoriziation\n\n"");
    printf(""positive integer (> 1) ? "");
    scanf(""%d"", &n);
    Range r = int_fact(n);
    printf(""\nThe factoriziation are: "");
    print_arr(r);
    destroy(r);
    return 0;
}"
print_arr,Range pStr,,null,"
void print_arr(Range pStr)
{
    assert(pStr); /* checks whether pStr is a null-pointer */
    int i = 0;
    printf(""\n"");
    for (i; i < pStr->length; i++)
    {
        if (i == 0)
            printf(""%d"", pStr->range[0]);
        else
            printf(""-%d"", pStr->range[i]);
    }
    printf(""\n"");
}"
increase,"int *arr, int len",,tmp,"
int *increase(int *arr, int len)
{
    assert(arr); /* checks whether arr is a null-pointer */
    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));
    assert(tmp);
    return tmp;
    //    assert(arr);
}"
destroy,Range r,assert(arr);,null,"
void destroy(Range r)
{
    free(r->range);
    free(r);
}"
GCD,"int x, int y",,"x | GCD(y, x % y)","
int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}"
main,,,,"
int main()
{
    int a, b;
    printf(""Input two numbers:\n"");
    scanf(""%d %d"", &a, &b);
    printf(""Greatest common divisor: %d\n"", GCD(a, b));
}"
delete_number,large_num *num,,null,"void delete_number(large_num *num)
{
    free(num->digits);
    free(num);
}"
add_digit,"large_num *num, unsigned int value",,null,"void add_digit(large_num *num, unsigned int value)
{
    if (value > 9)
    {
        fprintf(stderr, ""digit > 9!!\n"");
        delete_number(num);
        exit(EXIT_FAILURE);
    }

    num->num_digits++;
    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));
    num->digits[num->num_digits - 1] = value;
}"
multiply,"large_num *num, unsigned long n",,null,"void multiply(large_num *num, unsigned long n)
{
    int i;
    unsigned long carry = 0, temp;
    for (i = 0; i < num->num_digits; i++)
    {
        temp = num->digits[i] * n;
        temp += carry;
        if (temp < 10)
            carry = 0;
        else
        {
            carry = temp / 10;
            temp = temp % 10;
        }
        num->digits[i] = temp;
    }

    while (carry != 0)
    {
        add_digit(num, carry % 10);
        carry /= 10;
    }
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    int number, i;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf(""Enter the value of n(n starts from 0 ): "");
        scanf(""%d"", &number);
    }

    large_num *result = new_number();

    clock_t start_time = clock();
    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */
        multiply(result, i);
    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;
    // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC;

    printf(""%d! = "", number);
    for (i = result->num_digits; i > 0; i--)
        putchar(result->digits[i - 1] + '0');
    printf(""\nTime taken: %.4g ms\n"", time_taken);

    delete_number(result);
    return 0;
}"
test,,,null,"void test()
{
    /* all the prime numbers less than 100 */
    int primers[] = {2,  3,  5,  7,  11, 13, 17, 19, 23, 29, 31, 37, 41,
                     43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
    for (size_t i = 0, size = sizeof(primers) / sizeof(primers[0]); i < size;
         ++i)
    {
        assert(isPrime(primers[i]));
    }

    /* Example Non-prime numbers */
    int NonPrimers[] = {-1, 0, 1, 4, 6, 8, 9, 10};
    for (size_t i = 0, size = sizeof(NonPrimers) / sizeof(NonPrimers[0]);
         i < size; ++i)
    {
        assert(!isPrime(NonPrimers[i]));
    }
}"
main,,"Test function
@return void",0,"int main()
{
    test();
    return 0;
}"
prime,int *p,,null,"void prime(int *p)
{
	for(long long int i=3;i<=MAX_SIZE;i+=2) { p[i]=1; }
	for(long long int i=3;i<=MAX_SIZE;i+=2)
	{
		if(p[i]==1) {
		    for(long long int j=i*i;j<=MAX_SIZE;j+=i) {
			p[j]=0;
		    }
		}
	}
	p[2]=1;
	p[0]=p[1]=0;    
}"
count,"int *arr, const int size",,k,"int count(int *arr, const int size){
  int k=0;
  for(int i=0;i<=size;i++){
    if(arr[i]==1){
      k++;
    }
  }
  return k;
}"
test,,,null,"static void test()
{
    // Test Case 1
    const int size = 10; /* array size */
    printf(""Test Case 1..."");
    int arr[1000005]={0};   /* array to store prime numbers */
    prime(arr);
    assert(count(arr,size)==4);
    printf(""Passed\n"");
}"
main,"int argc, const char *argv[]",Test Case 1,0,"int main(int argc, const char *argv[])
{
    test();	// execute the tests
    return 0;
}"
to_polar,"double x, double y, double *r, double *theta",,null,"void to_polar(double x, double y, double *r, double *theta)
{
    double thetaFinal = 0.f;

    *r = sqrt(x * x + y * y);

    if (x != 0)
    {
        if (y != 0)
        {
            *theta = atan(y / x);
            if ((x > 0 && y > 0) || (x == -y))
            {  // Q1
                thetaFinal = *theta;
            }
            else if (x < 0 && y > 0)
            {  // Q2
                thetaFinal = *theta + M_PI;
            }
            else if (x < 0 && y < 0)
            {  // Q3
                thetaFinal = *theta - M_PI;
            }
            else if (x > 0 && y < 0)
            {  // Q4
                thetaFinal = 2 * M_PI - *theta;
            }
            else
            {
                fprintf(stderr, ""Should not reach here!\n"");
            }
        }
    }
    else
    {  // exceptions when no actual angle is present
        if (y > 0)
        {
            thetaFinal = M_PI / 2;
        }
        else
        {
            thetaFinal = -(M_PI / 2);
        }
    }
    if (y == 0)
    {
        if (x > 0)
        {
            thetaFinal = 0;
        }
        else
        {
            thetaFinal = -M_PI;
        }
    }

    *theta = thetaFinal;
}"
get_rand,"double lim1, double lim2",,(lim2 - lim1) * r + lim1,"double get_rand(double lim1, double lim2)
{
    double r = (double)rand() / RAND_MAX;  // value in [0,1)
    return (lim2 - lim1) * r + lim1;       // scale to range
}"
test,,,null,"void test()
{
    srand(10);
    int NUM_TESTS = 5;

    for (int i = 0; i < NUM_TESTS; i++)
    {
        double r, theta;
        printf(""Test %d.... "", i);
        double x = get_rand(-5, 5);
        double y = get_rand(-5, 5);
        printf(""(%.2g, %.2g).... "", x, y);
        to_polar(x, y, &r, &theta);
        assert(fabs(r - hypot(x, y)) < 0.01);
        assert(fabs(theta - atan2(y, x)) < 0.01);
        printf(""passed\n"");
    }
}"
main,,,0,"int main()
{
    test();

    return 0;
}"
getOne,char c,,"""IX"" | ""VIII"" | ""VII"" | ""VI"" | ""V"" | ""IV"" | ""III"" | ""II"" | ""I"" | """" | NULL","char *getOne(char c)
{
    switch (c)
    {
    case '9':
        return ""IX"";

    case '8':
        return ""VIII"";

    case '7':
        return ""VII"";

    case '6':
        return ""VI"";

    case '5':
        return ""V"";

    case '4':
        return ""IV"";

    case '3':
        return ""III"";

    case '2':
        return ""II"";

    case '1':
        return ""I"";

    case '0':
        return """";

    default:
        return NULL;
    }
}"
getTen,char c,,"""XC"" | ""LXXX"" | ""LXX"" | ""LX"" | ""L"" | ""XL"" | ""XXX"" | ""XX"" | ""X"" | """" | NULL","
char *getTen(char c)
{
    switch (c)
    {
    case '9':
        return ""XC"";

    case '8':
        return ""LXXX"";

    case '7':
        return ""LXX"";

    case '6':
        return ""LX"";

    case '5':
        return ""L"";

    case '4':
        return ""XL"";

    case '3':
        return ""XXX"";

    case '2':
        return ""XX"";

    case '1':
        return ""X"";

    case '0':
        return """";

    default:
        return NULL;
    }
}"
getHundred,char c,,"""CM"" | ""DCCC"" | ""DCC"" | ""DC"" | ""D"" | ""CD"" | ""CCC"" | ""CC"" | ""C"" | """" | NULL","
char *getHundred(char c)
{
    switch (c)
    {
    case '9':
        return ""CM"";

    case '8':
        return ""DCCC"";

    case '7':
        return ""DCC"";

    case '6':
        return ""DC"";

    case '5':
        return ""D"";

    case '4':
        return ""CD"";

    case '3':
        return ""CCC"";

    case '2':
        return ""CC"";

    case '1':
        return ""C"";

    case '0':
        return """";

    default:
        return NULL;
    }
}"
getThousand,char c,,"""MMM"" | ""MM"" | ""M"" | NULL","
char *getThousand(char c)
{
    switch (c)
    {
    case '3':
        return ""MMM"";

    case '2':
        return ""MM"";

    case '1':
        return ""M"";

    default:
        return NULL;
    }
}"
intToRoman,int num,,s,"
char *intToRoman(int num)
{
    int length;
    char number[5];
    char *s = malloc(16 * sizeof(char));

    sprintf(number, ""%i"", num);

    length = strlen(number);

    switch (length)
    {
    case 4:
        sprintf(s, ""%s%s%s%s"", getThousand(number[0]), getHundred(number[1]),
                getTen(number[2]), getOne(number[3]));
        break;

    case 3:
        sprintf(s, ""%s%s%s"", getHundred(number[0]), getTen(number[1]),
                getOne(number[2]));

        break;

    case 2:
        sprintf(s, ""%s%s"", getTen(number[0]), getOne(number[1]));

        break;

    case 1:
        s = getOne(number[0]);
        break;

    default:
        break;
    }
    return s;
}"
sumOfLeftLeaves,struct TreeNode *root,,0 | root->left->val + sumOfLeftLeaves(root->right) | sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right),"
int sumOfLeftLeaves(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    if (root->left)
    {
        if (isleaf(root->left))
            return root->left->val + sumOfLeftLeaves(root->right);
    }
    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
}"
rangeBitwiseAnd,"int m, int n",,n,"int rangeBitwiseAnd(int m, int n)
{
    while (m < n)
    {
        n &= n - 1;
    }
    return n;
}"
hammingWeight,uint32_t n,,weight,"int hammingWeight(uint32_t n)
{
    int TotalBits = 32;
    int i, weight = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (n &
            (UINT32_C(1)
             << i))  // if the bit on the ith position of 32 bit input is 1,
                     // then proceed Further note the use of UINT32_C to
                     // convert 1 to unsigned 32 bit int, as just 1 is treated
                     // as int which cannot be shifted left more than 30 times
            weight += 1;
    }
    return weight;
}"
compare,"const int* i, const int* j",,*i - *j,"
int compare(const int* i, const int* j)
{
    return *i - *j;
}"
maxFrequency,"int* nums, int numsSize, int k",,result,"
int maxFrequency(int* nums, int numsSize, int k){
    qsort(nums, numsSize, sizeof (int), (int(*) (const void*, const void*)) compare);
    long* prefixSum = malloc(numsSize * sizeof(long));
    
    prefixSum[0] = nums[0];
    for(int i = 0; i < numsSize - 1; i++){
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    int leftWindowPosition = 0;
    int result = 0;
    
    for(int rightWindowPosition = 0; rightWindowPosition < numsSize; rightWindowPosition++){
        long rightSum = prefixSum[rightWindowPosition];
        long leftSum = prefixSum[leftWindowPosition];

        while ((long)nums[rightWindowPosition] * (rightWindowPosition - leftWindowPosition) - (rightSum - leftSum) > k){
            leftWindowPosition += 1;
        }

        result = max(result, rightWindowPosition - leftWindowPosition + 1);
    }

    free(prefixSum);
    return result;
}"
uniquePathsWithObstacles,"int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize",,0 | paths[obstacleGridSize - 1][*obstacleGridColSize - 1],"int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize,
                             int* obstacleGridColSize)
{
    if (obstacleGrid[obstacleGridSize - 1][*obstacleGridColSize - 1] == 1)
    {
        return 0;
    }
    int paths[obstacleGridSize][*obstacleGridColSize];
    for (int i = 0; i < obstacleGridSize; i++)
    {
        for (int j = 0; j < *obstacleGridColSize; j++)
        {
            if (obstacleGrid[i][j])
            {
                paths[i][j] = 0;
            }
            else
            {
                paths[i][j] = (i == 0 && j == 0)
                                  ? 1
                                  : ((i == 0 ? 0 : paths[i - 1][j]) +
                                     (j == 0 ? 0 : paths[i][j - 1]));
            }
        }
    }
    return paths[obstacleGridSize - 1][*obstacleGridColSize - 1];
}"
waysToSplitArray,"int* nums, int numsSize",,result,"
int waysToSplitArray(int* nums, int numsSize){
    long sumNums = 0;
    for (int i = 0; i < numsSize; i++){
        sumNums += nums[i];
    }
    
    long prefixSum = 0;
    int result = 0;
    for (int i = 0; i < numsSize - 1; i++){
        prefixSum += nums[i];
        if (prefixSum >= sumNums - prefixSum){
            result += 1;
        }
    }

    return result;
}"
getPointKey,"int i, int j, int boardSize, int boardColSize",,boardSize * boardColSize * i + j,"int getPointKey(int i, int j, int boardSize, int boardColSize){
    return boardSize * boardColSize * i + j;
}"
countCharsForStringSlice,"int* charsCounter, char* s, int length, int sign",,null,"
void countCharsForStringSlice(int* charsCounter, char* s, int length, int sign) {
    for (int i = 0; i < length; i++) {

        charsCounter[s[i] - 'a'] += sign;
    }
}"
distanceBetweenBusStops,"int *distance, int distanceSize, int start, int destination",,sum1 < sum2 ? sum1 : sum2,"int distanceBetweenBusStops(int *distance, int distanceSize, int start,
                            int destination)
{
    int sum1 = 0, sum2 = 0;
    if (start > destination)
    {
        int tmp = start;
        start = destination;
        destination = tmp;
    }
    for (auto i = 0; i < distanceSize; ++i)
    {
        if (i >= start && i < destination)
            sum1 += distance[i];
        else
            sum2 += distance[i];
    }
    return sum1 < sum2 ? sum1 : sum2;
}"
numJewelsInStones,"char *j, char *s",,sol,"
int numJewelsInStones(char *j, char *s)
{
    // as strlen is O(n), store it once rather than using it in for loop
    int cnt[500], lens = strlen(s), lenj = strlen(j), sol = 0;
    memset(cnt, 0, sizeof(cnt));

    // lookup to know which character occurs in j
    for (int i = 0; i < lenj; i++) cnt[j[i]]++;

    // count the characters in s
    for (int i = 0; i < lens; i++) sol += cnt[s[i]];

    return sol;
}"
convert,"char* in, uint16_t numRows",,out,"char* convert(char* in, uint16_t numRows)
{
    uint16_t len = strlen(in);

    if (len < numRows)
    {
        numRows = len;
    }
    char* out = calloc(len + 1, sizeof(char));

    if (numRows < 2)
    {
        memcpy(out, in, len + 1);
        return out;
    }

    uint16_t max = numRows - 1;
    uint16_t rr = 2 * max;
    uint16_t i = 0;
    uint16_t o = 0;
    uint16_t delta = 0;

    // first row
    while (i < len)
    {
        out[o++] = in[i];
        i += rr;
    }

    // middle rows
    for (uint16_t l = 1; l < max; l++)
    {
        i = l;
        delta = 2 * l;
        while (i < len)
        {
            out[o++] = in[i];
            delta = rr - delta;
            i += delta;
        }
    }

    // last row
    i = max;
    while (i < len)
    {
        out[o++] = in[i];
        i += rr;
    }

    return out;
}"
testZigZag,"char* s, int numRows, char* expected",,null,"static void testZigZag(char* s, int numRows, char* expected)
{
    char* ret = convert(s, numRows);
    int len = strlen(s);
    int cmp = strncmp(ret, expected, len);
    assert(!cmp);

    free(ret);
}"
test,,,null,"static void test()
{
    char* s01 = ""PAYPALISHIRING"";

    char* r01 = ""PINALSIGYAHRPI"";
    testZigZag(s01, 4, r01);

    char* r02 = ""PAHNAPLSIIGYIR"";
    testZigZag(s01, 3, r02);

    char* s03 = ""A"";
    testZigZag(s03, 1, s03);
    testZigZag(s03, 3, s03);

    char* s04 =
        ""cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc""
        ""ozwknwyhzgpqlwfkjqipuu""
        ""jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe""
        ""rmrnyuqnwbjjpdjhdeavkn""
        ""ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh""
        ""bctcbxdxezrzgbpfhzanff""
        ""eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch""
        ""ghrgytzdnobqcvdeqjystm""
        ""epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa""
        ""eeimidfnnzcphkflpbqsvt""
        ""dwludsgaungfzoihbxifoprwcjzsdxngtacw"";

    char* r04 =
        ""cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc""
        ""ozwknwyhzgpqlwfkjqipuu""
        ""jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe""
        ""rmrnyuqnwbjjpdjhdeavkn""
        ""ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh""
        ""bctcbxdxezrzgbpfhzanff""
        ""eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch""
        ""ghrgytzdnobqcvdeqjystm""
        ""epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa""
        ""eeimidfnnzwccpahtkgfnl""
        ""xpdbsqzsjvctwdrwploufdisxgbahuinogzf"";

    testZigZag(s04, 472, r04);
}"
main,,,0,"int main(void)
{
    test();  // run self-test implementations
    return 0;
}"
findComplement,int num,,num,"int findComplement(int num)
{
    int TotalBits = 0;
    int temp = num;
    while (temp)
    {  // To find position of MSB in given num. Since num is represented as a
       // standard size in memory, we cannot rely on size for that information.
        TotalBits++;  // increment TotalBits till temp becomes 0
        temp >>= 1;   // shift temp right by 1 bit every iteration; temp loses 1
                      // bit to underflow every iteration till it becomes 0
    }
    int i,
        flipNumber = 1;  // Eg: 1's complement of 101(binary) can be found as
                         // 101^111 (XOR with 111 flips all bits that are 1 to 0
                         // and flips 0 to 1)
    for (i = 1; i < TotalBits; i++)
    {
        flipNumber += UINT32_C(1)
                      << i;  // Note the use of unsigned int to facilitate left
                             // shift more than 31 times, if needed
    }
    num = num ^ flipNumber;
    return num;
}"
duplicateZeros,"int *arr, int arrSize",,null,"void duplicateZeros(int *arr, int arrSize)
{
    int i, start = 0;
    int *tmp = malloc(arrSize * sizeof(int));
    /* Copy arr into tmp arr */
    for (i = 0; i < arrSize; i++)
    {
        tmp[i] = arr[i];
    }
    i = 0;
    for (start = 0; start < arrSize; start++)
    {
        arr[start] = tmp[i];
        if (tmp[i] == 0)
        {
            start++;
            if (start < arrSize)
                arr[start] = 0;
        }
        i++;
    }
}"
strStr,"char *haystack, char *needle",,0 | -1 | i,"int strStr(char *haystack, char *needle)
{
    int i = 0;
    int j = 0;
    int k = 0;
    int hlen = 0;
    int nlen = 0;

    if (needle == NULL || *needle == 0)
        return 0;

    if (haystack == NULL || *haystack == 0)
        return -1;

    hlen = strlen(haystack);
    nlen = strlen(needle);

    if (hlen < nlen)
        return -1;

    for (i = 0; i <= hlen - nlen; i++)
    {
        j = 0;
        if (haystack[i] != needle[j++])
            continue;

        k = i + 1;
        for (; j < nlen; j++)
        {
            if (haystack[k] != needle[j])
            {
                break;
            }
            else
                k++;
        }
        if (j == nlen)
            return i;
    }
    return -1;
}"
fill_overlap,"char *needle, int len_needle, int *overlap",,null,"void fill_overlap(char *needle, int len_needle, int *overlap)
{
    int len = 0;
    int i = 0;

    overlap[0] = 0;

    for (i = 1; i < len_needle;)
    {
        if (needle[i] == needle[len])
        {
            len++;
            overlap[i++] = len;
        }
        else
        {
            if (len)
                len = overlap[len - 1];
            else
                overlap[i++] = 0;
        }
    }
}"
strStr,"char *haystack, char *needle",,0 | (i - j) | -1,"
int strStr(char *haystack, char *needle)
{
    int i = 0; /* index for haystack */
    int j = 0; /* index for needle */

    int len_needle = strlen(needle);
    int len_haystack = strlen(haystack);

    if (!len_needle)
        return 0;

    int overlap[len_needle];

    fill_overlap(needle, len_needle, overlap);

    while (i < len_haystack)
    {
        if (needle[j] == haystack[i])
        {
            i++;
            j++;
        }

        if (j == len_needle)
        {
            return (i - j);
        }
        else if (i < len_haystack && needle[j] != haystack[i])
        {
            if (j != 0)
                j = overlap[j - 1];
            else
                i = i + 1;
        }
    }
    return -1;
}"
searchBST,"struct TreeNode *root, int val",,"NULL | root | searchBST(root->left, val) | searchBST(root->right, val)","struct TreeNode *searchBST(struct TreeNode *root, int val)
{
    if (!root)
        return NULL;

    if (root->val == val)
    {
        return root;
    }
    else if (root->val > val)
    {
        return searchBST(root->left, val);
    }
    else
    {
        return searchBST(root->right, val);
    }
}"
recursiveSolve,"struct TreeNode* node, int* result, int minVal, int maxVal",,null,"
void recursiveSolve(struct TreeNode* node, int* result, int minVal, int maxVal){
    if (node == NULL){
        return;
    }

    *result = max(*result, abs(minVal - node->val));
    *result = max(*result, abs(maxVal - node->val));

    minVal = min(minVal, node->val);
    maxVal = max(maxVal, node->val);

    recursiveSolve(node->left, result, minVal, maxVal);
    recursiveSolve(node->right, result, minVal, maxVal);
}"
maxAncestorDiff,struct TreeNode* root,Depth First Search,result,"
int maxAncestorDiff(struct TreeNode* root){
    int result = 0;
    int maxVal = root->val;
    int minVal = root->val;
    recursiveSolve(root, &result, minVal, maxVal);
    return result;
}"
numberOfWaysForChar,"char * s, char c",,result,"long numberOfWaysForChar(char * s, char c){
    long firstBuildingAppearNumber = 0;
    long secondBuildingAppearNumber = 0;
    long result = 0;
    
    int sLength = strlen(s);
    for (int i = 0; i < sLength; i++){
        if (s[i] == c){
            result += secondBuildingAppearNumber;

            firstBuildingAppearNumber += 1;
            continue;
        }

        secondBuildingAppearNumber += firstBuildingAppearNumber;
    }
    
    return result;
        
}"
getRow,"int rowIndex, int* returnSize",,ans,"int* getRow(int rowIndex, int* returnSize){
    int colIndex = rowIndex + 1;
    int* ans = (int*) malloc(sizeof(int) * colIndex);
    for (int i = 0; i < colIndex; i++)
    {
        ans[i] = 1;
    }
    *returnSize = colIndex;
    
    for (int r = 2; r <= rowIndex; r++)
    {
        for (int c = r - 1; c > 0; c--)
        {
            ans[c] = ans[c] + ans[c-1];
        }
    }
    
    return ans;
}"
findKthSmallest,"struct TreeNode* node, int* k",,"NULL | resultNode | node | findKthSmallest(node->right, k)","struct TreeNode* findKthSmallest(struct TreeNode* node, int* k){
    if (node == NULL){
        return NULL;
    }
    
    struct TreeNode* resultNode = findKthSmallest(node->left, k);
    
    if (resultNode != NULL){
        return resultNode;
    }
    
    *k -= 1;

    if (*k == 0){
        return node;
    }
    
    return findKthSmallest(node->right, k);
}"
kthSmallest,"struct TreeNode* root, int k",Depth-First Search,"findKthSmallest(root, &k)->val","
int kthSmallest(struct TreeNode* root, int k){
    return findKthSmallest(root, &k)->val;
}"
processTraversal,"struct TreeNode *root, int *res, int *size",,null,"void processTraversal(struct TreeNode *root, int *res, int *size)
{
    if (!root)
        return;
    processTraversal(root->left, res, size);
    res[*size] = root->val;
    *size = *size + 1;
    processTraversal(root->right, res, size);
}"
inorderTraversal,"struct TreeNode *root, int *returnSize",,res,"
int *inorderTraversal(struct TreeNode *root, int *returnSize)
{
    int *res = malloc(256 * sizeof(int));
    *returnSize = 0;
    processTraversal(root, res, returnSize);
    return res;
}"
deleteMiddle,struct ListNode* head,,NULL | head,"struct ListNode* deleteMiddle(struct ListNode* head)
{
    if (head == NULL || head->next == NULL)
        return NULL;
    struct ListNode *fast, *slow, *prev;
    int n = 0;
    fast = head;
    slow = head;
    while (fast != NULL)
    {
        n = n + 1;
        fast = fast->next;
    }
    fast = head;
    while (fast->next != NULL && fast->next->next != NULL)  // finds mid node
    {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    if (n % 2 == 0)
    {
        prev = slow;
        slow = slow->next;
        prev->next = slow->next;
    }
    else
        prev->next = slow->next;
    return head;
}"
maxcmp,"int a, int b",,a >= b ? a : b,"
int maxcmp(int a, int b) { return a >= b ? a : b; }"
maxSubArray,"int *nums, int numsSize",,maxSoFar,"
int maxSubArray(int *nums, int numsSize)
{
    int maxSoFar = nums[0], maxEndingHere = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]);
        maxSoFar = maxcmp(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}"
reverse,struct ListNode *head,,res,"struct ListNode *reverse(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}"
longestDecompositionDpCached,"char* text, int textLen, int index, int* dp",,0 | dp[index],"
int longestDecompositionDpCached(char* text, int textLen, int index, int* dp){
    if (2 * index >= textLen){
        return 0;
    }

    if (dp[index] == 0){
        dp[index] = longestDecompositionDp(text, textLen, index, dp);
    }

    return dp[index];
}"
longestDecompositionDp,"char* text, int textLen, int index, int* dp",,"max(result, 2 + longestDecompositionDpCached(text, textLen, index + i + 1, dp)) | result","
int longestDecompositionDp(char* text, int textLen, int index, int* dp){
    char ch = text[index];
    int result = 1;
    
    for (int i = 0; i < (textLen - 2 * index) / 2; i++){
        if (ch == text[textLen - 1 - index - i] 
            && equalSubstrings(text, index, textLen - 1 - index - i, i + 1)){
                return max(result, 2 + longestDecompositionDpCached(text, textLen, index + i + 1, dp));
        }
    }

    return result;
}"
longestDecomposition,char * text,Dynamic programming. Up -> down approach.,result,"
int longestDecomposition(char * text){
    int textLen = strlen(text);
    int* dp = calloc(textLen, sizeof(int));
    int result = longestDecompositionDpCached(text, textLen, 0, dp);

    free(dp);
    return result;
}"
reverseBits,uint32_t n,,reverse_int,"uint32_t reverseBits(uint32_t n)
{
    uint TotalBits = 32;
    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0
    uint i;
    for (i = 0; i < TotalBits; i++)
    {
        if ((n & (UINT32_C(1)
                  << i)))  // if the bit on the ith position of 32 bit input is
                           // 1, then proceed Further note the use of UINT32_C
                           // to convert 1 to unsigned 32 bit int, since just 1
                           // is treated as int which cannot be shifted left
                           // more than 30 times
            reverse_int =
                reverse_int |
                (UINT32_C(1)
                 << (TotalBits - 1 -
                     i));  // Convert the ith bit from the end in reverse_int
                           // from 0 to 1, if ith bit from beginning in n is 1
                           // This is achieved by using bitwise OR on
                           // reverse_int (where ith bit from end is currently
                           // 0) and 1 shifted left 31 - i bits (to ith bit from
                           // the end)
    }
    return reverse_int;
}"
find,"int* sets, int index",,index,"int find(int* sets, int index){
    while (sets[index] != index){
        index = sets[index];
    }

    return index;
}"
unionSet,"int* sets, int i1, int i2",,null,"
void unionSet(int* sets, int i1, int i2){
    int i1Parent = find(sets, i1);
    int i2Parent = find(sets, i2);
    
    sets[i1Parent] = i2Parent;
}"
findRedundantConnection,"int** edges, int edgesSize, int* edgesColSize, int* returnSize",,result,"
int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){
    int setsSize = edgesSize + 1;
    int* sets = malloc(setsSize * sizeof(int));
    for (int i = 0; i < setsSize; i++){
        sets[i] = i;
    }

    int* result = malloc(2 * sizeof(int));
    *returnSize = 2;

    for (int i = 0; i < edgesSize; i++){
        int* edge = edges[i];

        int i0Parent = find(sets, edge[0]);
        int i1Parent = find(sets, edge[1]);

        if (i0Parent == i1Parent){
            result[0] = edge[0];
            result[1] = edge[1];
            continue;
        }

        unionSet(sets, i0Parent, i1Parent);
    }

    free(sets);
    return result;
}"
maxNumberOfBalloons,char *text,,min_counter_ballons,"int maxNumberOfBalloons(char *text)
{
    /*
        0 -> b,
        1 -> a,
        2 -> l,
        3 -> o,
        4 -> n
    */
    int count_letters[5] = {0};
    int i, min_counter_ballons;

    for (char *ptr = text; *ptr; ptr++)
    {
        if (*ptr == 'b')
        {
            count_letters[0]++;
        }
        else if (*ptr == 'a')
        {
            count_letters[1]++;
        }
        else if (*ptr == 'l')
        {
            count_letters[2]++;
        }
        else if (*ptr == 'o')
        {
            count_letters[3]++;
        }
        else if (*ptr == 'n')
        {
            count_letters[4]++;
        }
    }

    /* Divide by 2 the repeted letters */
    count_letters[2] /= 2;
    count_letters[3] /= 2;

    /* Max number of times which we can write ballon is equal to min value of
     * letters on count_letter */
    min_counter_ballons = count_letters[0];
    for (i = 1; i < 5; i++)
    {
        if (count_letters[i] < min_counter_ballons)
            min_counter_ballons = count_letters[i];
    }

    return min_counter_ballons;
}"
bSTIteratorNext,BSTIterator *obj,,NextValue,"int bSTIteratorNext(BSTIterator *obj)
{
    int NextValue = obj->values[obj->CurrentIndex];
    obj->CurrentIndex++;
    return NextValue;
}"
bSTIteratorFree,BSTIterator *obj,,null,"
void bSTIteratorFree(BSTIterator *obj)
{
    free(obj->values);
    free(obj);
}"
buildBST,"struct ListNode *head, struct ListNode *tail",,NULL | node,"struct TreeNode *buildBST(struct ListNode *head, struct ListNode *tail)
{
    if (head == tail)
        return NULL;
    struct ListNode *slow = head, *fast = head;
    while (fast != tail && fast->next != tail)
    {
        fast = fast->next->next;
        slow = slow->next;
    }
    struct TreeNode *node = malloc(sizeof(struct TreeNode));
    node->val = slow->val;
    node->left = buildBST(head, slow);
    node->right = buildBST(slow->next, tail);
    return node;
}"
sortedListToBST,struct ListNode *head,,"NULL | buildBST(head, NULL)","
struct TreeNode *sortedListToBST(struct ListNode *head)
{
    if (!head)
        return NULL;
    else
        return buildBST(head, NULL);
}"
sortArrayByParity,"int *A, int ASize, int *returnSize",,retArr,"int *sortArrayByParity(int *A, int ASize, int *returnSize)
{
    int *retArr = malloc(ASize * sizeof(int));
    int oddIndex = ASize - 1;
    int evenIndex = 0;
    *returnSize = ASize;
    for (int i = 0; i < ASize; i++)
    {
        if (A[i] % 2 == 0)
        {
            retArr[evenIndex] = A[i];
            evenIndex++;
        }
        else
        {
            retArr[oddIndex] = A[i];
            oddIndex--;
        }
    }

    return retArr;
}"
maxcmp,"int a, int b",,(a >= b) ? a : b,"int maxcmp(int a, int b) { return (a >= b) ? a : b; }"
maxProfit,"int *prices, int pricesSize",,maxSoFar,"int maxProfit(int *prices, int pricesSize)
{
    /* maxCur: current maximum
     * maxSoFar: found maximum for subarray so far
     */
    int maxCur = 0, maxSoFar = 0;
    for (int i = 1; i < pricesSize; i++)
    {
        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);
        maxSoFar = maxcmp(maxSoFar, maxCur);
    }
    return maxSoFar;
}"
recursiveSolve,"struct TreeNode* node, int* result",,"0 | node->val + max(leftSum, rightSum) | result","
int recursiveSolve(struct TreeNode* node, int* result){
    if (node == NULL){
        return 0;
    }

    int leftSum = max(recursiveSolve(node->left, result), 0);
    int rightSum = max(recursiveSolve(node->right, result), 0);

    // Check if it's possible to make a maximum path from left right and current node
    int maxValueNode = node->val + leftSum + rightSum;
    *result = max(maxValueNode, *result);

    // Choose the max sum val path 
    return node->val + max(leftSum, rightSum);
}

// Depth First Search
// Runtime: O(n), n - the number of nodes in tree.
// Space: O(1)
int maxPathSum(struct TreeNode* root){
    const int LOWER_BOUND = -2147483648
    int result = LOWER_BOUND;
    recursiveSolve(root, &result);
    return result;
}
"
maxPathSum,struct TreeNode* root,Depth First Search,result,"
int maxPathSum(struct TreeNode* root){
    const int LOWER_BOUND = -2147483648
    int result = LOWER_BOUND;
    recursiveSolve(root, &result);
    return result;
}"
diff,"const int* i, const int* j",,*i - *j,"int diff(const int* i, const int* j)

{
    return *i - *j;
}"
hIndex,"int* citations, int citationsSize",,i | citationsSize,"
int hIndex(int* citations, int citationsSize){
    qsort(citations, citationsSize, sizeof(int), (int(*) (const void*, const void*)) diff);

    for(int i = 0; i < citationsSize; i++){
        if (citations[citationsSize - 1 - i] <= i){
            return i;
        }
    }

    return citationsSize;
}"
minimumAverageDifference,"int* nums, int numsSize",,minIndex,"
int minimumAverageDifference(int* nums, int numsSize){
    long numsSum = 0;
    for (int i = 0; i < numsSize; i++){
        numsSum += nums[i];
    }
    
    long currSum = 0;
    long minAverage = 9223372036854775807; // Long max
    int minIndex = 0;
    
    for (int i = 0; i < numsSize; i++){
        currSum += nums[i];

        int leftItemsNumber = (numsSize - i  - 1);
        long leftItemsNumberAverage = 0;
        if (leftItemsNumber != 0){
            leftItemsNumberAverage = (numsSum - currSum) / leftItemsNumber;
        }

        long currItemsNumberAverage = currSum / (i + 1);
        long averageDiff = abs(currItemsNumberAverage - leftItemsNumberAverage);

        if (averageDiff < minAverage){
            minAverage = averageDiff;
            minIndex = i;
        }
    }

    return minIndex;
}"
cmpval,"const void *a, const void *b",,*(int *)a - *(int *)b,"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
arrayPairSum,"int *nums, int numsSize",,sum,"
int arrayPairSum(int *nums, int numsSize)
{
    int sum = 0, i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];
    return sum;
}"
tribonacci,int n,,t0 | t1 | t2,"
int tribonacci(int n){
    int t0 = 0;
    int t1 = 1;
    int t2 = 1;

    if (n == 0) {
        return t0;
    }

    if (n == 1){
        return t1;
    }

    if (n == 2){
        return t2;
    }

    for (int i = 0; i < n - 2; i++){
        int nextT = t0 + t1 + t2;
        t0 = t1;
        t1 = t2;
        t2 = nextT;
    }

    return t2;
}"
myAtoi,char *str,,__INT_MAX__ * -1 - 1 | __INT_MAX__ | result,"int myAtoi(char *str)
{
    int minusFlag = 0;
    int length = strlen(str);
    long int result = 0;
    char numberBuffer[11];
    int counter = 0;
    while (str[counter] == ' ')
    {
        counter++;
    }
    str = &str[counter];
    counter = 0;

    for (int i = 0; i < length; i++)
    {
        if (i == 0)
        {
            if (str[0] == '-')
            {
                minusFlag = 1;
                i++;
            }
            else if (str[0] == '+')
            {
                i++;
            }
        }
        if (counter > 10)
        {
            if (minusFlag)
            {
                return __INT_MAX__ * -1 - 1;
            }
            else
            {
                return __INT_MAX__;
            }
        }

        if (str[i] < '0' || str[i] > '9')
        {
            break;
        }
        if (counter == 0 && str[i] == '0')
        {
            continue;
        }

        numberBuffer[counter] = str[i];
        counter++;
    }

    int i = 0;
    while (counter > 0)
    {
        if (minusFlag)
        {
            result -= (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        else
        {
            result += (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        i++;
        counter--;
    }

    if (result > __INT_MAX__)
    {
        return __INT_MAX__;
    }
    else if (result < __INT_MAX__ * -1 - 1)
    {
        return __INT_MAX__ * -1 - 1;
    }
    return result;
}"
addTwoNumbers,"struct ListNode *l1, struct ListNode *l2",,head,"struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *head = NULL;
    struct ListNode *walk = NULL;
    struct ListNode *tmp = NULL;

    int carry = 0;
    int val1 = 0;
    int val2 = 0;
    int val = 0;

    while (l1 != NULL || l2 != NULL || carry)
    {
        val1 = 0;
        val2 = 0;
        val = 0;

        if (l1)
        {
            val1 = l1->val;
            l1 = l1->next;
        }

        if (l2)
        {
            val2 = l2->val;
            l2 = l2->next;
        }

        val = carry + val1 + val2;
        carry = val / 10;

        tmp = malloc(sizeof(struct ListNode));
        tmp->val = val % 10;
        tmp->next = NULL;

        if (!head)
        {
            head = walk = tmp;
        }
        else
        {
            walk->next = tmp;
            walk = walk->next;
        }
    }

    return head;
}"
sumEvenAfterQueries,"int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize",,result,"
int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){
    int summ = 0;
    int* result = malloc(queriesSize * sizeof(int));
    *returnSize = queriesSize;
    
    for(int i = 0; i < numsSize; i++){
        if (nums[i] % 2 == 0) {
            summ += nums[i];
        }
    }
    
    for(int i = 0; i < queriesSize; i++){
        int* query = queries[i];
        int val = query[0];
        int index = query[1];
        
        // sub index value from summ if it's even
        if (nums[index] % 2 == 0) {
            summ -= nums[index];
        }

        // modify the nums[index] value
        nums[index] += val;

        // add index value from summ if it's even
        if (nums[index] % 2 == 0) {
            summ += nums[index];
        }
        
        result[i] = summ;
    }
    
    return result;
}"
moveZeroes,"int *nums, int numsSize",,null,"void moveZeroes(int *nums, int numsSize)
{
    int i = 0, start = 0;

    for (i = 0; i < numsSize; i++)
    {
        if (nums[i])
            nums[start++] = nums[i];
    }

    for (start; start < numsSize; start++)
    {
        nums[start] = 0;
    }
}"
rangeSumBST,"struct TreeNode *root, int L, int R",,"0 | root->val + rangeSumBST(root->left, L, R) +
               rangeSumBST(root->right, L, R) | rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R)","int rangeSumBST(struct TreeNode *root, int L, int R)
{
    if (root == NULL)
    {
        return 0;
    }
    else if (root->val >= L && root->val <= R)
    {
        return root->val + rangeSumBST(root->left, L, R) +
               rangeSumBST(root->right, L, R);
    }
    else
    {
        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
    }
}"
plusOne,"int *digits, int digitsSize, int *returnSize",,digits | newdigit,"int *plusOne(int *digits, int digitsSize, int *returnSize)
{
    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (digits[i] < 9)
        {
            digits[i]++;
            *returnSize = digitsSize;
            return digits;
        }
        else
        {
            digits[i] = 0;
        }
    }

    int *newdigit = (int *)malloc((digitsSize + 1) * sizeof(int));
    newdigit[0] = 1;
    for (int i = 1; i < (digitsSize + 1); i++)
    {
        newdigit[i] = digits[i - 1];
    }
    *returnSize = digitsSize + 1;
    return newdigit;
}"
numOfSubarrays,"int* arr, int arrSize",,result % modulo,"
int numOfSubarrays(int* arr, int arrSize){
    int result = 0;
    int curSumm = 0;
    int currOddSumms = 0;
    int currEvenSumm = 0;
    int modulo = 1000000000 + 7;

    for(int i = 0; i < arrSize; i++){
        curSumm += arr[i];
        if (curSumm % 2 == 0){
            currEvenSumm++;
            result = (result + currOddSumms) % modulo;
        }
        else {
            currOddSumms++;
            result = (result + 1 + currEvenSumm) % modulo;
        }
    }

    return result % modulo;
}"
minPathCost,"int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize",,minValue,"
int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){
    int* dp = (int*)calloc(gridColSize[0], sizeof(int));
    int* newDp = (int*)calloc(gridColSize[0], sizeof(int));
    
    for(int i = 0; i < gridSize - 1; i++){
        int currGridColSize = gridColSize[i];
        for(int j = 0; j < currGridColSize; j++){
            newDp[j] = -1;
        }
        
        for(int j = 0; j < currGridColSize; j++){
            int currGridItem = grid[i][j];
            for(int z = 0; z < currGridColSize; z++){
                int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem;
                
                newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost);
            }
        }
        
        for(int j = 0; j < currGridColSize; j++){
            dp[j] = newDp[j];
        }
    }
    
    // Find minimum value.
    int minValue = dp[0] + grid[gridSize - 1][0];
    for(int j = 1; j < gridColSize[0]; j++){
        minValue = min(minValue, dp[j] + grid[gridSize - 1][j]);
    }
    
    // free resources
    free(dp);
    free(newDp);
    
    return minValue;
}"
search,"int *nums, int numsSize, int target",,mid | -1,"int search(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (target > nums[mid])
        {
            low = mid + 1;
        }
        else if (target < nums[mid])
        {
            high = mid - 1;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}"
cmpint,"const void *a, const void *b",,*(int *)a - *(int *)b,"int cmpint(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
search,"int *nums, int numsSize, int target",Another solution: Using bsearch(),(ret - nums) | -1,"
int search(int *nums, int numsSize, int target)
{
    int *ret = bsearch(&target, nums, numsSize, sizeof(int), cmpint);
    if (ret)
        return (ret - nums);
    else
        return -1;
}"
maxval,"int a, int b",,a | b,"int maxval(int a, int b)
{
    if (a > b)
        return a;
    else
        return b;
}"
maxDepth,struct TreeNode *root,,"0 | 1 + maxval(maxDepth(root->left), maxDepth(root->right))","
int maxDepth(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + maxval(maxDepth(root->left), maxDepth(root->right));
}"
longestSquareStreakDp,"int* numsSet, int numsSetSize, int* dp, long num",,dp[num],"
int longestSquareStreakDp(int* numsSet, int numsSetSize, int* dp, long num){
    if (dp[num] != 0){
        return dp[num];
    }

    long numSquare = num * num;

    dp[num] = 1;
    if (numSquare <= numsSetSize && numsSet[numSquare] == 1){
        dp[num] += longestSquareStreakDp(numsSet, numsSetSize, dp, numSquare);
    }

    return dp[num];
}"
longestSquareStreak,"int* nums, int numsSize",,result,"
int longestSquareStreak(int* nums, int numsSize){
    // Find nums maximum
    int numMax = 0;
    for(int i = 0; i < numsSize; i++){
        numMax = max(numMax, nums[i]);
    }

    int* numsSet = calloc(numMax + 1, sizeof(int));
    int* dp = calloc(numMax + 1, sizeof(int));
    
    // Init set of nums
    for(int i = 0; i < numsSize; i++){
        numsSet[nums[i]] = 1;
    }

    // Find result
    int result = -1;
    for(int i = 0; i < numsSize; i++){
        long num = nums[i];
        long numSquare = num * num;

        if (numSquare > numMax || numsSet[numSquare] == 0){
            continue;
        }

        result = max(result, 1 + longestSquareStreakDp(numsSet, numMax, dp, numSquare));
    }

    free(dp);
    free(numsSet);
    return result;
}"
deleteDuplicates,struct ListNode *head,,NULL | deleteDuplicates(head->next) | head,"struct ListNode *deleteDuplicates(struct ListNode *head)
{
    if (head == NULL)
        return NULL;

    if (head->next && head->val == head->next->val)
    {
        /* Remove all duplicate numbers */
        while (head->next && head->val == head->next->val)
        {
            head = head->next;
        }
        return deleteDuplicates(head->next);
    }
    else
    {
        head->next = deleteDuplicates(head->next);
    }
    return head;
}"
firstBadVersion,int n,,low,"
int firstBadVersion(int n)
{
    int low = 1, high = n;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (isBadVersion(mid))
        {
            high = mid - 1;
        }
        else
        {
            low = mid + 1;
        }
    }
    return low;
}"
numcmp,"const void *a, const void *b",,*(int *)a - *(int *)b,"int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
maximizeTarget,"char * answerKey, char targetChar, int k",,result,"
int maximizeTarget(char * answerKey, char targetChar, int k){
    int leftIndex = -1;
    int result = 0;
    int currTargetChars = 0;
    int lenAnswerKey = strlen(answerKey);

    for (int rightIndex = 0; rightIndex < lenAnswerKey; rightIndex++){
        char ch = answerKey[rightIndex];
        if (ch == targetChar){
            currTargetChars++;
        }
        
        while (rightIndex - leftIndex > currTargetChars + k) {
            leftIndex++;
            if (answerKey[leftIndex] == targetChar){
                currTargetChars--;
            }
        }
        
        result = max(result, rightIndex - leftIndex);
    }
    
    return result;
}"
maxConsecutiveAnswers,"char * answerKey, int k",Use sliding window approach + two pointers.,"max(maximizeTarget(answerKey, 'T', k), maximizeTarget(answerKey, 'F', k))","
int maxConsecutiveAnswers(char * answerKey, int k){
    return max(maximizeTarget(answerKey, 'T', k), maximizeTarget(answerKey, 'F', k));
}"
trap,"int* height, int heightSize",,result,"
int trap(int* height, int heightSize){
    int* rightMaxStack = malloc(heightSize * sizeof(int));
    rightMaxStack[heightSize - 1] = height[heightSize - 1];

    for (int i = heightSize - 2; i >= 0; i--){
        rightMaxStack[i] = max(rightMaxStack[i + 1], height[i]);
    }

    int leftMax = 0;
    int result = 0;
    for (int i = 0; i < heightSize; i++){
        leftMax = max(leftMax, height[i]);
        result += max(0, min(leftMax, rightMaxStack[i]) - height[i]);
    }
    
    free(rightMaxStack);
    return result;
}"
nextLargerNodes,"struct ListNode* head, int* returnSize",,output,"int* nextLargerNodes(struct ListNode* head, int* returnSize)
{
    int *output, count = 0;
    struct ListNode *tmp = head, *tmp2;
    for (; tmp != NULL; tmp = tmp->next, count++)
        ;
    output = (int*)calloc(count, sizeof(int));
    *returnSize = count;
    for (tmp = head, count = 0; tmp->next != NULL; tmp = tmp->next, count++)
    {
        for (tmp2 = tmp->next; tmp2 != NULL; tmp2 = tmp2->next)
        {
            if (tmp2->val > tmp->val)
            {
                output[count] = tmp2->val;
                break;
            }
        }
    }
    return output;
}"
findLengthOfLCIS,"int *nums, int numsSize",,0 | maxval,"int findLengthOfLCIS(int *nums, int numsSize)
{
    int maxval = 1, i, count = 1;
    if (numsSize == 0)
        return 0;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] > nums[i - 1])
        {
            count++;
            if (count >= maxval)
                maxval = count;
        }
        else
        {
            count = 1;
        }
    }
    return maxval;
}"
reverseList,struct ListNode *head,,res,"struct ListNode *reverseList(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}"
countSubstrings,char *s,,count,"int countSubstrings(char *s)
{
    int len = strlen(s);
    int i;
    int count = 0;
    for (i = 0; i < len; i++)
    {
        // cases handled for both odd and even lenghted Palindrome

        count += countPalin(s, i, i, len);
        if (i != len - 1)
            count += countPalin(s, i, i + 1, len);
    }
    return count;
}"
countPalin,"char *s, int head, int tail, int len",,ret,"
int countPalin(char *s, int head, int tail, int len)
{
    int ret = (s[head] == s[tail]) ? 1 : 0;
    if (ret && head - 1 >= 0 && tail + 1 < len)
        ret += countPalin(s, head - 1, tail + 1, len);
    return ret;
}"
get_letters,char digit,,"""abc"" | ""def"" | ""ghi"" | ""jkl"" | ""mno"" | ""pqrs"" | ""tuv"" | ""wxyz"" | """"","
char *get_letters(char digit) {
    switch (digit) {
        case '2':
            return ""abc"";
        case '3':
            return ""def"";
        case '4':
            return ""ghi"";
        case '5':
            return ""jkl"";
        case '6':
            return ""mno"";
        case '7':
            return ""pqrs"";
        case '8':
            return ""tuv"";
        case '9':
            return ""wxyz"";
        default:
            return """";
    }
}"
invertTree,struct TreeNode *root,,NULL | root,"struct TreeNode *invertTree(struct TreeNode *root)
{
    struct TreeNode *tmp;
    if (root == NULL)
        return NULL;
    tmp = root->left;
    root->left = root->right;
    root->right = tmp;

    invertTree(root->left);
    invertTree(root->right);
    return root;
}"
removeElement,"int *nums, int numsSize, int val",,start,"int removeElement(int *nums, int numsSize, int val)
{
    int i, start = 0;
    for (i = 0; i < numsSize; i++)
    {
        if (nums[i] != val)
            nums[start++] = nums[i];
    }
    return start;
}"
minFallingPathSum,"int** matrix, int matrixSize, int* matrixColSize",,result,"
int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){
    int* dp = calloc(matrixSize, sizeof(int));

    for (int i = 0; i < matrixSize; i++){
        int* nextDp = calloc(matrixSize, sizeof(int));

        for (int j = 0; j < matrixSize; j++){
            nextDp[j] = dp[j] + matrix[i][j];

            // If not the first column - try to find minimum in prev column
            if(j > 0){
                nextDp[j] = min(nextDp[j], dp[j - 1] + matrix[i][j]);
            }

            // If not the last column - try to find minimum in next column
            if (j < matrixSize - 1){
                nextDp[j] = min(nextDp[j], dp[j + 1] + matrix[i][j]);
            }
        }

        free(dp);
        dp = nextDp;
    }

    int result = dp[0];
    for (int j = 1; j < matrixSize; j++){
        result = min(result, dp[j]);
    }

    free(dp);
    return result;
}"
cmpval,"const void *a, const void *b",,*(int *)a - *(int *)b,"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
findDuplicate,"int *nums, int numsSize",,nums[i],"
int findDuplicate(int *nums, int numsSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize - 1; i++)
    {
        if (nums[i] == nums[i + 1])
            return nums[i];
    }
    return nums[i];
}"
uniquePaths,"int m, int n",,dp[m - 1][n - 1],"
int uniquePaths(int m, int n)
{
    int dp[m][n];

    for (int column = 0; column < n; column++)
    {
        dp[0][column] = 1;
    }

    for (int row = 1; row < m; row++)
    {
        dp[row][0] = 1;
    }

    for (int row = 1; row < m; row++)
    {
        for (int column = 1; column < n; column++)
        {
            dp[row][column] = dp[row - 1][column] + dp[row][column - 1];
        }
    }
    return dp[m - 1][n - 1];
}"
middleNode,struct ListNode *head,,slow,"struct ListNode *middleNode(struct ListNode *head)
{
    struct ListNode *fast, *slow;
    fast = slow = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}"
minOperations,"char* boxes, int* returnSize",,result,"
int* minOperations(char* boxes, int* returnSize){
    int leftOnes = 0;
    int leftCommonDistance = 0;
    
    int rightOnes = 0;
    int rightCommonDistance = 0;
    
    int boxesLength = strlen(boxes);

    *returnSize = boxesLength;
    int* result = malloc(boxesLength * sizeof(int));
    
    for (int i = 0; i < boxesLength; i++){
        if (boxes[i] == '1'){
            rightOnes += 1;
            rightCommonDistance += i;
        }
    }
    
    for (int i = 0; i < boxesLength; i++){
        if (boxes[i] == '1'){
            rightOnes -= 1;
            leftOnes += 1;
        }
        
        result[i] = rightCommonDistance + leftCommonDistance;
        rightCommonDistance -= rightOnes;
        leftCommonDistance += leftOnes;
    }

    return result;
}"
deleteDuplicates,struct ListNode *head,,head,"
struct ListNode *deleteDuplicates(struct ListNode *head)
{
    struct ListNode *cur = head;
    while (cur && cur->next)
    {
        if (cur->val == cur->next->val)
            cur->next = cur->next->next;
        else
            cur = cur->next;
    }
    return head;
}"
swap,"int *x, int *y",,null,"void swap(int *x, int *y){
    if (x==y)
        return;
   *x = *x + *y;
    *y= *x - *y;
    *x= *x - *y;
}"
sortColors,"int* arr, int n",,null,"
void sortColors(int* arr, int n){
    int start=0, mid=0, end=n-1;
    while(mid<=end){
        if(arr[mid]==1)
            mid++;
        else if(arr[mid]==0){
            swap(&arr[mid],&arr[start]);
            mid++;
            start++;
        }
        else{
            swap(&arr[mid],&arr[end]);
            end--;
        }
    }
}"
powPositive,"double x, int n",,x | result,"double powPositive(double x, int n){
    if (n == 1){
        return x;
    }

    double val = powPositive(x, n / 2);
    double result = val * val;
    
    // if n is odd
    if (n & 1 > 0){
        result *= x;
    }

    return result;
}"
myPow,"double x, int n",,"1 | 1 / (powPositive(x, -(n + 1)) * x) | 1 / powPositive(x, -n) | powPositive(x, n)","
double myPow(double x, int n){
    if (n == 0){
        return 1;
    }

    const int LOWER_BOUND = -2147483648;

    // n is the minimum int, couldn't be converted in -n because maximum is 2147483647.
    // this case we use (1 / pow(x, -(n + 1))) * n
    if (n == LOWER_BOUND){
        return 1 / (powPositive(x, -(n + 1)) * x);
    }

    // 1 / pow(x, -(n + 1))
    if (n < 0){
        return 1 / powPositive(x, -n);
    }

    return powPositive(x, n);
}
"
bstFromPreorder,"int* preorder, int preorderSize",,new,"struct TreeNode* bstFromPreorder(int* preorder, int preorderSize)
{
    struct TreeNode* new;
    int left_ptr;

    new = malloc(sizeof(struct TreeNode));
    new->val = preorder[0];

    if (preorderSize == 1)
    {
        new->right = NULL;
        new->left = NULL;
        return new;
    }

    left_ptr = 1;
    while ((left_ptr < preorderSize) && (preorder[left_ptr] < preorder[0]))
        left_ptr++;
    if (left_ptr == 1)
        new->left = NULL;
    else
        new->left = bstFromPreorder(preorder + 1, left_ptr - 1);
    if (left_ptr < preorderSize)
        new->right =
            bstFromPreorder(preorder + left_ptr, preorderSize - left_ptr);
    else
        new->right = NULL;

    return new;
}"
intersectionSize,"int p11, int p12, int p21, int p22",,"0 | min(p12 - p21, p22 - p21) | min(p22 - p11, p12 - p11)","
int intersectionSize(int p11, int p12, int p21, int p22){
    if (p11 >= p22 || p12 <= p21){
        return 0;
    }

    if (p11 < p21){
        return min(p12 - p21, p22 - p21);
    }

    return min(p22 - p11, p12 - p11);
}"
computeArea,"int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2",,areaA + areaB - areaInteresection,"
int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){
    int areaA = (ay2 - ay1) * (ax2 - ax1);
    int areaB = (by2 - by1) * (bx2 - bx1);
    int areaInteresection = intersectionSize(ax1, ax2, bx1, bx2) * intersectionSize(ay1, ay2, by1, by2);
    
    return areaA + areaB - areaInteresection;
}"
mergeTwoLists,"struct ListNode *l1, struct ListNode *l2",,l2 | l1 | list | NULL,"struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *list = NULL;
    struct ListNode *tmp = NULL;

    if (!l1)
        return l2;
    if (!l2)
        return l1;

    if (l1 && l2)
    {
        if (l1->val < l2->val)
        {
            list = tmp = l1;
            l1 = l1->next;
        }
        else
        {
            list = tmp = l2;
            l2 = l2->next;
        }

        while (l1 && l2)
        {
            if (l1->val < l2->val)
            {
                tmp->next = l1;
                l1 = l1->next;
            }
            else
            {
                tmp->next = l2;
                l2 = l2->next;
            }
            tmp = tmp->next;
        }

        if (l1)
            tmp->next = l1;
        if (l2)
            tmp->next = l2;

        return list;
    }

    return NULL;
}"
mergeTwoLists,"struct ListNode *l1, struct ListNode *l2",,l2 | l1,"struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    if (!l1)
        return l2;
    if (!l2)
        return l1;
    if (l1->val < l2->val)
    {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else
    {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}"
getEndValidIndexFromDp,"int* dp, char* s, int index, int lenS",,notValid | dp[index],"
int getEndValidIndexFromDp(int* dp, char* s, int index, int lenS){
    if (index >= lenS){
        return notValid;
    }

    if (dp[index] == notCalculated){
        dp[index] = getEndValidIndex(dp, s, index, lenS);
    }

    return dp[index];
}"
getEndValidIndex,"int* dp, char* s, int index, int lenS",,"notValid | max(index + 1, getEndValidIndexFromDp(dp, s, index + 2, lenS)) | max(nextEndValidIndex + 1, getEndValidIndexFromDp(dp, s, nextEndValidIndex + 2, lenS))","
int getEndValidIndex(int* dp, char* s, int index, int lenS){
    if (s[index] == '('){
        if (index + 1 >= lenS){
            return notValid;
        }

        if (s[index + 1] == ')'){
            return max(index + 1, getEndValidIndexFromDp(dp, s, index + 2, lenS));
        }
        
        int nextEndValidIndex = getEndValidIndexFromDp(dp, s, index + 1, lenS);
        if (nextEndValidIndex == notValid || nextEndValidIndex + 1 >= lenS || s[nextEndValidIndex + 1] != ')') {
            return notValid;
        }
        
        return max(nextEndValidIndex + 1, getEndValidIndexFromDp(dp, s, nextEndValidIndex + 2, lenS));
    }
    
    return notValid;
}"
longestValidParentheses,char * s,Dynamic Programming. UP -> down approach.,0 | result,"
int longestValidParentheses(char * s){
    int lenS = strlen(s);
    if (lenS == 0){
        return 0;
    }

    int* dp = malloc(lenS * sizeof(int));
    for(int i = 0; i < lenS; i++){
        dp[i] = notCalculated;
    }

    int result = 0;
    for(int i = 0; i < lenS; i++){
        result = max(result, getEndValidIndexFromDp(dp, s, i, lenS) - i + 1);
    }
    
    free(dp);
    return result;
}"
freeList,struct ListItem* target,,null,"
void freeList(struct ListItem* target){
    if (target->next != NULL){
        freeList(target->next);
    }
    
    free(target);
}"
lowestCommonAncestor,"struct TreeNode* root, struct TreeNode* p, struct TreeNode* q",Find the longest common path in paths.,lowestTreeNode,"
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    struct ListItem* pPath = malloc(sizeof(struct ListItem));
    struct ListItem* qPath = malloc(sizeof(struct ListItem));
    
    findTargetPath(root, p, pPath);
    findTargetPath(root, q, qPath);
    
    struct TreeNode* lowestTreeNode = NULL;
    struct ListItem* pPathCursor = pPath->next;
    struct ListItem* qPathCursor = qPath->next;
    while(pPathCursor != NULL && qPathCursor != NULL) {
        if (pPathCursor->node->val == qPathCursor->node->val){
            lowestTreeNode = pPathCursor->node;
            pPathCursor = pPathCursor->next;
            qPathCursor = qPathCursor->next;
            continue;
        }

        break;
    }
    
    freeList(pPath);
    freeList(qPath);
    
    return lowestTreeNode;
}"
findMedianSortedArrays,"int *nums1, int nums1Size, int *nums2, int nums2Size",,v[0] | (n1 + n2) / 2 | v[new_index],"
double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2,
                              int nums2Size)
{
    int index1 = 0;
    int index2 = 0;
    int v[nums1Size + nums2Size];
    int v_index = 0;

    while (index1 < nums1Size && index2 < nums2Size)
    {
        if (nums1[index1] <= nums2[index2])
        {
            v[v_index++] = nums1[index1++];
        }
        else
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (index1 < nums1Size)
    {
        while (index1 < nums1Size)
        {
            v[v_index++] = nums1[index1++];
        }
    }
    if (index2 < nums2Size)
    {
        while (index2 < nums2Size)
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (v_index == 1)
    {
        return v[0];
    }
    if (v_index % 2 == 0)
    {
        double n1, n2;
        n1 = v[v_index / 2];
        n2 = v[(v_index / 2) - 1];
        return (n1 + n2) / 2;
    }
    int new_index = (int)v_index / 2;
    int i = 0;
    return v[new_index];
}"
minimumDeletions,char * s,,"min(aStateValue, bStateValue)","
int minimumDeletions(char * s){
    int len = strlen(s);
    
    int aStateValue = s[0] == 'b';

    int bStateValue = 0;
    
    int newAStateValue;
    int newBStateValue;

    for(int i = 1; i < len; i++){
        newAStateValue = aStateValue + (s[i] == 'b');

        newBStateValue = min(
                               aStateValue,
                               bStateValue + (s[i] == 'a')
                             );
            
        aStateValue = newAStateValue;
        bStateValue = newBStateValue;
    }
    
    return min(aStateValue, bStateValue);
}"
compare,"const void* i, const void* j",,*((int*)i) - *((int*)j),"int compare(const void* i, const void* j)
{
    return *((int*)i) - *((int*)j);
}"
maxIceCream,"int* costs, int costsSize, int coins",,result,"
int maxIceCream(int* costs, int costsSize, int coins){
    qsort(costs, costsSize, sizeof(int), compare);

    int result = 0;
    int leftCoins = coins;
    for (int i = 0; i < costsSize; i++){
        if (costs[i] > leftCoins){
            break;
        }

        leftCoins -= costs[i];
        result++;
    }

    return result;
}"
findJudge,"int n, int** trust, int trustSize, int* trustColSize",,-1 | potentialJudjeNumber,"
int findJudge(int n, int** trust, int trustSize, int* trustColSize){
    int* personsToTrust = calloc(n + 1, sizeof(int));
    int* personsFromTrust = calloc(n + 1, sizeof(int));

    for(int i = 0; i < trustSize; i++){
        int* currentTrust = trust[i];
        personsToTrust[currentTrust[1]] += 1;
        personsFromTrust[currentTrust[0]] += 1;
    }

    int potentialJudjeNumber = -1;
    for(int i = 1; i < n + 1; i++){
        if (personsToTrust[i] == n - 1 && personsFromTrust[i] == 0){
            if (potentialJudjeNumber > -1){
                return -1;
            }

            potentialJudjeNumber = i;
        }
    }

    free(personsToTrust);
    free(personsFromTrust);

    return potentialJudjeNumber;
}"
removeDuplicates,"int *nums, int numsSize",,numsSize - count,"int removeDuplicates(int *nums, int numsSize)
{
    int count = 0, i;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] == nums[i - 1])
            count++;
        else
            nums[i - count] = nums[i];
    }
    return numsSize - count;
}"
removeElements,"struct ListNode *head, int val",,"NULL | removeElements(head->next, val) | head","struct ListNode *removeElements(struct ListNode *head, int val)
{
    if (head == NULL)
        return NULL;
    if (head->val == val)
    {
        return removeElements(head->next, val);
    }
    else
    {
        head->next = removeElements(head->next, val);
    }
    return head;
}"
convertBST,"int *nums, int left, int right",,NULL | new_val,"struct TreeNode *convertBST(int *nums, int left, int right)
{
    if (left > right)
        return NULL;
    else
    {
        int mid = (right + left) / 2;
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = nums[mid];
        new_val->left = convertBST(nums, left, mid - 1);
        new_val->right = convertBST(nums, mid + 1, right);
        return new_val;
    }
}"
sortedArrayToBST,"int *nums, int numsSize",,"NULL | convertBST(nums, 0, numsSize - 1)","
struct TreeNode *sortedArrayToBST(int *nums, int numsSize)
{
    if (numsSize == 0)
        return NULL;
    else
        return convertBST(nums, 0, numsSize - 1);
}"
hammingDistance,"int x, int y",,distance,"int hammingDistance(int x, int y)
{
    int difference =
        x ^ y;  // The XOR operator generates the bitwise difference in the
                // binary representation of two numbers If bit in ith position
                // of both numbers is same, bit in difference is 0, otherwise 1
    int TotalBits = sizeof(difference) * 8;  // total number of bits
    int i, distance = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (difference &
            (UINT32_C(1)
             << i))  // if the bit on the ith position of 32 bit input is 1,
                     // then proceed Further note the use of UINT32_C to convert
                     // 1 to unsigned 32 bit int, as just 1 is treated as int
                     // which cannot be shifted left more than 30 times
            distance += 1;
    }
    return distance;
}"
bitwiseComplement,int n,,1 | (~n) & ((1 << binary_number_length) - 1),"
int bitwiseComplement(int n){
    if (n == 0){
        return 1;
    }

    int binary_number_length = ceil(log2(n));
    return (~n) & ((1 << binary_number_length) - 1);
}"
fib,int N,,0 | 1 | fib(N - 1) + fib(N - 2),"int fib(int N)
{
    if (N == 0)
        return 0;
    if (N == 1)
        return 1;
    return fib(N - 1) + fib(N - 2);
}"
mySqrt,int x,,mid | ans,"
int mySqrt(int x){
int start=0;
        int end=x;
        long long int ans=0;
        while(start <= end){
               long long int mid=(start+end)/2;
               long long int val=mid*mid;
               if( val == x){
                   return mid;
                }
//if mid is less than the square root of the number(x) store the value of mid in ans.
               if( val < x){
                       ans = mid;
                       start = mid+1;
               }
//if mid is greater than the square root of the number(x) then ssign the value mid-1 to end.               
               if( val > x){
                       end = mid-1;
               }
        }
   return ans;
}"
rotate,"int *nums, int numsSize, int k",,null,"void rotate(int *nums, int numsSize, int k)
{
    for (int i = 1; i <= k; i++)
    {
        int j;
        int lastElement;
        lastElement = nums[numsSize - 1];
        for (j = numsSize - 1; j > 0; j--)
        {
            nums[j] = nums[j - 1];
        }
        nums[0] = lastElement;
    }
}"
compare,"const int* i, const int* j",,*i - *j,"int compare(const int* i, const int* j)
{
    return *i - *j;
}"
maximumBags,"int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks",,bags,"
int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) {
    int* capacityLeft = malloc(capacitySize * sizeof(int));
    for (int i = 0; i < capacitySize; i++) {
        capacityLeft[i] = capacity[i] - rocks[i];
    }

    qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare);
    
    int bags = 0;
    for (int i = 0; i < capacitySize; i++) {
        if (additionalRocks < capacityLeft[i]){
            break;
        }

        additionalRocks -= capacityLeft[i];
        bags++;
    }

    free(capacityLeft);
    return bags;
}"
maximumUniqueSubarray,"int* nums, int numsSize",,maxSum,"
int maximumUniqueSubarray(int* nums, int numsSize){
    short* numsSet = (short*)calloc(10001, sizeof(short));
    numsSet[nums[0]] = 1;

    int maxSum = nums[0];

    int windowSumm = maxSum;
    int leftIndex = 0;
    
    int num = 0;
    for(int i = 1; i < numsSize; i++){
        num = nums[i];
        while (numsSet[num] != 0){
            numsSet[nums[leftIndex]] = 0;
            windowSumm -= nums[leftIndex];
            leftIndex++;
        }
        
        numsSet[num] = 1;
        windowSumm += num;
            
        if (maxSum < windowSumm){
            maxSum = windowSumm;
        }
    }
    
    return maxSum;
}"
cmpval,"const void *a, const void *b",,*(int *)b - *(int *)a,"int *cmpval(const void *a, const void *b) { return *(int *)b - *(int *)a; }"
findKthLargest,"int *nums, int numsSize, int k",,nums[k - 1],"
int findKthLargest(int *nums, int numsSize, int k)
{
    qsort(nums, numsSize, sizeof(int), cmpval);
    return nums[k - 1];
}"
min,"int a, int b",,((a < b) ? a : b),"
int min(int a, int b) { return ((a < b) ? a : b); }"
maxArea,"int *height, int heightSize",,res,"
int maxArea(int *height, int heightSize)
{
    // Start with maximum container width
    int start = 0;
    int end = heightSize - 1;
    int res = 0;

    while (start < end)
    {
        // Calculate current area by taking minimum of two heights
        int currArea = (end - start) * min(height[start], height[end]);

        if (currArea > res)
            res = currArea;

        if (height[start] < height[end])
            start = start + 1;
        else
            end = end - 1;
    }

    return res;
}"
getIntersectionNode,"struct ListNode *headA, struct ListNode *headB",,NULL | cur1,"struct ListNode *getIntersectionNode(struct ListNode *headA,
                                     struct ListNode *headB)
{
    struct ListNode *cur1 = headA, *cur2 = headB;
    if (cur1 == NULL || cur2 == NULL)
        return NULL;
    while (cur1 && cur2 && cur1 != cur2)
    {
        cur1 = cur1->next;
        cur2 = cur2->next;
        if (cur1 == cur2)
            return cur1;
        if (!cur1)
            cur1 = headB;
        if (!cur2)
            cur2 = headA;
    }
    return cur1;
}"
swapPairs,struct ListNode *head,,head | tmp,"struct ListNode *swapPairs(struct ListNode *head)
{
    if (!head || !head->next)
        return head;
    struct ListNode *tmp = head->next;
    head->next = swapPairs(head->next->next);
    tmp->next = head;
    return tmp;
}"
divide,"int dividend, int divisor",,INT_MIN | INT_MAX | output * sign,"int divide(int dividend, int divisor)
{
    int sign = 1;
    long int output = 0;
    if (dividend < 0)
    {
        sign *= -1;
    }
    else
    {
        dividend *= -1;
    }
    if (divisor < 0)
    {
        sign *= -1;
    }
    else
    {
        divisor *= -1;
    }
    while (dividend <= divisor)
    {
        long int tmp = 0;
        long int div = divisor;
        while (dividend <= div)
        {
            tmp += (tmp + 1);
            dividend -= div;
            div += div;
        }
        if (output >= INT_MAX)
        {
            if (sign == -1)
            {
                return INT_MIN;
            }
            else
            {
                return INT_MAX;
            }
        }
        output += tmp;
    }

    return output * sign;
}"
singleNonDuplicate,"int* nums, int numsSize",,nums[left],"int singleNonDuplicate(int* nums, int numsSize) {
    int left = 0, right = numsSize - 1;
    while (left < right) {
        int mid = (right + left) / 2;
        if (mid % 2 == 0) {
            if (nums[mid] == nums[mid + 1])
                left = mid + 2;
            else
                right = mid;
        }
        else {
            if (nums[mid] == nums[mid - 1])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    return nums[left];
}"
coundDevices,char* bankRow,,result,"int coundDevices(char* bankRow){
    int result = 0;
    int bankRowSize = strlen(bankRow);
    for(int i = 0; i < bankRowSize; i++){
        if (bankRow[i] == '1'){
            result++;
        }
    }

    return result;
}"
numberOfBeams,"char ** bank, int bankSize",,result,"
int numberOfBeams(char ** bank, int bankSize){
    int prevRowDevices = 0;
    int result = 0;
    for(int i = 0; i < bankSize; i++){
        int devices = coundDevices(bank[i]);
        if (devices == 0){
            continue;
        }

        result += devices * prevRowDevices;
        prevRowDevices = devices;
    }

    return result;
}"
majorityElement,"int *nums, int numsSize",,majorNum,"int majorityElement(int *nums, int numsSize)
{
    int count = 1;
    int majorNum = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        if (count == 0)
        {
            majorNum = nums[i];
            count++;
        }
        else if (majorNum == nums[i])
            count++;
        else
            count--;
    }
    return majorNum;
}"
firstUniqChar,char *s,,i | -1,"int firstUniqChar(char *s)
{
    int *arr = calloc(256, sizeof(int));
    int i;
    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;
    for (i = 0; i < strlen(s); i++)
    {
        if (arr[s[i]] == 1)
            return i;
    }
    return -1;
}"
cmpvalue,"const void *a, const void *b",,*(int *)b - *(int *)a,"
int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }"
twoSum,"int *nums, int numsSize, int target, int *returnSize",,ret,"int *twoSum(int *nums, int numsSize, int target, int *returnSize)
{
    int i, j;
    int *ret = calloc(2, sizeof(int));
    for (i = 0; i < numsSize; i++)
    {
        int key = target - nums[i];
        for (j = i + 1; j < numsSize; j++)
            if (nums[j] == key)
            {
                ret[0] = i;
                ret[1] = j;
            }
    }
    *returnSize = 2;
    return ret;
}"
getDisturb,struct TreeNode* node,,result,"
struct NodeDistributeInfo* getDisturb(struct TreeNode* node) {
    struct NodeDistributeInfo* result = malloc(sizeof(struct NodeDistributeInfo));

    if (node == NULL) {
        result->distributeMoves = 0;
        result->distributeExcess = 1;
        return result;
    }

    struct NodeDistributeInfo* leftDistribute = getDisturb(node->left);
    struct NodeDistributeInfo* rightDistribute = getDisturb(node->right);

    int coinsToLeft = 1 - leftDistribute->distributeExcess;
    int coinsToRight = 1 - rightDistribute->distributeExcess;

    // Calculate moves as excess and depth between left and right subtrees.
    result->distributeMoves = leftDistribute->distributeMoves + rightDistribute->distributeMoves + abs(coinsToLeft) + abs(coinsToRight);
    result->distributeExcess = node->val - coinsToLeft - coinsToRight;

    free(leftDistribute);
    free(rightDistribute);

    return result;
}"
distributeCoins,struct TreeNode* root,On each node-step we try to recombinate coins between left and right subtree.,getDisturb(root)->distributeMoves,"
int distributeCoins(struct TreeNode* root) {
    return getDisturb(root)->distributeMoves;
}"
newNode,int item,,node,"struct TreeNode *newNode(int item)
{
    struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    node->val = item;
    node->left = node->right = NULL;
    return node;
}"
mergeTrees,"struct TreeNode *t1, struct TreeNode *t2",,NULL | node,"
struct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)
{
    if (t1 == NULL && t2 == NULL)
        return NULL;
    int item = (t1 == NULL ? 0 : t1->val) + (t2 == NULL ? 0 : t2->val);
    struct TreeNode *node = newNode(item);
    node->left =
        mergeTrees(t1 == NULL ? NULL : t1->left, t2 == NULL ? NULL : t2->left);
    node->right = mergeTrees(t1 == NULL ? NULL : t1->right,
                             t2 == NULL ? NULL : t2->right);
    return node;
}"
insertIntoBST,"struct TreeNode *root, int val",,new_val | root,"struct TreeNode *insertIntoBST(struct TreeNode *root, int val)
{
    if (root == NULL)
    {
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = val;
        new_val->left = new_val->right = NULL;
        return new_val;
    }
    else
    {
        if (root->val >= val)
            root->left = insertIntoBST(root->left, val);
        else
            root->right = insertIntoBST(root->right, val);
    }
    return root;
}"
max,"a,b",,a | b,"int max(a,b){
    if(a>b)
        return a;
    else
        return b;
}"
findMaxConsecutiveOnes,"int* nums, int numsSize",,result,"
int findMaxConsecutiveOnes(int* nums, int numsSize){
    int count = 0; 
	int result = 0; 
    
    for (int i = 0; i < numsSize; i++)
	{
		if (nums[i] == 0)
			count = 0;
		else
		{
			count++;
			result = max(result, count);
		}
	}
    return result;
}"
cmp,"const void* a, const void* b",,(*A > *B) - (*A < *B),"
int cmp(const void* a, const void* b) {
    const int *A = a, *B = b;
    return (*A > *B) - (*A < *B);
}"
threeSumClosest,"int* nums, int nums_size, int target",,sum3 | result,"
int threeSumClosest(int* nums, int nums_size, int target) {
    int i, j, k, result, sum3;
    qsort(nums, nums_size, sizeof(int), cmp);
    result = nums[0] + nums[1] + nums[2];
    for (i = 0; i < nums_size - 2; i++) {
        j = i + 1;
        k = nums_size - 1;
        while (j < k) {
            sum3 = nums[i] + nums[j] + nums[k];
            if (abs(target - sum3) < abs(target - result)) {
                result = sum3;
            }
            if (sum3 < target) {
                j++;
            } else if (sum3 > target) {
                k--;
            } else {
                return sum3;
            }
        }
    }
    return result;
}"
longestPalindrome,char * s,,s | NULL | s_longest,"
char * longestPalindrome(char * s) {
    int si_max = 0, ei_max = 0, sz_max = 0, sz, i, delta_i;
    char ch, *s_longest;
    if (s[1] == '\0') return s;

    for (ch = s[1], i = 1; ch != '\0'; ch = s[++i]) {
        if (s[i - 1] == ch) {
            sz = 2;
            delta_i = 1;
            while (i - 1 - delta_i >= 0 && s[i + delta_i] != '\0' && s[i - 1 - delta_i] == s[i + delta_i]) {
                sz += 2;
                delta_i += 1;
            }
            if (sz > sz_max) {
                sz_max = sz;
                si_max = i - 1 - delta_i + 1;
                ei_max = i + delta_i - 1;
            }
        }
    }

    for (ch = s[0], i = 1; ch != '\0'; ch = s[++i]) {
        sz = 1;
        delta_i = 1;
        while (i - delta_i >= 0 && s[i + delta_i] != '\0' && s[i - delta_i] == s[i + delta_i]) {
            sz += 2;
            delta_i += 1;
        }
        if (sz > sz_max) {
            sz_max = sz;
            si_max = i - delta_i + 1;
            ei_max = i + delta_i - 1;
        }
    }

    if ((s_longest = (char *) malloc(sizeof(s))) == NULL) {
        return NULL;
    }
    strncpy(s_longest, s + si_max, sz_max);
    s_longest[sz_max] = '\0';

    return s_longest;
}"
countSegments,char * s,,result,"
int countSegments(char * s){
    int sLen = strlen(s);
    int prevSpace = 1;
    int result = 0;
    char currChar;

    for (int i = 0; i < sLen; i++){
        currChar = s[i];

        //A string of whitespaces will only be counted once as the condition below is only true when we transition from whitespace to non-whitespace.
        //Since we start with assumed whitespace (prevSpace = 1), initial whitespaces are handled as well, if any
        if (s[i] != ' ' && prevSpace) {
            result++;
        }
        prevSpace = (currChar == ' ');
    }

    return result;
}"
cmpval,"const void *a, const void *b",,*(int *)a - *(int *)b,"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
findDuplicates,"int *nums, int numsSize, int *returnSize",,retArr,"
int *findDuplicates(int *nums, int numsSize, int *returnSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    int *retArr = malloc(numsSize * sizeof(int));
    *returnSize = 0;
    for (i = 0; i < numsSize - 1;)
    {
        if (nums[i] == nums[i + 1])
        {
            retArr[*returnSize] = nums[i];
            *returnSize = *returnSize + 1;
            i = i + 2;
        }
        else
        {
            i = i + 1;
        }
    }
    return retArr;
}"
sortedSquares,"int *A, int ASize, int *returnSize",,res,"int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int i, start = 0, end = ASize - 1;
    int *res = malloc(ASize * sizeof(int));
    *returnSize = ASize;
    for (i = ASize - 1; i >= 0; i--)
    {
        if (abs(A[start]) > A[end])
        {
            res[i] = A[start] * A[start];
            start++;
        }
        else
        {
            res[i] = A[end] * A[end];
            end--;
        }
    }
    return res;
}"
cmpval,"const void *a, const void *b",,*(int *)a - *(int *)b,"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }"
sortedSquares,"int *A, int ASize, int *returnSize",2nd way: Using qsort,res,"
int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int *res = malloc(ASize * sizeof(int));
    for (int i = 0; i < ASize; i++) res[i] = A[i] * A[i];
    *returnSize = ASize;
    qsort(res, ASize, sizeof(int), cmpval);
    return res;
}"
maxIncreaseKeepingSkyline,"int** grid, int gridSize, int* gridColSize",,result,"
int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){
    int* rowsMaxs = calloc(gridSize, sizeof(int));
    int* colsMaxs = calloc(gridSize, sizeof(int));

    // Find max of each row and column
    for(int i = 0; i < gridSize; i++){
        for (int j = 0; j < gridSize; j++){
            rowsMaxs[i] = max(rowsMaxs[i], grid[i][j]);
            colsMaxs[j] = max(colsMaxs[j], grid[i][j]);
        }
    }

    int result = 0;
    for(int i = 0; i < gridSize; i++){
        for (int j = 0; j < gridSize; j++){
            int rowMax = rowsMaxs[i];
            int colMax = colsMaxs[j];
            result += min(rowMax - grid[i][j], colMax - grid[i][j]);
        }
    }

    free(rowsMaxs);
    free(colsMaxs);

    return result;
}"
stockSpannerNext,"StockSpanner* obj, int price",,result,"
int stockSpannerNext(StockSpanner* obj, int price) {
    while(obj->stackPointer != obj->sentry && obj->stackPointer->price <= price){
        Stack* currStackPointer = obj->stackPointer;
        obj->stackPointer = obj->stackPointer->previous;
        free(currStackPointer);
    }
    
    obj->index += 1;
    int result = obj->index;
    if (obj->stackPointer != obj->sentry){
        result -= obj->stackPointer->index;
    }
    
    Stack* newStackItem = (Stack *)malloc(sizeof(Stack));
    newStackItem->index = obj->index;
    newStackItem->price = price;
    newStackItem->previous = obj->stackPointer;
    obj->stackPointer = newStackItem;
    
    return result;
}"
stockSpannerFree,StockSpanner* obj,,null,"
void stockSpannerFree(StockSpanner* obj) {
    while(obj->stackPointer != obj->sentry){
        Stack* currStackPointer = obj->stackPointer;
        obj->stackPointer = obj->stackPointer->previous;
        free(currStackPointer);
    }

    free(obj->sentry);
    free(obj);
}"
charsCount,char* word,,result,"
int* charsCount(char* word){
    int* result = calloc(charLength, sizeof(int));
    int wordLen = strlen(word);
    for (int i = 0; i < wordLen; i++){
        result[word[i] - 'a']++;
    }

    return result;
}"
diff,"const int *i, const int *j",,*i - *j,"
int diff(const int *i, const int *j)
{
    return *i - *j;
}"
findMaxConsecutiveOnes,"int* nums, int numsSize",,maxCount,"int findMaxConsecutiveOnes(int* nums, int numsSize){
    int i=0;
    int maxCount=0;
    int count = 0;
    
    while(i<numsSize){
        
        while(i<numsSize && nums[i]!=0){
            count++;
            i++;
        }
        
        if(maxCount<=count){
         maxCount = count;   
        }
        
        count = 0;
        while(i<numsSize && nums[i]==0){
            i++;
        }
        
    }
    return maxCount;
    
}"
romanToInt,char *s,,romanToInt,"int romanToInt(char *s)
{
    int romanToInt = 0;
    for (int i = 0; i < strlen(s); i++)
    {
        switch (s[i])
        {
        case 'I':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'V' || s[i + 1] == 'X')
                {
                    romanToInt -= 1;
                    break;
                }
            }
            romanToInt += 1;
            break;
        case 'V':
            romanToInt += 5;
            break;
        case 'X':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'L' || s[i + 1] == 'C')
                {
                    romanToInt -= 10;
                    break;
                }
            }
            romanToInt += 10;
            break;
        case 'L':
            romanToInt += 50;
            break;
        case 'C':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'D' || s[i + 1] == 'M')
                {
                    romanToInt -= 100;
                    break;
                }
            }
            romanToInt += 100;
            break;
        case 'D':
            romanToInt += 500;
            break;
        case 'M':
            romanToInt += 1000;
            break;
        default:
            break;
        }
    }
    return romanToInt;
}"
getTripletId,"int i, int j",,(i / 3) * 3 + (j / 3),"
int getTripletId(int i, int j){
    return (i / 3) * 3 + (j / 3);
}"
solveSudoku,"char** board, int boardSize, int* boardColSize",,null,"
void solveSudoku(char** board, int boardSize, int* boardColSize){
    // Declare sets for cheking occupation of numbers by horizontals, verticals lines and triplets.
    int** horizontalsSets = initSet(boardSize + 1);
    int** verticalsSets = initSet(boardSize + 1);
    int** tripletsSets = initSet(getTripletId(boardSize + 1, boardSize + 1));

    // Populate sets with values from the board.
    for (int i = 0; i < boardSize; i++) {
        for (int j = 0; j < boardColSize[i]; j++) {
            if (board[i][j] == '.'){
                continue;
            }
            
            int value = board[i][j] - '0';
            horizontalsSets[i][value] = 1;
            verticalsSets[j][value] = 1;
            tripletsSets[getTripletId(i, j)][value] = 1;
        }
    }

    // Solving
    sudokuSolver(0, 0, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets);

    // Free resources
    free(horizontalsSets);
    free(verticalsSets);
    free(tripletsSets);
}"
missingNumber,"int *nums, int numsSize",,actual_sum + numsSize - sum,"int missingNumber(int *nums, int numsSize)
{
    int i, actual_sum = 0, sum = 0;
    for (i = 0; i < numsSize; i++)
    {
        sum = sum + nums[i];
        actual_sum = actual_sum + i;
    }
    return actual_sum + numsSize - sum;
}"
findMin,"int *nums, int numsSize",,nums[low],"int findMin(int *nums, int numsSize)
{
    int low = 0, high = numsSize - 1;
    while (low < high)
    {
        int mid = low + (high - low) / 2;
        /* minimum is on left side */
        if (nums[mid] < nums[high])
            high = mid;
        /* minimum is on right side */
        else
            low = mid + 1;
    }
    return nums[low];
}"
findTheDifference,"char *s, char *t",,(char)(sum2 - sum1),"char findTheDifference(char *s, char *t)
{
    int sum1 = 0, sum2 = 0;
    int i;
    for (i = 0; i < strlen(s); i++) sum1 += s[i];
    for (i = 0; i < strlen(t); i++) sum2 += t[i];
    return (char)(sum2 - sum1);
}"
countAndSay,int n,,arr,"char *countAndSay(int n)
{
    // Calculating the length of array
    double result = 1.0;
    for (int i = 0; i < n - 1; i++)
    {
        result *= 1.4;
    }

    int k, j, count, convert = (int)result;

    // Creating array with the length calculated above
    char *arr = malloc(convert + 4);
    arr[0] = '1';
    arr[1] = '\0';

    for (int i = 2, length; i <= n; i++)
    {
        length = strlen(arr);
        char newArr[length * 2];
        strcpy(newArr, arr);

        k = 0;
        j = 0;
        count = 1;

        while (newArr[j] != '\0')
        {
            if (newArr[j] == newArr[j + 1])
            {
                count++;
                j++;
            }
            else
            {
                arr[k] = (48 + count);
                arr[k + 1] = newArr[j];
                arr[k + 2] = '\0';
                j++;
                k += 2;
                count = 1;
            }
        }
    }

    return arr;
}"
visitRooms,"int key, int** rooms, int roomsSize, int* roomsColSize, int* visitedRooms",,null,"void visitRooms(int key, int** rooms, int roomsSize, int* roomsColSize, int* visitedRooms){
    if (visitedRooms[key] == 1){
        return;
    }

    visitedRooms[key] = 1;
    for (int i = 0; i < roomsColSize[key]; i++){
        visitRooms(rooms[key][i], rooms, roomsSize, roomsColSize, visitedRooms);
    }
}"
getSum,"int* nums, int numsSize, int divizor",,result,"
long getSum(int* nums, int numsSize, int divizor){
    long result = 0;
    for (int i = 0; i < numsSize; i++){
        int value = nums[i] / divizor;
        if (value * divizor != nums[i]){
            value++;
        }

        result += value;
    }

    return result;
}"
smallestDivisor,"int* nums, int numsSize, int threshold",,middle | -1,"
int smallestDivisor(int* nums, int numsSize, int threshold){
    int maxNum = 0;
    for (int i = 0; i < numsSize; i++){
        maxNum = max(maxNum, nums[i]);
    }

    int left = 1;
    int right = maxNum;
    while (left <= right){
        int middle = (left + right) / 2;
        long middleSum = getSum(nums, numsSize, middle);
        if (middleSum <= threshold && (middle == 1 || getSum(nums, numsSize, middle - 1) > threshold)){
            return middle;
        }

        if (middleSum > threshold){
            left = middle + 1;
        }
        else{
            right = middle - 1;
        }
    }

    return -1;
}"
lengthOfLongestSubstring,char *str,,0 | L_len,"int lengthOfLongestSubstring(char *str)
{
    int n = strlen(str);

    if (!n)
        return 0;

    int L_len = 1;  // length of longest substring
    int C_len = 1;  // length of current substring

    int P_ind, i;      //  P_ind for previous index
    int visited[256];  //  visited will keep track of visiting char for the last
                       //  instance. since there are 256 ASCII char, its size is
                       //  limited to that value.
    memset(visited, -1, sizeof(int) * 256);
    visited[str[0]] =
        0;  //  the index of that char will tell us that when it was visited.
    for (i = 1; i < n; i++)
    {
        P_ind = visited[str[i]];
        if (P_ind == -1 || i - C_len > P_ind)
            C_len++;  //  if the current char was not visited earlier, or it is
                      //  not the part of current substring
        else
        {  //  otherwise, we need to change the current/longest substring length
            if (C_len > L_len)
                L_len = C_len;
            C_len = i - P_ind;
        }
        visited[str[i]] = i;
    }
    if (C_len > L_len)
        L_len = C_len;
    return L_len;
}"
lengthOfLongestSubstring,char *s,,max,"int lengthOfLongestSubstring(char *s)
{
    int cur_max = 0, max = 0;
    int counter[255];
    int end = 0;

    memset(counter, 0, sizeof(int) * 255);
    while (end < strlen(s))
    {
        if (counter[s[end]] == 0)
        {
            counter[s[end]]++;
            end++;
            cur_max++;
        }
        else
        {
            char c = s[end];
            memset(counter, 0, 255 * sizeof(int));
            if (cur_max >= max)
                max = cur_max;
            cur_max = 0;
            while (s[end - 1] != c) end--;
        }
    }
    if (cur_max >= max)
        max = cur_max;
    return max;
}"
reverseOnlyLetters,char *S,,S,"char *reverseOnlyLetters(char *S)
{
    int last = strlen(S) - 1, i;
    for (i = 0; i < last;)
    {
        if (!isalpha(S[i]))
        {
            i++;
            continue;
        }
        if (!isalpha(S[last]))
        {
            last--;
            continue;
        }
        char tmp = S[i];
        S[i] = S[last];
        S[last] = tmp;
        i++;
        last--;
    }
    return S;
}"
trimBST,"struct TreeNode* root, int low, int high",,"NULL | trimBST(root->left, low, high) | trimBST(root->right, low, high) | root","
struct TreeNode* trimBST(struct TreeNode* root, int low, int high){
    if (root == NULL){
        return NULL;
    }
    
    if (root->val > high){
        return trimBST(root->left, low, high);
    }

    if (root->val < low){
        return trimBST(root->right, low, high);
    }
    
    root->left = trimBST(root->left, low, high);
    root->right = trimBST(root->right, low, high);
    return root;
}"
pairSum,struct ListNode* head,,max,"int pairSum(struct ListNode* head)
{
    struct ListNode* dup = head;
    int count = 0, i = 0, max = 0;
    while (head != NULL)
    {
        count++;
        head = head->next;
    }
    int* arr = malloc(count * sizeof(int));
    while (dup != NULL)
    {
        arr[i++] = dup->val;
        dup = dup->next;
    }
    for (i = 0; i < count / 2; ++i)
    {
        if (arr[i] + arr[count - i - 1] > max)
            max = arr[i] + arr[count - i - 1];
    }
    return max;
}"
singleNumber,"int *nums, int numsSize",,result,"int singleNumber(int *nums, int numsSize)
{
    int i, result = 0;
    for (i = 0; i < numsSize; i++) result = result ^ nums[i];
    return result;
}"
removeNthFromEnd,"struct ListNode *head, int n",,entry.next,"struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {
    struct ListNode entry, *p_free, *p = head;
    int i, sz = 0;
    entry.next = head;
    while (p != NULL) {
        p = p->next;
        sz++;
    }
    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)
    ;
    p_free = p->next;
    if (n != 1) {
        p->next = p->next->next;
    } else {
        p->next = NULL;
    }
    free(p_free);
    return entry.next;
}"
detectCycle,struct ListNode *head,,NULL | entry,"struct ListNode *detectCycle(struct ListNode *head)
{
    if (head == NULL || head->next == NULL)
        return NULL;
    struct ListNode *slow, *fast;
    slow = fast = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
        {
            struct ListNode *entry = head;
            while (slow != entry)
            {
                slow = slow->next;
                entry = entry->next;
            }
            return entry;
        }
    }
    return NULL;
}"
peakIndexInMountainArray,"int *A, int ASize",,mid | -1,"int peakIndexInMountainArray(int *A, int ASize)
{
    int low = 1, high = ASize;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (A[mid - 1] < A[mid] && A[mid] > A[mid + 1])
            return mid;
        else if (A[mid - 1] < A[mid] && A[mid] < A[mid + 1])
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}"
max,"int a, int b",,a >= b ? a : b,"int max(int a, int b) { return a >= b ? a : b; }"
height,struct TreeNode *root,,"0 | 1 + max(height(root->left), height(root->right))","
int height(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + max(height(root->left), height(root->right));
}"
jump,"int* nums, int numsSize",,0 | step | -1,"
int jump(int* nums, int numsSize) {
    if (numsSize == 1) {
        return 0;
    }

    int step = 1;
    int* visitedCells = calloc(numsSize, sizeof(int));

    int* queue = malloc(numsSize * sizeof(int));
    queue[0] = 0;
    int queueLength = 1;

    while (queueLength > 0){
        int* nextQueue = malloc(numsSize * sizeof(int));
        int nextQueueLength = 0;

        for (int i = 0; i < queueLength; i++) {
            int cell = queue[i];
            int jump = nums[cell];

            if (cell + jump >= numsSize - 1) {
                free(visitedCells);
                free(queue);
                free(nextQueue);
                return step;
            }

            // populate next queue wave for searching
            for (int nextCell = cell; nextCell <= cell + jump; nextCell++) {
                if (visitedCells[nextCell] == 0){
                    nextQueue[nextQueueLength++] = nextCell;
                    visitedCells[nextCell] = 1;
                }
            }
        }

        step++;
        free(queue);

        queue = nextQueue;
        queueLength = nextQueueLength;
    }

    free(visitedCells);
    free(queue);
    return -1;
}"
reverseString,"char *s, int sSize",,null,"void reverseString(char *s, int sSize)
{
    int last = sSize - 1, i;
    for (i = 0; i < last; i++)
    {
        char tmp = s[i];
        s[i] = s[last];
        s[last] = tmp;
        last--;
    }
}"
reverse,int x,,0 | rev,"
int reverse(int x)
{
    int rev = 0;
    while (x != 0)
    {
        int pop = x % 10;
        x /= 10;
        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7))
            return 0;
        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8))
            return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}"
toLowerCase,char *str,,str,"char *toLowerCase(char *str)
{
    for (int i = 0; i < strlen(str); i++) str[i] = tolower(str[i]);
    return str;
}"
searchInsert,"int *nums, int numsSize, int target",,mid | low,"int searchInsert(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1, mid;
    while (low <= high)
    {
        mid = low + (high - low) / 2;
        if (target > nums[mid])
            low = mid + 1;
        else if (target < nums[mid])
            high = mid - 1;
        else
            return mid;
    }
    return low;
}"
searchInsert,"int *nums, int numsSize, int target",,"numsSize | searchInsert(nums, numsSize - 1, target) | 0","int searchInsert(int *nums, int numsSize, int target)
{
    int idx = numsSize - 1;
    if (numsSize > 0)
    {
        if (target > nums[idx])
        {
            return numsSize;
        }
        return searchInsert(nums, numsSize - 1, target);
    }
    return 0;
}"
insert,"node **root, int id, int at, int bt, int prior",,null,"void insert(node **root, int id, int at, int bt, int prior)
{
    // create a new node and initialize it
    node *new = (node *)malloc(sizeof(node));
    node *ptr = *root;
    new->ID = id;
    new->AT = at;
    new->BT = bt;
    new->priority = prior;
    new->next = NULL;
    new->CT = 0;
    new->WT = 0;
    new->TAT = 0;
    // if the root is null, make the new node the root
    if (*root == NULL)
    {
        *root = new;
        return;
    }
    // else traverse to the end of the queue and insert the new node there
    while (ptr->next != NULL)
    {
        ptr = ptr->next;
    }
    ptr->next = new;
    return;
}"
delete,"node **root, int id",,"if (ptr == NULL)
    {
        return","void delete(node **root, int id)
{
    node *ptr = *root, *prev;
    // if the root is null, return
    if (ptr == NULL)
    {
        return;
    }
    // if the root is the process to be deleted, make the next node the root
    if (ptr->ID == id)
    {
        *root = ptr->next;
        free(ptr);
        return;
    }
    // else traverse the queue and delete the process
    while (ptr != NULL && ptr->ID != id)
    {
        prev = ptr;
        ptr = ptr->next;
    }
    if (ptr == NULL)
    {
        return;
    }
    prev->next = ptr->next;
    free(ptr);
}"
show_list,node *head,,null,"void show_list(node *head)
{
    printf(""Process Priority AT BT CT TAT WT \n"");
    while (head != NULL)
    {
        printf(""P%d. %d %d %d %d %d %d \n"", head->ID, head->priority, head->AT,
               head->BT, head->CT, head->TAT, head->WT);
        head = head->next;
    }
}"
l_length,node **root,,count,"int l_length(node **root)
{
    int count = 0;
    node *ptr = *root;
    while (ptr != NULL)
    {
        count++;
        ptr = ptr->next;
    }
    return count;
}"
update,"node **root, int id, int ct, int wt, int tat",,null,"void update(node **root, int id, int ct, int wt, int tat)
{
    node *ptr = *root;
    // If process to be updated is head node
    if (ptr != NULL && ptr->ID == id)
    {
        if (ct != 0)
        {
            ptr->CT = ct;
        }
        if (wt != 0)
        {
            ptr->WT = wt;
        }
        if (tat != 0)
        {
            ptr->TAT = tat;
        }
        return;
    }
    // else traverse the queue and update the values
    while (ptr != NULL && ptr->ID != id)
    {
        ptr = ptr->next;
    }
    if (ct != 0)
    {
        ptr->CT = ct;
    }
    if (wt != 0)
    {
        ptr->WT = wt;
    }
    if (tat != 0)
    {
        ptr->TAT = tat;
    }
    return;
}"
calculate_ct,node **root,,avg,"float calculate_ct(node **root)
{
    // calculate the total completion time of all the processes
    node *ptr = *root, *prior, *rpt;
    int ct = 0, i, time = 0;
    int n = l_length(root);
    float avg, sum = 0;
    node *duproot = NULL;
    // create a duplicate queue
    while (ptr != NULL)
    {
        insert(&duproot, ptr->ID, ptr->AT, ptr->BT, ptr->priority);
        ptr = ptr->next;
    }
    ptr = duproot;
    rpt = ptr->next;
    // sort the queue based on the arrival time and priority
    while (rpt != NULL)
    {
        if (!compare(ptr, rpt))
        {
            ptr = rpt;
        }
        rpt = rpt->next;
    }
    // ptr is the process to be executed first.
    ct = ptr->AT + ptr->BT;
    time = ct;
    sum += ct;
    // update the completion time, turn around time and waiting time of the
    // process
    update(root, ptr->ID, ct, 0, 0);
    delete (&duproot, ptr->ID);
    // repeat the process until all the processes are executed
    for (i = 0; i < n - 1; i++)
    {
        ptr = duproot;
        while (ptr != NULL && ptr->AT > time)
        {
            ptr = ptr->next;
        }
        rpt = ptr->next;
        while (rpt != NULL)
        {
            if (rpt->AT <= time)
            {
                if (rpt->priority < ptr->priority)
                {
                    ptr = rpt;
                }
            }
            rpt = rpt->next;
        }
        ct += ptr->BT;
        time += ptr->BT;
        sum += ct;
        update(root, ptr->ID, ct, 0, 0);
        delete (&duproot, ptr->ID);
    }
    avg = sum / n;
    return avg;
}"
calculate_tat,node **root,,avg,"float calculate_tat(node **root)
{
    float avg, sum = 0;
    int n = l_length(root);
    node *ptr = *root;
    // calculate the completion time if not already calculated
    if (ptr->CT == 0)
    {
        calculate_ct(root);
    }
    // calculate the total turn around time of all the processes
    while (ptr != NULL)
    {
        ptr->TAT = ptr->CT - ptr->AT;
        sum += ptr->TAT;
        ptr = ptr->next;
    }
    avg = sum / n;
    return avg;
}"
calculate_wt,node **root,,avg,"float calculate_wt(node **root)
{
    float avg, sum = 0;
    int n = l_length(root);
    node *ptr = *root;
    // calculate the completion if not already calculated
    if (ptr->CT == 0)
    {
        calculate_ct(root);
    }
    // calculate the total waiting time of all the processes
    while (ptr != NULL)
    {
        ptr->WT = (ptr->TAT - ptr->BT);
        sum += ptr->WT;
        ptr = ptr->next;
    }
    avg = sum / n;
    return avg;
}"
test,,,null,"static void test()
{
    // Entered processes
    // printf(""ID Priority Arrival Time Burst Time \n"");
    // printf(""1 0 5 1 \n"");
    // printf(""2 1 4 2 \n"");
    // printf(""3 2 3 3 \n"");
    // printf(""4 3 2 4 \n"");
    // printf(""5 4 1 5 \n"");

    node *root = NULL;
    insert(&root, 1, 0, 5, 1);
    insert(&root, 2, 1, 4, 2);
    insert(&root, 3, 2, 3, 3);
    insert(&root, 4, 3, 2, 4);
    insert(&root, 5, 4, 1, 5);
    float avgCT = calculate_ct(&root);
    float avgTAT = calculate_tat(&root);
    float avgWT = calculate_wt(&root);
    assert(avgCT == 11);
    assert(avgTAT == 9);
    assert(avgWT == 6);
    printf(""[+] All tests have successfully passed!\n"");
    // printf(""Average Completion Time is : %f \n"", calculate_ct(&root));
    // printf(""Average Turn Around Time is : %f \n"", calculate_tat(&root));
    // printf(""Average Waiting Time is : %f \n"", calculate_wt(&root));
}"
main,,"printf(""Average Waiting Time is : %f \n"", calculate_wt(&root));",0,"int main()
{
    test();  // run self-test implementations

    return 0;
}"
enqueue,int v,,null,"
void enqueue(int v) { q[qp++] = v; }"
cf,"void *a, void *b",,*y - *x,"
int cf(void *a, void *b)
{
    int *x = (int *)a;
    int *y = (int *)b;
    return *y - *x;
}"
dequeue,,,q[--qp],"
int dequeue()
{
    qsort(q, qp, sizeof(int), cf);
    return q[--qp];
}"
queue_has_something,,,(qp > 0),"
int queue_has_something() { return (qp > 0); }"
dijkstra,int s,,null,"
void dijkstra(int s)
{
    dist[s] = 0;
    int i;
    for (i = 0; i < V; ++i)
    {
        if (i != s)
        {
            dist[i] = INF;
        }
        enqueue(i);
    }
    while (queue_has_something())
    {
        int u = dequeue();
        visited[vp++] = u;
        for (i = 0; i < V; ++i)
        {
            if (mat[u][i])
            {
                if (dist[i] > dist[u] + mat[u][i])
                {
                    dist[i] = dist[u] + mat[u][i];
                }
            }
        }
    }
}"
main,"int argc, char const *argv[]",,0,"
int main(int argc, char const *argv[])
{
    printf(""Enter the number of vertices: "");
    scanf("" %d"", &V);
    printf(""Enter the adj matrix: "");
    int i, j;
    for (i = 0; i < V; ++i)
    {
        for (j = 0; j < V; ++j)
        {
            scanf("" %d"", &mat[i][j]);
        }
    }

    dijkstra(0);

    printf(""\nNode\tDist\n"");
    for (i = 0; i < V; ++i)
    {
        printf(""%d\t%d\n"", i, dist[i]);
    }

    return 0;
}"
minimum,"uint16_t arr[], uint16_t N",,index,"uint16_t minimum(uint16_t arr[], uint16_t N)
{
    uint16_t index = 0;
    uint16_t min = INF;

    for (uint16_t i = 0; i < N; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
            index = i;
        }
    }
    return index;
}"
prim,"uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V",,null,"void prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
    uint16_t u, v;
    uint16_t E_t[MAX], path[MAX];
    uint16_t V_t[MAX], no_of_edges;

    E_t[0] = 0;  // edges for current vertex
    V_t[0] = 1;  // list of visited vertices

    for (uint16_t i = 1; i < V; i++)
    {
        E_t[i] = G[i][0];
        path[i] = 0;
        V_t[i] = 0;
    }

    no_of_edges = V - 1;

    while (no_of_edges > 0)
    {
        u = minimum(E_t, V);
        while (V_t[u] == 1)
        {
            E_t[u] = INF;
            u = minimum(E_t, V);
        }

        v = path[u];
        MST[v][u] = E_t[u];
        MST[u][v] = E_t[u];
        no_of_edges--;
        V_t[u] = 1;

        for (uint16_t i = 1; i < V; i++)
        {
            if (V_t[i] == 0 && G[u][i] < E_t[i])
            {
                E_t[i] = G[u][i];
                path[i] = v;
            }
        }
    }
}"
test,"uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V",,null,"static void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
 
  uint16_t test[4][4] = {{0,1,2,3},{1,0,4,6},{2,4,0,5},{3,6,5,0}};
  uint16_t solution[4][4] = {{0,1,2,3},{1,0,0,0},{2,0,0,0},{3,0,0,0}};

  V = 4;

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      G[i][j] = test[i][j];
    }
  }

  prim(&(*G),&(*MST),V);

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      assert(MST[i][j] == solution[i][j]);
    }
  }
}"
user_graph,"uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V",,null,"void user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
      printf(""Enter the number of vertices: "");
      scanf("" %hd"", &V);

      assert(V <= MAX);

      printf(""Enter the adj matrix\n"");
      uint16_t i, j;
      for (i = 0; i < V; ++i)
      {
          for (j = 0; j < V; ++j)
          {
              printf(""G[%d][%d]: "", i, j);
              scanf("" %hd"", &G[i][j]);
              if (G[i][j] == 0)
                  G[i][j] = INF;
          }
      }

      prim(&(*G),&(*MST),V);

      printf(""minimum spanning tree:\n"");
      for (i = 0; i < V; ++i)
      {
          printf(""\n"");
          for (j = 0; j < V; ++j)
          {
              printf(""%d\t"", MST[i][j]);
          }
      }
}"
main,"int argc, char const *argv[]",,0,"int main(int argc, char const *argv[])
{   

    uint16_t G[MAX][MAX];    ///< weighted, connected graph G
    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G
    uint16_t V;              ///< number of vertices in V in G


    if(argc == 2 && strcmp(argv[1],""-test"") == 0)
    {
      test(&(*G),&(*MST),V);
    }
    else
    {
      user_graph(&(*G),&(*MST),V);
    }

    return 0;
}"
main,,,,"
int main()
{
    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;
    float MEAN = 0, VARIANCE = 0, STAND;

    printf(""Enter no. for Random Numbers :"");
    scanf(""%d"", &ARRAY_LENGTH);
    ARRAY = (int *)realloc(
        ARRAY,
        ARRAY_LENGTH * (sizeof(int)));  // We allocate the dedicated memory
    for (i = 0; i < ARRAY_LENGTH; i++)  // We generate the random numbers
        ARRAY[i] = rand() % 100;

    printf(""Random Numbers Generated are :\n"");  // We display them
    for (i = 0; i < ARRAY_LENGTH; i++) printf(""%d "", ARRAY[i]);

    printf(""\nSorted Data: "");  // Then we sort it using Bubble Sort..

    while (!isSorted)
    {                  // While our array's not sorted
        isSorted = 1;  // we suppose that it's sorted
        for (i = 0; i < ARRAY_LENGTH - 1; i++)
        {  // then for each element of the array
            if (ARRAY[i] > ARRAY[i + 1])
            {                  // if the two elements aren't sorted
                isSorted = 0;  // it means that the array is not sorted
                TEMPORARY_ELEMENT = ARRAY[i];  // and we switch these elements
                                               // using TEMPORARY_ELEMENT
                ARRAY[i] = ARRAY[i + 1];
                ARRAY[i + 1] = TEMPORARY_ELEMENT;
            }
        }
    }
    for (i = 0; i < ARRAY_LENGTH; i++)
    {
        printf(""%d "", ARRAY[i]);
        MEAN = MEAN + ARRAY[i];
    }
    MEAN = MEAN / (float)ARRAY_LENGTH;

    for (i = 0; i < ARRAY_LENGTH; i++)
        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));

    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;
    STAND = sqrt(VARIANCE);

    printf(""\n\n- Mean is: %f\n"", MEAN);
    printf(""- Variance is: %f\n"", VARIANCE);
    printf(""- Standard Deviation is: %f\n"", STAND);
}
"
func,double x,,x * x - 3.,"double func(double x)
{
    return x * x - 3.;  // x^2 = 3 - solution is sqrt(3)
}"
secant_method,"double x0, double x1, double tolerance",,"value if it meets tolerance
        if (fabs(x1 - x0) < tolerance)
            return x2 | -1","double secant_method(double x0, double x1, double tolerance)
{
    int n = 1;  // step counter

    while (n++ < NMAX)
    {
        // calculate secant line root
        double x2 = x1 - func(x1) * (x1 - x0) / (func(x1) - func(x0));

        // update values
        x0 = x1;
        x1 = x2;

        // return value if it meets tolerance
        if (fabs(x1 - x0) < tolerance)
            return x2;
    }

    return -1;  // method failed (maximum number of steps exceeded)
}"
test,,,null,"static void test()
{
    // compares root values found by the secant method within the tolerance
    assert(secant_method(0.2, 0.5, TOLERANCE) - sqrt(3) < TOLERANCE);
    assert(fabs(secant_method(-2, -5, TOLERANCE)) - sqrt(3) < TOLERANCE);
    assert(secant_method(-3, 2, TOLERANCE) - sqrt(3) < TOLERANCE);
    assert(fabs(secant_method(1, -1.5, TOLERANCE)) - sqrt(3) < TOLERANCE);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
stats_computer1,"float x, float *mean, float *variance, float *std",,"sample mean computed till last sample */
    if (mean != NULL)
        *mean = K + Ex / n | data variance computed till last sample */
    if (variance != NULL)
        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1) | sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance)","void stats_computer1(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float Ex = 0.f, Ex2 = 0.f;
    static float K = 0.f;

    if (n == 0)
        K = x;
    n++;
    float tmp = x - K;
    Ex += tmp;
    Ex2 += tmp * tmp;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = K + Ex / n;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}"
stats_computer2,"float x, float *mean, float *variance, float *std",,"sample mean computed till last sample */
    if (mean != NULL)
        *mean = mu | data variance computed till last sample */
    if (variance != NULL)
        *variance = M / n | sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance)","void stats_computer2(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float mu = 0, M = 0;

    n++;
    float delta = x - mu;
    mu += delta / n;
    float delta2 = x - mu;
    M += delta * delta2;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = mu;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = M / n;

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}"
test_function,"const float *test_data, const int number_of_samples",,null,"void test_function(const float *test_data, const int number_of_samples)
{
    float ref_mean = 0.f, ref_variance = 0.f;
    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    for (int i = 0; i < number_of_samples; i++)
    {
        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);
        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);
        ref_mean += test_data[i];
    }
    ref_mean /= number_of_samples;

    for (int i = 0; i < number_of_samples; i++)
    {
        float temp = test_data[i] - ref_mean;
        ref_variance += temp * temp;
    }
    ref_variance /= number_of_samples;

    printf(""<<<<<<<< Test Function >>>>>>>>\n"");
    printf(""Expected: Mean: %.4f\t Variance: %.4f\n"", ref_mean, ref_variance);
    printf(""\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n"", s1_mean,
           s1_variance, s1_std);
    printf(""\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n"", s2_mean,
           s2_variance, s2_std);

    assert(fabs(s1_mean - ref_mean) < 0.01);
    assert(fabs(s2_mean - ref_mean) < 0.01);
    assert(fabs(s2_variance - ref_variance) < 0.01);

    printf(""(Tests passed)\n\n"");
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};
    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));

    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    printf(""Enter data. Any non-numeric data will terminate the data input.\n"");

    while (1)
    {
        float val;
        printf(""Enter number: "");

        // check for failure to read input. Happens for
        // non-numeric data
        if (!scanf(""%f"", &val))
            break;

        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);
        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);

        printf(""\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n"",
               s1_mean, s1_variance, s1_std);
        printf(""\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n"",
               s2_mean, s2_variance, s2_std);
    }

    return 0;
}"
check_termination,long double delta,,1 | 0,"char check_termination(long double delta)
{
    static long double past_delta = INFINITY;
    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)
        return 1;
    past_delta = delta;
    return 0;
}"
main,"int argc, char **argv",,0 | EXIT_FAILURE,"int main(int argc, char **argv)
{
    long double *coeffs = NULL;
    long double complex *s0 = NULL;
    unsigned int degree = 0;
    unsigned int n, i;

    if (argc < 2)
    {
        printf(
            ""Please pass the coefficients of the polynomial as commandline ""
            ""arguments.\n"");
        return 0;
    }

    degree = argc - 1; /* detected polynomial degree */
    coeffs = (long double *)malloc(
        degree * sizeof(long double)); /* store all input coefficients */
    s0 = (long double complex *)malloc(
        (degree - 1) *
        sizeof(long double complex)); /* number of roots = degree-1 */

    /* initialize random seed: */
    srand(time(NULL));

    if (!coeffs || !s0)
    {
        perror(""Unable to allocate memory!"");
        if (coeffs)
            free(coeffs);
        if (s0)
            free(s0);
        return EXIT_FAILURE;
    }

#if defined(DEBUG) || !defined(NDEBUG)
    /**
     * store intermediate values to a CSV file
     */
    FILE *log_file = fopen(""durand_kerner.log.csv"", ""wt"");
    if (!log_file)
    {
        perror(""Unable to create a storage log file!"");
        free(coeffs);
        free(s0);
        return EXIT_FAILURE;
    }
    fprintf(log_file, ""iter#,"");
#endif

    printf(""Computing the roots for:\n\t"");
    for (n = 0; n < degree; n++)
    {
        coeffs[n] = strtod(argv[n + 1], NULL);
        if (n < degree - 1 && coeffs[n] != 0)
            printf(""(%Lg) x^%d + "", coeffs[n], degree - n - 1);
        else if (coeffs[n] != 0)
            printf(""(%Lg) x^%d = 0\n"", coeffs[n], degree - n - 1);

        double tmp;
        if (n > 0)
            coeffs[n] /= tmp; /* numerical errors less when the first
                                 coefficient is ""1"" */
        else
        {
            tmp = coeffs[0];
            coeffs[0] = 1;
        }

        /* initialize root approximations with random values */
        if (n < degree - 1)
        {
            s0[n] = (long double)rand() + (long double)rand() * I;
#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, ""root_%d,"", n);
#endif
        }
    }

#if defined(DEBUG) || !defined(NDEBUG)
    fprintf(log_file, ""avg. correction"");
    fprintf(log_file, ""\n0,"");
    for (n = 0; n < degree - 1; n++)
        fprintf(log_file, ""%s,"", complex_str(s0[n]));
#endif

    double tol_condition = 1;
    unsigned long iter = 0;

    clock_t end_time, start_time = clock();
    while (!check_termination(tol_condition) && iter < INT_MAX)
    {
        long double complex delta = 0;
        tol_condition = 0;
        iter++;

#if defined(DEBUG) || !defined(NDEBUG)
        fprintf(log_file, ""\n%ld,"", iter);
#endif

        for (n = 0; n < degree - 1; n++)
        {
            long double complex numerator =
                poly_function(coeffs, degree, s0[n]);
            long double complex denominator = 1.0;
            for (i = 0; i < degree - 1; i++)
                if (i != n)
                    denominator *= s0[n] - s0[i];

            delta = numerator / denominator;

            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))
            {
                printf(""\n\nOverflow/underrun error - got value = %Lg"",
                       cabsl(delta));
                goto end;
            }

            s0[n] -= delta;

            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));

#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, ""%s,"", complex_str(s0[n]));
#endif
        }
        // tol_condition /= (degree - 1);

#if defined(DEBUG) || !defined(NDEBUG)
        if (iter % 500 == 0)
        {
            printf(""Iter: %lu\t"", iter);
            for (n = 0; n < degree - 1; n++) printf(""\t%s"", complex_str(s0[n]));
            printf(""\t\tabsolute average change: %.4g\n"", tol_condition);
        }

        fprintf(log_file, ""%.4g"", tol_condition);
#endif
    }
end:

    end_time = clock();

#if defined(DEBUG) || !defined(NDEBUG)
    fclose(log_file);
#endif

    printf(""\nIterations: %lu\n"", iter);
    for (n = 0; n < degree - 1; n++) printf(""\t%s\n"", complex_str(s0[n]));
    printf(""absolute average change: %.4g\n"", tol_condition);
    printf(""Time taken: %.4g sec\n"",
           (end_time - start_time) / (double)CLOCKS_PER_SEC);

    free(coeffs);
    free(s0);

    return 0;
}"
main,,,0,"
int main()
{
    float x[20], y[20], a, sum, p;
    int n, i, j;

    printf(""Enter the no of entry to insert->"");
    scanf(""%d"", &n);

    for (i = 0; i < n; i++)
    {
        printf(""enter the value of x%d->"", i);
        scanf(""%f"", &x[i]);
        printf(""enter the value of y%d->"", i);
        scanf(""%f"", &y[i]);
    }
    printf(""\n X \t\t Y \n"");
    printf(""----------------------------\n"");
    for (i = 0; i < n; i++)
    {
        printf(""%f\t"", x[i]);
        printf(""%f\n"", y[i]);
    }
    printf(""\nenter the value of x for interpolation:"");
    scanf(""%f"", &a);
    sum = 0;
    for (i = 0; i < n; i++)
    {
        p = 1.0;
        for (j = 0; j < n; j++)
        {
            if (i != j)
            {
                p = p * (a - x[j]) / (x[i] - x[j]);
            }
            sum = sum + y[i] * p;
        }
        printf(""ans is->%f"", sum);

        return 0;
    }
}"
problem,"const double *x, double *y, double *dy",,null,"void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}"
exact_solution,"const double *x, double *y",,null,"void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}"
midpoint_euler_step,"double dx, double *x, double *y, double *dy",,null,"void midpoint_euler_step(double dx, double *x, double *y, double *dy)
{
    problem(x, y, dy);
    double tmp_x = (*x) + 0.5 * dx;
    double tmp_y[order];
    int o;
    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];

    problem(&tmp_x, tmp_y, dy);

    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}"
midpoint_euler,"double dx, double x0, double x_max, double *y, char save_to_file",,-1 | (double)(t2 - t1) / CLOCKS_PER_SEC,"double midpoint_euler(double dx, double x0, double x_max, double *y,
                      char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen(""midpoint_euler.csv"", ""w+"");
        if (fp == NULL)
        {
            perror(""Error! "");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        midpoint_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                             // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf(""\nEnter the step size: "");
        scanf(""%lg"", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);
    printf(""\tTime = %.6g ms\n"", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen(""exact.csv"", ""w+"");
    if (fp == NULL)
    {
        perror(""Error! "");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf(""Finding exact solution\n"");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf(""\tTime = %.6g ms\n"", total_time);
    fclose(fp);

    return 0;
}"
f,float x,,"1.0 +
           x * x * x","
float f(float x)
{
    return 1.0 +
           x * x * x;  // This is the expresion of the function to integrate?
}"
main,,,0,"
int main()
{
    int i, n;
    float a, b, h, x, s2, s3, sum, integral;

    printf(""enter the lower limit of the integration:"");
    scanf(""%f"", &a);
    printf(""enter the upper limit of the integration:"");
    scanf(""%f"", &b);
    printf(""enter the number of intervals:"");
    scanf(""%d"", &n);

    h = (b - a) / n;
    sum = f(a) + f(b);
    s2 = s3 = 0.0;

    for (i = 1; i < n; i += 3)
    {
        x = a + i * h;
        s3 = s3 + f(x) + f(x + h);
    }

    for (i = 3; i < n; i += 3)
    {
        x = a + i * h;
        s2 = s2 + f(x);
    }

    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);
    printf(""\nValue of the integral = %9.4f\n"", integral);

    return 0;
}"
sign,"double a, double b",,"(a > 0 && b > 0) + (a < 0 && b < 0) - (a > 0 && b < 0) -
           (a < 0 && b > 0)","double sign(double a, double b)
{
    return (a > 0 && b > 0) + (a < 0 && b < 0) - (a > 0 && b < 0) -
           (a < 0 && b > 0);
}"
func,double x,,x * x * x + 2.0 * x - 10.0,"double func(double x)
{
    return x * x * x + 2.0 * x - 10.0;  // f(x) = x**3 + 2x - 10
}"
bisection,"double x_left, double x_right, double tolerance",,middle | -1,"double bisection(double x_left, double x_right, double tolerance)
{
    int n = 1;      // step counter
    double middle;  // midpoint

    while (n <= NMAX)
    {
        middle = (x_left + x_right) / 2;  // bisect the interval
        double error = middle - x_left;

        if (fabs(func(middle)) < EPSILON || error < tolerance)
        {
            return middle;
        }

        if (sign(func(middle), func(x_left)) > 0.0)
        {
            x_left = middle;  // new lower endpoint
        }
        else
        {
            x_right = middle;  // new upper endpoint
        }

        n++;  // increase step counter
    }
    return -1;  // method failed (maximum number of steps exceeded)
}"
test,,,null,"static void test()
{
    /* Compares root value that is found by the bisection method within a given
     * floating point error*/
    assert(fabs(bisection(1.0, 2.0, 0.0001) - 1.847473) <
           EPSILON);  // the algorithm works as expected
    assert(fabs(bisection(100.0, 250.0, 0.0001) - 249.999928) <
           EPSILON);  // the algorithm works as expected

    printf(""All tests have successfully passed!\n"");
}"
main,,"@brief Self-test implementations
@returns void",0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
main,,,0,"
int main()
{
    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;

    printf(""Enter values of eq1:"");
    scanf(""%f%f%f%f"", &a1, &a2, &a3, &d1);
    printf(""Enter values of eq2:"");
    scanf(""%f%f%f%f"", &b1, &b2, &b3, &d2);
    printf(""Enter values of eq3:"");
    scanf(""%f%f%f%f"", &c1, &c2, &c3, &d3);
    x1 = x2 = x3 = 0.0;
    do
    {
        a = x1;
        b = x2;
        c = x3;
        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));
        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));
        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));
    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&
             fabs(x3 - c) > 0.0001);
    printf(""x1=%f\nx2=%f\nx3=%f"", x1, x2, x3);

    return 0;
}"
display,"float a[ARRAY_SIZE][ARRAY_SIZE], int n",,null,"
void display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j <= n; j++)
        {
            printf(""%.2f \t"", a[i][j]);
        }
        printf(""\n"");
    }
}"
interchange,"float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n",,m[ARRAY_SIZE - 1][ARRAY_SIZE - 1],"
float interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp[ARRAY_SIZE][ARRAY_SIZE];
    float max = fabs(m[i][i]);
    int j, k = i;

    for (j = i; j < n; j++)
    {
        if (max < fabs(m[j][i]))
        {
            max = fabs(m[j][i]);
            k = j;
        }
    }
    for (j = 0; j <= n; j++)
    {
        tmp[i][j] = m[i][j];
        m[i][j] = m[k][j];
        m[k][j] = tmp[i][j];
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}"
eliminate,"float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n",,m[ARRAY_SIZE - 1][ARRAY_SIZE - 1],"
float eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp;
    int k = 1, l, j;
    for (j = i; j < n - 1; j++)
    {
        tmp = -((m[i + k][i]) / (m[i][i]));
        for (l = 0; l <= n; l++)
        {
            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);
        }
        k++;
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}"
main,,,0,"
int main(void)
{
    int i, j, n, k = 0, l;
    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,
        ans[ARRAY_SIZE];

    printf(""Total No.of Equations : "");
    scanf(""%d"", &n);

    printf(""\n"");
    for (i = 0; i < n; i++)
    {
        printf(""Enter Co-efficient Of Equations %d & Total --->>>\n"", i + 1);
        for (j = 0; j <= n; j++)
        {
            printf(""r%d%d : "", i, j);
            scanf(""%f"", &m[i][j]);
        }
        printf(""\n"");
    }
    printf("":::::::::::: Current Matrix ::::::::::::\n\n"");
    display(m, n);

    for (i = 0; i < n - 1; i++)
    {
        printf(""\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\n"", i + 1);
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);
        display(m, n);
        printf(""\n_______________________________________\n"");
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);
        display(m, n);
    }
    printf(""\n\n Values are : \n"");
    for (i = n - 1; i >= 0; i--)
    {
        l = n - 1;
        mul = 0;
        for (j = 0; j < k; j++)
        {
            mul = mul + m[i][l] * ans[l];
            l--;
        }
        k++;
        ans[i] = (m[i][n] - mul) / m[i][i];
        printf(""X%d = %.2f\n"", i + 1, ans[i]);
    }

    return 0;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    double delta = 1;
    double complex cdelta = 1;

    /* initialize random seed: */
    srand(time(NULL));

    /* random initial approximation */
    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;

    unsigned long counter = 0;
    /* iterate till a convergence is reached */
    while (delta > ACCURACY && counter < ULONG_MAX)
    {
        cdelta = func(root) / d_func(root);
        root += -cdelta;
        counter++;
        delta = fabs(cabs(cdelta));

#if defined(DEBUG) || !defined(NDEBUG)
        if (counter % 50 == 0)
        {
            double r = creal(root);
            double c = cimag(root);

            printf(""Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n"", counter,
                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);
        }
#endif
    }

    double r = creal(root);
    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);

    printf(""Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n"", counter, r,
           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);

    return 0;
}"
main,"int argc, char **argv",,1 | 0,"
int main(int argc, char **argv)
{
    int *a, n = 10, i, j, temp, sum = 0;
    float mean;

    if (argc == 2)
    {
        n = atoi(argv[1]);
        if (n >= MAX_LEN)
        {
            fprintf(stderr, ""Maximum %d!\n"", MAX_LEN);
            return 1;
        }
    }
    
    a = (int *)malloc(n * sizeof(int));

    printf(""Random Numbers Generated are: "");
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
        printf(""%2d, "", a[i]);
    }
    putchar('\n');

    for (i = 0; i < n; i++) sum = sum + a[i];

    mean = sum / (float)n;
    printf(""\nMean: "");
    printf(""%f\n"", mean);

    free(a);
    return 0;
}"
problem,"const double *x, double *y, double *dy",,null,"void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}"
exact_solution,"const double *x, double *y",,null,"void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}"
forward_euler_step,"const double dx, const double *x, double *y, double *dy",,null,"void forward_euler_step(const double dx, const double *x, double *y, double *dy)
{
    int o;
    problem(x, y, dy);
    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}"
forward_euler,"double dx, double x0, double x_max, double *y, char save_to_file",,-1 | (double)(t2 - t1) / CLOCKS_PER_SEC,"double forward_euler(double dx, double x0, double x_max, double *y,
                     char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen(""forward_euler.csv"", ""w+"");
        if (fp == NULL)
        {
            perror(""Error! "");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        forward_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                            // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf(""\nEnter the step size: "");
        scanf(""%lg"", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);
    printf(""\tTime = %.6g ms\n"", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen(""exact.csv"", ""w+"");
    if (fp == NULL)
    {
        perror(""Error! "");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf(""Finding exact solution\n"");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf(""\tTime = %.6g ms\n"", total_time);
    fclose(fp);

    return 0;
}"
main,,,-1 | 0,"int main(void)
{
    double **A;
    unsigned int ROWS, COLUMNS;

    printf(""Enter the number of rows and columns: "");
    scanf(""%u %u"", &ROWS, &COLUMNS);
    if (ROWS < COLUMNS)
    {
        fprintf(stderr,
                ""Number of rows must be greater than or equal to ""
                ""number of columns.\n"");
        return -1;
    }

    printf(""Enter matrix elements row-wise:\n"");

    A = (double **)malloc(ROWS * sizeof(double *));
    for (int i = 0; i < ROWS; i++)
        A[i] = (double *)malloc(COLUMNS * sizeof(double));

    for (int i = 0; i < ROWS; i++)
        for (int j = 0; j < COLUMNS; j++) scanf(""%lf"", &A[i][j]);

    print_matrix(A, ROWS, COLUMNS);

    double **R = (double **)malloc(sizeof(double *) * ROWS);
    double **Q = (double **)malloc(sizeof(double *) * ROWS);
    if (!Q || !R)
    {
        perror(""Unable to allocate memory for Q & R!"");
        return -1;
    }
    for (int i = 0; i < ROWS; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * COLUMNS);
        Q[i] = (double *)malloc(sizeof(double) * ROWS);
        if (!Q[i] || !R[i])
        {
            perror(""Unable to allocate memory for Q & R."");
            return -1;
        }
    }

    clock_t t1 = clock();
    qr_decompose(A, Q, R, ROWS, COLUMNS);
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    print_matrix(R, ROWS, COLUMNS);
    print_matrix(Q, ROWS, COLUMNS);
    printf(""Time taken to compute: %.4g sec\n"", dtime);

    for (int i = 0; i < ROWS; i++)
    {
        free(A[i]);
        free(R[i]);
        free(Q[i]);
    }
    free(A);
    free(R);
    free(Q);
    return 0;
}"
main,,,0,"
int main()
{
    int a[10], n, i, j, temp;
    float mean, median;

    printf(""Enter no. for Random Numbers :"");
    scanf(""%d"", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf(""Random Numbers Generated are :\n"");
    for (i = 0; i < n; i++)
    {
        printf(""\n%d"", a[i]);
    }
    printf(""\n"");
    printf(""\nSorted Data:"");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf(""\n%d"", a[i]);
    }

    if (n % 2 == 0)
    {
        median = (a[n / 2] + a[(n / 2) - 1]) / 2;
    }
    else
    {
        median = a[n / 2];
    }
    printf(""\nMedian is : %f"", median);

    return 0;
}"
problem,"const double *x, double *y, double *dy",,null,"void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}"
exact_solution,"const double *x, double *y",,null,"void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}"
semi_implicit_euler_step,"double dx, double *x, double *y, double *dy",,null,"void semi_implicit_euler_step(double dx, double *x, double *y, double *dy)
{
    int o;

    problem(x, y, dy);   // update dy once
    y[0] += dx * dy[0];  // update y0

    problem(x, y, dy);  // update dy once more

    for (o = 1; o < order; o++)
        y[o] += dx * dy[o];  // update remaining using new dy
    *x += dx;
}"
semi_implicit_euler,"double dx, double x0, double x_max, double *y, char save_to_file",,-1 | (double)(t2 - t1) / CLOCKS_PER_SEC,"double semi_implicit_euler(double dx, double x0, double x_max, double *y,
                           char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen(""semi_implicit_euler.csv"", ""w+"");
        if (fp == NULL)
        {
            perror(""Error! "");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        semi_implicit_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                                  // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf(""\nEnter the step size: "");
        scanf(""%lg"", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);
    printf(""\tTime = %.6g ms\n"", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen(""exact.csv"", ""w+"");
    if (fp == NULL)
    {
        perror(""Error! "");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf(""Finding exact solution\n"");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, ""%.4g,%.4g,%.4g\n"", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf(""\tTime = %.6g ms\n"", total_time);
    fclose(fp);

    return 0;
}"
create_matrix,"double **A, int N",,null,"void create_matrix(double **A, int N)
{
    int i, j, tmp, lim2 = LIMS >> 1;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        A[i][i] = (rand() % LIMS) - lim2;
        for (j = i + 1; j < N; j++)
        {
            tmp = (rand() % LIMS) - lim2;
            A[i][j] = tmp;
            A[j][i] = tmp;
        }
    }
}"
eigen_values,"double **A, double *eigen_vals, int mat_size, char debug_print",,-1 | dtime,"double eigen_values(double **A, double *eigen_vals, int mat_size,
                    char debug_print)
{
    if (!eigen_vals)
    {
        perror(""Output eigen value vector cannot be NULL!"");
        return -1;
    }
    double **R = (double **)malloc(sizeof(double *) * mat_size);
    double **Q = (double **)malloc(sizeof(double *) * mat_size);
    if (!Q || !R)
    {
        perror(""Unable to allocate memory for Q & R!"");
        if (Q)
        {
            free(Q);
        }
        if (R)
        {
            free(R);
        }
        return -1;
    }

    /* allocate dynamic memory for matrices */
    for (int i = 0; i < mat_size; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * mat_size);
        Q[i] = (double *)malloc(sizeof(double) * mat_size);
        if (!Q[i] || !R[i])
        {
            perror(""Unable to allocate memory for Q & R."");
            for (; i >= 0; i--)
            {
                free(R[i]);
                free(Q[i]);
            }
            free(Q);
            free(R);
            return -1;
        }
    }

    if (debug_print)
    {
        print_matrix(A, mat_size, mat_size);
    }

    int rows = mat_size, columns = mat_size;
    int counter = 0, num_eigs = rows - 1;
    double last_eig = 0;

    clock_t t1 = clock();
    while (num_eigs > 0) /* continue till all eigen values are found */
    {
        /* iterate with QR decomposition */
        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)
        {
            last_eig = A[num_eigs][num_eigs];
            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; /* A - cI */
            qr_decompose(A, Q, R, rows, columns);

            if (debug_print)
            {
                print_matrix(A, rows, columns);
                print_matrix(Q, rows, columns);
                print_matrix(R, columns, columns);
                printf(""-------------------- %d ---------------------\n"",
                       ++counter);
            }

            mat_mul(R, Q, A, columns, columns, rows, columns);
            for (int i = 0; i < rows; i++) A[i][i] += last_eig; /* A + cI */
        }

        /* store the converged eigen value */
        eigen_vals[num_eigs] = last_eig;

        if (debug_print)
        {
            printf(""========================\n"");
            printf(""Eigen value: % g,\n"", last_eig);
            printf(""========================\n"");
        }

        num_eigs--;
        rows--;
        columns--;
    }
    eigen_vals[0] = A[0][0];
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    if (debug_print)
    {
        print_matrix(R, mat_size, mat_size);
        print_matrix(Q, mat_size, mat_size);
    }

    /* cleanup dynamic memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(R[i]);
        free(Q[i]);
    }
    free(R);
    free(Q);

    return dtime;
}"
test1,,,null,"void test1()
{
    int mat_size = 2;
    double X[][2] = {{5, 7}, {7, 11}};
    double y[] = {15.56158, 0.384227};  // corresponding y-values
    double eig_vals[2] = {0, 0};

    // The following steps are to convert a ""double[][]"" to ""double **""
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf(""------- Test 1 -------\n"");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf(""%d/5 Checking for %.3g --> "", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf(""(%.3g) "", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf(""found\n"");
    }
    printf(""Test 1 Passed in %.3g sec\n\n"", dtime);
    free(A);
}"
test2,,,null,"void test2()
{
    int mat_size = 5;
    double X[][5] = {{-4, 4, 2, 0, -3},
                     {4, -4, 4, -3, -1},
                     {2, 4, 4, 3, -3},
                     {0, -3, 3, -1, -3},
                     {-3, -1, -3, -3, 0}};
    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,
                  -5.98994};  // corresponding y-values
    double eig_vals[5];

    // The following steps are to convert a ""double[][]"" to ""double **""
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf(""------- Test 2 -------\n"");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf(""%d/5 Checking for %.3g --> "", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf(""(%.3g) "", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf(""found\n"");
    }
    printf(""Test 2 Passed in %.3g sec\n\n"", dtime);
    free(A);
}"
main,"int argc, char **argv",,0 | -1,"int main(int argc, char **argv)
{
    srand(time(NULL));

    int mat_size = 5;
    if (argc == 2)
    {
        mat_size = atoi(argv[1]);
    }
    else
    {  // if invalid input argument is given run tests
        test1();
        test2();
        printf(""Usage: ./qr_eigen_values [mat_size]\n"");
        return 0;
    }

    if (mat_size < 2)
    {
        fprintf(stderr, ""Matrix size should be > 2\n"");
        return -1;
    }

    int i;

    double **A = (double **)malloc(sizeof(double *) * mat_size);
    /* number of eigen values = matrix size */
    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);
    if (!eigen_vals)
    {
        perror(""Unable to allocate memory for eigen values!"");
        free(A);
        return -1;
    }
    for (i = 0; i < mat_size; i++)
    {
        A[i] = (double *)malloc(sizeof(double) * mat_size);
        eigen_vals[i] = 0.f;
    }

    /* create a random matrix */
    create_matrix(A, mat_size);

    print_matrix(A, mat_size, mat_size);

    double dtime = eigen_values(A, eigen_vals, mat_size, 0);
    printf(""Eigen vals: "");
    for (i = 0; i < mat_size; i++) printf(""% 9.4g\t"", eigen_vals[i]);
    printf(""\nTime taken to compute: % .4g sec\n"", dtime);

    for (int i = 0; i < mat_size; i++) free(A[i]);
    free(A);
    free(eigen_vals);
    return 0;
}"
lu_decomposition,"double **A, double **L, double **U, int mat_size",,0,"int lu_decomposition(double **A, double **L, double **U, int mat_size)
{
    int row, col, j;

    // regularize each row
    for (row = 0; row < mat_size; row++)
    {
        // Upper triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];

            // Evaluate U[i,k]
            U[row][col] = A[row][col] - lu_sum;
        }

        // Lower triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            if (row == col)
            {
                L[row][col] = 1.;
                continue;
            }

            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];

            // Evaluate U[i,k]
            L[col][row] = (A[col][row] - lu_sum) / U[row][row];
        }
    }

    return 0;
}"
display,"double **A, int N",,null,"void display(double **A, int N)
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            printf(""% 3.3g \t"", A[i][j]);
        }
        putchar('\n');
    }
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    int mat_size = 3;  // default matrix size
    const int range = 10;
    const int range2 = range >> 1;

    if (argc == 2)
        mat_size = atoi(argv[1]);

    srand(time(NULL));  // random number initializer

    /* Create a square matrix with random values */
    double **A = (double **)malloc(mat_size * sizeof(double *));
    double **L = (double **)malloc(mat_size * sizeof(double *));  // output
    double **U = (double **)malloc(mat_size * sizeof(double *));  // output
    for (int i = 0; i < mat_size; i++)
    {
        // calloc so that all valeus are '0' by default
        A[i] = (double *)calloc(mat_size, sizeof(double));
        L[i] = (double *)calloc(mat_size, sizeof(double));
        U[i] = (double *)calloc(mat_size, sizeof(double));
        for (int j = 0; j < mat_size; j++)
            /* create random values in the limits [-range2, range-1] */
            A[i][j] = (double)(rand() % range - range2);
    }

    lu_decomposition(A, L, U, mat_size);

    printf(""A = \n"");
    display(A, mat_size);
    printf(""\nL = \n"");
    display(L, mat_size);
    printf(""\nU = \n"");
    display(U, mat_size);

    /* Free dynamically allocated memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(A[i]);
        free(L[i]);
        free(U[i]);
    }
    free(A);
    free(L);
    free(U);

    return 0;
}"
matrixChainOrder,"int l, const int *p, int *s",,result,"int matrixChainOrder(int l, const int *p, int *s)
{
    // mat stores the cost for a chain that starts at i and ends on j (inclusive
    // on both ends)
    int **mat = malloc(l * sizeof(int *));
    for (int i = 0; i < l; ++i)
    {
        mat[i] = malloc(l * sizeof(int));
    }

    for (int i = 0; i < l; ++i)
    {
        mat[i][i] = 0;
    }
    // cl denotes the difference between start / end indices, cl + 1 would be
    // chain length.
    for (int cl = 1; cl < l; ++cl)
    {
        for (int i = 0; i < l - cl; ++i)
        {
            int j = i + cl;
            mat[i][j] = INT_MAX;
            for (int div = i; div < j; ++div)
            {
                int q = mat[i][div] + mat[div + 1][j] + p[i] * p[div] * p[j];
                if (q < mat[i][j])
                {
                    mat[i][j] = q;
                    s[i * l + j] = div;
                }
            }
        }
    }
    int result = mat[0][l - 1];

    // Free dynamically allocated memory
    for (int i = 0; i < l; ++i)
    {
        free(mat[i]);
    }
    free(mat);

    return result;
}"
printSolution,"int l, int *s, int i, int j",,null,"void printSolution(int l, int *s, int i, int j)
{
    if (i == j)
    {
        printf(""A%d"", i);
        return;
    }
    putchar('(');
    printSolution(l, s, i, s[i * l + j]);
    printSolution(l, s, s[i * l + j] + 1, j);
    putchar(')');
}"
test,,,null,"static void test()
{
    int sizes[] = {35, 15, 5, 10, 20, 25};
    int len = 6;
    int *sol = malloc(len * len * sizeof(int));
    int r = matrixChainOrder(len, sizes, sol);
    assert(r == 18625);
    printf(""Result : %d\n"", r);
    printf(""Optimal ordering : "");
    printSolution(len, sol, 0, 5);
    free(sol);

    printf(""\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
lcslen,"const char *s1, const char *s2, int l1, int l2, int **L, int **B",,null,"void lcslen(const char *s1, const char *s2, int l1, int l2, int **L, int **B) {
	/* B is the directions matrix
	   L is the LCS matrix */
	int i, j;

	/* loop over the simbols in my sequences
	   save the directions according to the LCS */
	for (i = 1; i <= l1; ++i) {
		for (j = 1; j <= l2; ++j) {
			if (s1[i-1] == s2[j-1]) {
				L[i][j] = 1 + L[i-1][j-1];
				B[i][j] = DIAG;
			}
			else if (L[i-1][j] < L[i][j-1]) {
				L[i][j] = L[i][j-1];
				B[i][j] = LEFT;
			}
			else {
				L[i][j] = L[i-1][j];
				B[i][j] = UP;
            }
		}
	}
}"
lcsbuild,"const char *s1, int l1, int l2, int **L, int **B",,NULL | lcs,"char *lcsbuild(const char *s1, int l1, int l2, int **L, int **B) {
	int	 i, j, lcsl;
	char	*lcs;
	lcsl = L[l1][l2];
	
	/* my lcs is at least the empty symbol */
	lcs = (char *)calloc(lcsl+1, sizeof(char)); /* null-terminated \0 */
	if (!lcs) {
		perror(""calloc: "");
		return NULL;
	}

	i = l1, j = l2;
	while (i > 0 && j > 0) {
		/* walk the matrix backwards */
		if (B[i][j] == DIAG) {
			lcs[--lcsl] = s1[i-1];
			i = i - 1;
			j = j - 1;
		}
        else if (B[i][j] == LEFT)
        {
            j = j - 1;
		}
        else
        {
            i = i - 1;
        }
	}
	return lcs;
}"
test,,,null,"static void test() {
	/* https://en.wikipedia.org/wiki/Subsequence#Applications */
	int **L, **B, j, l1, l2;
	
	char *s1 = ""ACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA"";
	char *s2 = ""CGTTCGGCTATCGTACGTTCTATTCTATGATTTCTAA"";
	char *lcs;
	
	l1 = strlen(s1);
	l2 = strlen(s2);
	
	L = (int **)calloc(l1+1, sizeof(int *));
	B = (int **)calloc(l1+1, sizeof(int *));
	
	if (!L) {
		perror(""calloc: "");
		exit(1);
	}
	if (!B) {
		perror(""calloc: "");
		exit(1);
	}
	for (j = 0; j <= l1; j++) {
		L[j] = (int *)calloc(l2+1, sizeof(int));
		if (!L[j]) {
			perror(""calloc: "");
			exit(1);
		}
		B[j] = (int *)calloc(l2+1, sizeof(int));
		if (!L[j]) {
			perror(""calloc: "");
			exit(1);
		}
	}
	
	lcslen(s1, s2, l1, l2, L, B);
	lcs = lcsbuild(s1, l1, l2, L, B);
	
	assert(L[l1][l2] == 27);
	assert(strcmp(lcs, ""CGTTCGGCTATGCTTCTACTTATTCTA"") == 0);
	
	printf(""S1: %s\tS2: %s\n"", s1, s2);
	printf(""LCS len:%3d\n"", L[l1][l2]);
	printf(""LCS: %s\n"", lcs);

	free(lcs);
    for (j = 0; j <= l1; j++)
    {
        free(L[j]), free(B[j]);
	}
	free(L);
	free(B);

	printf(""All tests have successfully passed!\n"");
}"
main,"int argc, char *argv[]","@brief Self-test implementations
@returns void",0,"int main(int argc, char *argv[]) {
	test();  // run self-test implementations
	return 0;
}"
create,,,null,void create() { head = NULL; }
push,int x,Initialize the stack to NULL.,null,"void push(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(1 * sizeof(struct node));
        head->next = NULL;
        head->pre = NULL;
        head->data = x;
    }
    else
    {
        tmp = (struct node *)malloc(1 * sizeof(struct node));
        tmp->data = x;
        tmp->next = NULL;
        tmp->pre = head;
        head->next = tmp;
        head = tmp;
    }
    ++count;
}"
pop,,,returnData,"int pop()
{
    int returnData;
    if (head == NULL)
    {
        printf(""ERROR: Pop from empty stack.\n"");
        exit(1);
    }
    else
    {
        returnData = head->data;

        if (head->pre == NULL)
        {
            free(head);
            head = NULL;
        }
        else
        {
            head = head->pre;
            free(head->next);
        }
    }
    --count;
    return returnData;
}"
peek,,,head->data,"int peek()
{
    if (head != NULL)
        return head->data;
    else
    {
        printf(""ERROR: Peeking from empty stack."");
        exit(1);
    }
}"
size,,,count,int size() { return count; }
isEmpty,,Returns the size of the stack.,1 | 0,"int isEmpty()
{
    if (count == 0)
        return 1;
    return 0;
}"
init,"Vector* vec, int val",,null,"void init(Vector* vec, int val) {
    vec->contents = (int*)malloc(sizeof(int));
    vec->contents[0] = val;
    vec->current = 0;
    vec->len = 1;
}"
delete,Vector* vec,,null,"void delete(Vector* vec) {
    free(vec->contents);    
}"
clear,Vector* vec,,null,"void clear(Vector* vec) {
    delete(vec);
    init(vec, 0);
}"
len,Vector* vec,,vec->len,"int len(Vector* vec) {
    return vec->len;    
}"
push,"Vector* vec, int val",,null,"void push(Vector* vec, int val) {
    vec->contents = realloc(vec->contents, (sizeof(int) * (vec->len + 1)));
    vec->contents[vec->len] = val;
    vec->len++;
}"
get,"Vector* vec, int index",,vec->contents[index] | -1,"int get(Vector* vec, int index) {
    if(index < vec->len) {
        return vec->contents[index];
    }
    return -1;
}"
set,"Vector* vec, int index, int val",,null,"void set(Vector* vec, int index, int val) {
    if(index < vec->len) {
        vec->contents[index] = val;
    }
}"
next,Vector* vec,,current_val,"int next(Vector* vec) {
    if(vec->current == vec->len) {
        vec->current = 0;
    }
    int current_val = vec->contents[vec->current];
    vec->current++;
    return current_val;
}"
begin,Vector* vec,,(void*)vec->contents,"void* begin(Vector* vec) {
    return (void*)vec->contents;
}"
print,Vector* vec,,null,"void print(Vector* vec) {
    int size = vec->len;
    printf(""[ "");
    for(int count = 0; count < size; count++) {
        printf(""%d "", vec->contents[count]);
    }
    printf(""]\n"");
}"
test,,,null,"static void test() {
    Vector vec;
    init(&vec, 10);
    assert(get(&vec, 0) == 10);
    push(&vec, 20);
    assert(get(&vec, 1) == 20);
    set(&vec, 0, 11);
    assert(get(&vec, 0) == 11);
    assert(next(&vec) == 11);
    set(&vec, 1, 22);
    assert(get(&vec, 1) == 22);
    assert(len(&vec) == 2);
}"
main,,,0,"int main() {
    test();

    Vector vec;
    init(&vec, 10);
    push(&vec, 20);
    print(&vec);
    set(&vec, 0, 11);
    set(&vec, 1, 22);
    print(&vec);
    printf(""Length: %d\n"", len(&vec));
    return 0;
}"
grow,,,null,"void grow()
{
    max += 10; /* increases the capacity */

    int i;  // for the loop
    void **tmp = malloc(sizeof(void *) * max);

    /* copies the elements from the origin array in the new one. */
    for (i = 0; i < max - 10; i++)
    {
        *(tmp + i) = *(array + i);
    }
    /*free the memory */
    free(array);
    array = tmp;
}"
push,void *object,"grow: increases the stack by 10 elements.
          This utility function isn't part of the public interface",top | counter | counter == 0 | array[offset],"void push(void *object)
{
    assert(object); /* tests whether pointer isn't null */

    if (counter < max)
    {
        offset++; /* increases the element-pointer */

        /*
            moves pointer by the offset address
            pushs the object onto stack
         */
        *(array + offset) = object;

        /* increases the inner counter */
        counter++;
    }
    else /* stack is full */
    {
        grow();       /* lets grow stack */
        push(object); /* recursive call */
    }
}

/*
    pop: pops the top element of the stack from the stack.
*/
void *pop()
{
    void *top = *(array + offset);

    /* check pointers */
    assert(top);

    /* if use the pop-function, stack must not empty. */
    assert(!isEmpty());

    /* decreases the offset address for pointing of
        the new top element */
    offset--;

    /* decreases the inner counter */
    counter--;

    return top;
}

/*
    size: gets the number of elements of the stack.
*/
int size() { return counter; }

/*
    isEmpty(): returns 1 if stack is empty otherwise 0.
*/
int isEmpty() { return counter == 0; }

/*
    top: returns the top element from the stack without removing it.
*/
void *top()
{
    /* offset address points to the top element */
    return array[offset];
}"
pop,,push: pushs the argument onto the stack,top,"void *pop()
{
    void *top = *(array + offset);

    /* check pointers */
    assert(top);

    /* if use the pop-function, stack must not empty. */
    assert(!isEmpty());

    /* decreases the offset address for pointing of
        the new top element */
    offset--;

    /* decreases the inner counter */
    counter--;

    return top;
}"
size,,,counter,int size() { return counter; }
isEmpty,,size: gets the number of elements of the stack.,counter == 0,int isEmpty() { return counter == 0; }
top,,isEmpty(): returns 1 if stack is empty otherwise 0.,array[offset],"void *top()
{
    /* offset address points to the top element */
    return array[offset];
}"
push,"DArrayStack *ptr, int data",,ptr->top,"int push(DArrayStack *ptr, int data)
{
    if (ptr->top == (ptr->capacity) - 1)
    {
        ptr = double_array(ptr, ptr->capacity);
        ptr->top++;
        ptr->arrPtr[ptr->top] = data;
    }
    else
    {
        ptr->top++;
        ptr->arrPtr[ptr->top] = data;
    }
    printf(""Successfully pushed : %d\n"", data);
    return ptr->top;
}"
pop,DArrayStack *ptr,,-1 | ele,"int pop(DArrayStack *ptr)
{
    if (ptr->top == -1)
    {
        printf(""Stack is empty UNDERFLOW \n"");
        return -1;
    }
    int ele = ptr->arrPtr[ptr->top];
    ptr->arrPtr[ptr->top] = 0;
    ptr->top = (ptr->top - 1);
    if ((ptr->capacity) % 2 == 0)
    {
        if (ptr->top <= (ptr->capacity / 2) - 1)
        {
            ptr = shrink_array(ptr, ptr->capacity);
        }
    }
    printf(""Successfully popped: %d\n"", ele);
    return ele;
}"
peek,DArrayStack *ptr,,-1 | ptr->arrPtr[ptr->top],"int peek(DArrayStack *ptr)
{
    if (ptr->top == -1)
    {
        printf(""Stack is empty UNDERFLOW \n"");
        return -1;
    }
    return ptr->arrPtr[ptr->top];
}"
show_capacity,DArrayStack *ptr,,ptr->capacity,int show_capacity(DArrayStack *ptr) { return ptr->capacity; }
isempty,DArrayStack *ptr,"@brief To display the current capacity of the stack.
@param ptr Stack pointer
@return int Current capacity of the stack",1 | 0,"int isempty(DArrayStack *ptr)
{
    if (ptr->top == -1)
    {
        return 1;
    }
    return 0;
}"
stack_size,DArrayStack *ptr,,ptr->top + 1,int stack_size(DArrayStack *ptr) { return ptr->top + 1; }
test,,"@brief Used to get the size of the Stack or the number of elements present in
the Stack.
@param ptr Stack pointer
@return int size of stack",null,"static void test()
{
    DArrayStack *NewStack;
    int capacity = 1;
    NewStack = create_stack(capacity);
    uint64_t arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

    printf(""\nTesting Empty stack: "");
    assert(stack_size(NewStack) == 0);
    assert(isempty(NewStack) == 1);
    printf(""Size of an empty stack is %d\n"", stack_size(NewStack));

    printf(""\nTesting PUSH operation:\n"");
    for (int i = 0; i < 12; ++i)
    {
        int topVal = push(NewStack, arr[i]);
        printf(""Size: %d, Capacity: %d\n\n"", stack_size(NewStack),
               show_capacity(NewStack));
        assert(topVal == i);
        assert(peek(NewStack) == arr[i]);
        assert(stack_size(NewStack) == i + 1);
        assert(isempty(NewStack) == 0);
    }

    printf(""\nTesting POP operation:\n"");
    for (int i = 11; i > -1; --i)
    {
        peek(NewStack);
        assert(peek(NewStack) == arr[i]);
        int ele = pop(NewStack);
        assert(ele == arr[i]);
        assert(stack_size(NewStack) == i);
    }

    printf(""\nTesting Empty stack size: "");
    assert(stack_size(NewStack) == 0);
    assert(isempty(NewStack) == 1);
    printf(""Size of an empty stack is %d\n"", stack_size(NewStack));

    printf(""\nTesting POP operation on empty stack: "");
    assert(pop(NewStack) == -1);
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
main,,,0 | (0),"
int main()
{
    int x;
    while (1)
    {
        printf(""\n0 or CTRL-C to Exit "");
        printf(""\n1. Push"");
        printf(""\n2. Pop"");
        printf(""\n3. Peek"");
        printf(""\n4. Update"");
        printf(""\n5. Display"");
        printf(""\nEnter your choice? \n"");
        scanf(""%d"", &x);
        switch (x)
        {
        case 0:
            return 0;
        case 1:
            push();
            break;
        case 2:
            pop();
            break;
        case 3:
            peek();
            break;
        case 4:
            update();
            break;
        case 5:
            display();
            break;
        default:
            printf(""\nInvalid choice,\nPlease try again.\n"");
        }
    }
    return (0);
}"
push,,,null,"
void push()
{
    int n = 0;
    printf(""\nEnter the value to be inserted: "");
    scanf(""%d"", &n);
    top += 1;
    a[top] = n;
}"
pop,,,null,"
void pop()
{
    if (top == -1)
    {
        printf(""\nStack is empty"");
    }
    else
    {
        int item;
        item = a[top];
        top -= 1;
        printf(""\nPoped item is %d "", item);
    }
}"
peek,,,null,"
void peek()
{
    if (top >= 0)
        printf(""\nThe top element is %d"", a[top]);
    else
        printf(""\nStack is empty"");
}"
update,,,null,"
void update()
{
    int i, n;
    printf(""\nEnter the position to update? "");
    scanf(""%d"", &i);
    printf(""\nEnter the item to insert? "");
    scanf(""%d"", &n);
    if (top - i + 1 < 0)
    {
        printf(""\nUnderflow condition "");
    }
    else
    {
        a[top - i + 1] = n;
    }
}"
display,,,null,"
void display()
{
    if (top == -1)
    {
        printf(""\nStack is empty"");
    }
    else
    {
        for (int i = top; i >= 0; i--)
        {
            printf(""%d\n"", a[i]);
        }
    }
}"
isBalanced,char *s,,"0 | 1
    return (c == 0) ? 1 : 0","
int isBalanced(char *s)
{
    int i = 0;
    char x;
    while (s[i] != '\0')  // loop for covering entire string of brackets
    {
        // printf(""\t s[i]=%c\n"", s[i]); //DEBUG
        if (s[i] == '{' || s[i] == '(' ||
            s[i] == '[')  // if opening bracket then push
            push(s[i]);
        else
        {
            if (c <= 0)  // i.e, stack is empty as only opening brackets are
                         // added to stack
                return 0;

            x = pop();
            if (x == '{' && s[i] != '}')
                return 0;
            if (x == '[' && s[i] != ']')
                return 0;
            if (x == '(' && s[i] != ')')
                return 0;
        }
        i++;
    }

    // at end if stack is empy which means whole process has been performed
    // correctly so return 1
    return (c == 0) ? 1 : 0;
}"
destroyStack,,correctly so return 1,null,"
void destroyStack(void)
{
    struct node *p = head;
    if (c > 0)
    {
        while (p->link)
        {
            struct node *tmp = p;
            p = p->link;
            free(tmp);
        }

        c = 0;
    }
}"
main,,,0,"
int main(void)
{
    int t;
    printf(""\t\tBalanced parenthesis\n\n"");
    printf(""\nPlease enter the number of processing rounds? "");
    scanf(""%d"", &t);
    for (int a0 = 0; a0 < t; a0++)
    {
        char s[SIZE];
        printf(""\nPlease enter the expression? "");
        scanf(""%s"", s);

        if (isBalanced(s))
            printf(""\nYES\n"");
        else
            printf(""\nNO\n"");

        /* tidy up stack for new round */
        destroyStack();
    }
    return 0;
}"
Stack_empty,T stack,,stack->count == 0,"int Stack_empty(T stack)
{
    assert(stack);
    return stack->count == 0;
}"
Stack_size,T stack,,stack->count,"int Stack_size(T stack)
{
    assert(stack);
    return stack->count;
}"
Stack_push,"T stack, void *val",,null,"void Stack_push(T stack, void *val)
{
    elem_t *t;

    assert(stack);
    t = (elem_t *)malloc(sizeof(elem_t));
    t->val = val;
    t->next = stack->head;
    stack->head = t;
    stack->count++;
}"
Stack_pop,T stack,,val,"void *Stack_pop(T stack)
{
    void *val;
    elem_t *t;

    assert(stack);
    assert(stack->count > 0);
    t = stack->head;
    stack->head = t->next;
    stack->count--;
    val = t->val;
    free(t);
    return val;
}"
Stack_print,Stack_T stack,,null,"void Stack_print(Stack_T stack)
{
    assert(stack);

    int i, size = Stack_size(stack);
    elem_t *current_elem = stack->head;
    printf(""Stack [Top --- Bottom]: "");
    for (i = 0; i < size; ++i)
    {
        printf(""%p "", (int *)current_elem->val);
        current_elem = current_elem->next;
    }
    printf(""\n"");
}"
main,,,0,"
int main()
{
    Stack_T stk;
    stk = Stack_init();
    Stack_push(stk, (int *)1);
    Stack_push(stk, (int *)2);
    Stack_push(stk, (int *)3);
    Stack_push(stk, (int *)4);
    printf(""Size: %d\n"", Stack_size(stk));
    Stack_print(stk);
    Stack_pop(stk);
    printf(""Stack after popping: \n"");
    Stack_print(stk);
    Stack_pop(stk);
    printf(""Stack after popping: \n"");
    Stack_print(stk);
    return 0;
}"
main,,,0,"
int main()
{
    int vertices, edges, source, i, src, dst;
    printf(""Enter the number of vertices\n"");
    scanf(""%d"", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf(""Enter the number of edges\n"");
    scanf(""%d"", &edges);
    for (i = 0; i < edges; i++)
    {
        printf(""Edge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        addEdge(graph, src, dst);
    }
    printf(""Enter source of bfs\n"");
    scanf(""%d"", &source);
    bfs(graph, source);

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph = createGraph(6);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 4);
    addEdge(graph, 1, 3);
    addEdge(graph, 2, 4);
    addEdge(graph, 3, 4);
    bfs(graph,0);*/

    return 0;
}"
bfs,"struct Graph *graph, int startVertex",,null,"
void bfs(struct Graph *graph, int startVertex)
{
    struct queue *q = createQueue();

    // Add to visited list and put in queue
    graph->visited[startVertex] = 1;
    enqueue(q, startVertex);
    printf(""Breadth first traversal from vertex %d is:\n"", startVertex);

    // Iterate while queue not empty
    while (!isEmpty(q))
    {
        printf(""%d "", pollQueue(q));
        int currentVertex = dequeue(q);

        struct node *temp = graph->adjLists[currentVertex];
        // Add all unvisited neighbours of current vertex to queue to be printed
        // next
        while (temp)
        {
            int adjVertex = temp->vertex;
            // Only add if neighbour is unvisited
            if (graph->visited[adjVertex] == 0)
            {
                graph->visited[adjVertex] = 1;
                enqueue(q, adjVertex);
            }
            temp = temp->next;
        }
    }
}"
createNode,int v,,newNode,"
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}"
createGraph,int vertices,,graph,"
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }

    return graph;
}"
addEdge,"struct Graph *graph, int src, int dest",,null,"
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src; comment it out for directed graph
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}"
createQueue,,,q,"
struct queue *createQueue()
{
    struct queue *q = malloc(sizeof(struct queue));
    q->front = -1;
    q->rear = -1;
    return q;
}"
isEmpty,struct queue *q,,1 | 0,"
int isEmpty(struct queue *q)
{
    if (q->rear == -1)
        return 1;
    else
        return 0;
}"
enqueue,"struct queue *q, int value",,null,"
void enqueue(struct queue *q, int value)
{
    if (q->rear == SIZE - 1)
        printf(""\nQueue is Full!!"");
    else
    {
        if (q->front == -1)
            q->front = 0;
        q->rear++;
        q->items[q->rear] = value;
    }
}"
dequeue,struct queue *q,,item,"
int dequeue(struct queue *q)
{
    int item;
    if (isEmpty(q))
    {
        printf(""Queue is empty"");
        item = -1;
    }
    else
    {
        item = q->items[q->front];
        q->front++;
        if (q->front > q->rear)
        {
            q->front = q->rear = -1;
        }
    }
    return item;
}"
pollQueue,struct queue *q,,q->items[q->front],"
int pollQueue(struct queue *q) { return q->items[q->front]; }"
createGraph,"struct Graph *G, int V",,null,"
void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}"
addEdge,"struct Graph *G, int src, int dst, int weight",,null,"
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}"
print,"int dist[], int V",,null,"
void print(int dist[], int V)
{
    printf(""\nThe Distance matrix for Floyd - Warshall\n"");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            if (dist[i * V + j] != INT_MAX)
                printf(""%d\t"", dist[i * V + j]);
            else
                printf(""INF\t"");
        }
        printf(""\n"");
    }
}"
FloydWarshall,struct Graph *graph,The main function that finds the shortest path from a vertex,null,"
void FloydWarshall(struct Graph *graph)
{
    int V = graph->vertexNum;
    int dist[V][V];

    // Initialise distance array
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist[i][j] = graph->edges[i][j];

    // Calculate distances
    for (int k = 0; k < V; k++)
        // Choose an intermediate vertex

        for (int i = 0; i < V; i++)
            // Choose a source vertex for given intermediate

            for (int j = 0; j < V; j++)
                // Choose a destination vertex for above source vertex

                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&
                    dist[i][k] + dist[k][j] < dist[i][j])
                    // If the distance through intermediate vertex is less than
                    // direct edge then update value in distance array
                    dist[i][j] = dist[i][k] + dist[k][j];

    // Convert 2d array to 1d array for print
    int dist1d[V * V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];

    print(dist1d, V);
}"
main,,,0,"
int main()
{
    int V, E;
    int src, dst, weight;
    struct Graph G;
    printf(""Enter number of vertices: "");
    scanf(""%d"", &V);
    printf(""Enter number of edges: "");
    scanf(""%d"", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf(""\nEdge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        printf(""Enter weight: "");
        scanf(""%d"", &weight);
        addEdge(&G, src, dst, weight);
    }
    FloydWarshall(&G);

    return 0;
}"
degree,"Graph g, int nV, Vertex v",,deg,"
int degree(Graph g, int nV, Vertex v)
{
    int deg = 0;
    Vertex w;
    for (w = 0; w < nV; w++)
        if (adjacent(g, v, w))
            deg++;
    return deg;
}"
main,,,0,"
int main(void)
{
    Edge e;
    int n;

    printf(""Enter the number of vertices: "");
    scanf(""%d"", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf(""Enter source node: "");
    scanf(""%d"", &src);
    printf(""Enter destination node: "");
    scanf(""%d"", &dest);

    printf(""Enter an edge (from): "");
    while (scanf(""%d"", &e.v) == 1)
    {
        printf(""Enter an edge (to): "");
        scanf(""%d"", &e.w);
        insertEdge(g, e);
        printf(""Enter an edge (from): "");
    }
    printf(""Finished.\n"");

    printf(""The graph has "");
    if (hasEulerPath(g, n, src, dest))
        printf(""an"");
    else
        printf(""no"");
    printf("" Euler path from %d to %d.\n"", src, dest);

    freeGraph(g);
    return 0;
}"
createGraph,"int V, int E",,graph,"
struct Graph *createGraph(int V, int E)
{
    struct Graph* graph = (struct Graph*)(malloc(sizeof(struct Graph)));
    graph->V = V;
    graph->E = E;

    graph->edge = (struct Edge*)malloc(sizeof(struct Edge) * E);

    return graph;
}"
find,"struct subset subsets[], int i",A utility function to find set of an element i,subsets[i].parent,"
int find(struct subset subsets[], int i)
{
    // find root and make root as parent of i
    // (path compression)
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);

    return subsets[i].parent;
}"
Union,"struct subset subsets[], int x, int y",A function that does union of two sets of x and y,null,"
void Union(struct subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    // Attach smaller rank tree under root of high
    // rank tree (Union by Rank)
    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;

    // If ranks are same, then make one as root and
    // increment its rank by one
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}"
myComp,"const void *a, const void *b",Compare two edges according to their weights.,a1->weight > b1->weight,"
int myComp(const void *a, const void *b)
{
    struct Edge *a1 = (struct Edge *)a;
    struct Edge *b1 = (struct Edge *)b;
    return a1->weight > b1->weight;
}"
KruskalMST,struct Graph *graph,,0,"
void KruskalMST(struct Graph *graph)
{
    int V = graph->V;
    struct Edge result[V];  // Tnis will store the resultant MST
    int e = 0;              // An index variable, used for result[]
    int i = 0;              // An index variable, used for sorted edges

    // Step 1: Sort all the edges in non-decreasing
    // order of their weight. If we are not allowed to
    // change the given graph, we can create a copy of
    // array of edges
    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);

    // Allocate memory for creating V ssubsets
    struct subset *subsets = (struct subset *)malloc(V * sizeof(struct subset));

    // Create V subsets with single elements
    for (int v = 0; v < V; ++v)
    {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Number of edges to be taken is equal to V-1
    while (e < V - 1 && i < graph->E)
    {
        // Step 2: Pick the smallest edge. And increment
        // the index for next iteration
        struct Edge next_edge = graph->edge[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // If including this edge does't cause cycle,
        // include it in result and increment the index
        // of result for next edge
        if (x != y)
        {
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
        // Else discard the next_edge
    }

    // print the contents of result[] to display the
    // built MST
    printf(""Following are the edges in the constructed MST\n"");
    for (i = 0; i < e; ++i)
        printf(""%d -- %d == %d\n"", result[i].src, result[i].dest,
               result[i].weight);
    return;
}

// Driver program to test above functions
int main()
{
    /* Let us create following weighted graph
            10
        0--------1
        | \	 |
    6| 5\ |15
        |	 \ |
        2--------3
            4	 */
    int V = 4;  // Number of vertices in graph
    int E = 5;  // Number of edges in graph
    struct Graph *graph = createGraph(V, E);

    // add edge 0-1
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = 10;

    // add edge 0-2
    graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 6;

    // add edge 0-3
    graph->edge[2].src = 0;
    graph->edge[2].dest = 3;
    graph->edge[2].weight = 5;

    // add edge 1-3
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 15;

    // add edge 2-3
    graph->edge[4].src = 2;
    graph->edge[4].dest = 3;
    graph->edge[4].weight = 4;

    KruskalMST(graph);

    return 0;
}
"
main,,,0,"
int main()
{
    /* Let us create following weighted graph
            10
        0--------1
        | \	 |
    6| 5\ |15
        |	 \ |
        2--------3
            4	 */
    int V = 4;  // Number of vertices in graph
    int E = 5;  // Number of edges in graph
    struct Graph *graph = createGraph(V, E);

    // add edge 0-1
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = 10;

    // add edge 0-2
    graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 6;

    // add edge 0-3
    graph->edge[2].src = 0;
    graph->edge[2].dest = 3;
    graph->edge[2].weight = 5;

    // add edge 1-3
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 15;

    // add edge 2-3
    graph->edge[4].src = 2;
    graph->edge[4].dest = 3;
    graph->edge[4].weight = 4;

    KruskalMST(graph);

    return 0;
}"
createGraph,"struct Graph *G, int V",,null,"
void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}"
addEdge,"struct Graph *G, int src, int dst, int weight",,null,"
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}"
minDistance,"int mdist[], int vset[], int V",,minInd,"
int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX;
    static int minInd = -1; //remembers the previous value if not modified in the loop
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}"
print,"int dist[], int V",,null,"
void print(int dist[], int V)
{
    printf(""\nVertex  Distance\n"");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf(""%d\t%d\n"", i, dist[i]);
        else
            printf(""%d\tINF"", i);
    }
}"
Dijkstra,"struct Graph *graph, int src",The main function that finds the shortest path from given source,null,"
void Dijkstra(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int mdist[V];  // Stores updated distances to vertex
    int vset[V];   // vset[i] is true if the vertex i included
                   // in the shortest path tree

    // Initialise mdist and vset. Set distance of source as zero
    for (int i = 0; i < V; i++) mdist[i] = INT_MAX, vset[i] = 0;

    mdist[src] = 0;

    // iterate to find shortest path
    for (int count = 0; count < V - 1; count++)
    {
        int u = minDistance(mdist, vset, V);
        vset[u] = 1;

        for (int v = 0; v < V; v++)
        {
            if (!vset[v] && graph->edges[u][v] != INT_MAX &&
                mdist[u] + graph->edges[u][v] < mdist[v])
                mdist[v] = mdist[u] + graph->edges[u][v];
        }
    }

    print(mdist, V);

    return;
}"
main,,,0,"
int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf(""Enter number of vertices: "");
    scanf(""%d"", &V);
    printf(""Enter number of edges: "");
    scanf(""%d"", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf(""\nEdge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        printf(""Enter weight: "");
        scanf(""%d"", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf(""\nEnter source:"");
    scanf(""%d"", &gsrc);
    Dijkstra(&G, gsrc);

    return 0;
}"
main,,,0,"
int main()
{
    int vertices, edges, i, src, dst;
    printf(""Enter the number of vertices\n"");
    scanf(""%d"", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf(""Enter the number of edges\n"");
    scanf(""%d"", &edges);
    for (i = 0; i < edges; i++)
    {
        printf(""Edge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        addEdge(graph, src, dst);
    }
    printf(""One topological sort order is:\n"");
    topologicalSort(graph);
    printf(""\n"");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph2 = createGraph(4);
    addEdge(graph2, 0, 1);
    addEdge(graph2, 0, 2);
    addEdge(graph2, 1, 2);
    addEdge(graph2, 2, 3);
    printf(""One topological sort is:\n"");
    topologicalSort(graph2);
    printf(""\n"");*/
    return 0;
}"
topologicalSortHelper,"int vertex, struct Graph *graph, struct Stack *stack",,null,"
void topologicalSortHelper(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
    // First add all dependents (that is, children) to stack
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            topologicalSortHelper(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
    // and then add itself
    push(stack, vertex);
}"
topologicalSort,struct Graph *graph,,null,"
void topologicalSort(struct Graph *graph)
{
    struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
        // Execute topological sort on all elements
        if (graph->visited[i] == 0)
        {
            topologicalSortHelper(i, graph, stack);
        }
    }
    while (stack->top != -1) printf(""%d "", pop(stack));
}"
createNode,int v,,newNode,"
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}"
createGraph,int vertices,,graph,"
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}"
addEdge,"struct Graph *graph, int src, int dest",,null,"
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}"
printGraph,struct Graph *graph,,null,"
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf(""\n Adjacency list of vertex %d\n "", v);
        while (temp)
        {
            printf(""%d -> "", temp->vertex);
            temp = temp->next;
        }
        printf(""\n"");
    }
}"
createStack,,,stack,"
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}"
push,"struct Stack *stack, int element",,null,"
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  // Increment then add, as we start from -1
}"
pop,struct Stack *stack,,INT_MIN | stack->arr[stack->top--],"
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}"
createGraph,"struct Graph *G, int V, int E",,null,"
void createGraph(struct Graph *G, int V, int E)
{
    G->vertexNum = V;
    G->edgeNum = E;
    G->edges = (struct Edge *)malloc(E * sizeof(struct Edge));
}"
addEdge,"struct Graph *G, int src, int dst, int weight",,null,"
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    static int ind;
    struct Edge newEdge;
    newEdge.src = src;
    newEdge.dst = dst;
    newEdge.weight = weight;
    G->edges[ind++] = newEdge;
}"
minDistance,"int mdist[], int vset[], int V",,minInd,"
int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX, minInd;
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}"
print,"int dist[], int V",,null,"
void print(int dist[], int V)
{
    printf(""\nVertex  Distance\n"");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf(""%d\t%d\n"", i, dist[i]);
        else
            printf(""%d\tINF"", i);
    }
}"
BellmanFord,"struct Graph *graph, int src",The main function that finds the shortest path from given source,null,"
void BellmanFord(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int E = graph->edgeNum;
    int dist[V];

    // Initialize distances array as INF for all except source
    // Intialize source as zero
    for (int i = 0; i < V; i++) dist[i] = INT_MAX;
    dist[src] = 0;

    // Calculate shortest path distance from source to all edges
    // A path can contain maximum (|V|-1) edges
    for (int i = 0; i <= V - 1; i++)
        for (int j = 0; j < E; j++)
        {
            int u = graph->edges[j].src;
            int v = graph->edges[j].dst;
            int w = graph->edges[j].weight;

            if (dist[u] != INT_MAX && dist[u] + w < dist[v])
                dist[v] = dist[u] + w;
        }

    // Iterate inner loop once more to check for negative cycle
    for (int j = 0; j < E; j++)
    {
        int u = graph->edges[j].src;
        int v = graph->edges[j].dst;
        int w = graph->edges[j].weight;

        if (dist[u] != INT_MAX && dist[u] + w < dist[v])
        {
            printf(
                ""Graph contains negative weight cycle. Hence, shortest ""
                ""distance not guaranteed."");
            return;
        }
    }

    print(dist, V);

    return;
}"
main,,,0,"
int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf(""Enter number of vertices: "");
    scanf(""%d"", &V);
    printf(""Enter number of edges: "");
    scanf(""%d"", &E);
    createGraph(&G, V, E);
    for (int i = 0; i < E; i++)
    {
        printf(""\nEdge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        printf(""Enter weight: "");
        scanf(""%d"", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf(""\nEnter source:"");
    scanf(""%d"", &gsrc);
    BellmanFord(&G, gsrc);

    return 0;
}"
main,,,0,"
int main()
{
    int vertices, edges, i, src, dst;
    printf(""Enter the number of vertices\n"");
    scanf(""%d"", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf(""Enter the number of edges\n"");
    scanf(""%d"", &edges);
    for (i = 0; i < edges; i++)
    {
        printf(""Edge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        addEdge(graph, src, dst);
    }
    printf(""The strongly connected conponents are:\n"");
    scc(graph);
    printf(""\n"");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph2 = createGraph(4);
    addEdge(graph2, 0, 1);
    addEdge(graph2, 1, 2);
    addEdge(graph2, 2, 0);
    addEdge(graph2, 2, 3);
    printf(""The strongly connected components are:\n"");
    scc(graph2);
    printf(""\n"");*/
    return 0;
}"
fillOrder,"int vertex, struct Graph *graph, struct Stack *stack",,null,"
void fillOrder(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
    // First add all dependents (that is, children) to stack
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            fillOrder(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
    // and then add itself
    push(stack, vertex);
}"
transpose,struct Graph *g,and then add itself,graph,"
struct Graph *transpose(struct Graph *g)
{
    struct Graph *graph =
        createGraph(g->numVertices);  // Number of vertices is same
    int i = 0;
    for (i = 0; i < g->numVertices; i++)
    {
        struct node *temp = g->adjLists[i];
        while (temp != NULL)
        {
            addEdge(graph, temp->vertex, i);  // Reverse all edges
            temp = temp->next;
        }
    }
    return graph;
}"
dfs,"struct Graph *graph, int vertex",,null,"
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

    // Add vertex to visited list and print it
    graph->visited[vertex] = 1;
    printf(""%d "", vertex);

    // Recursively call the dfs function on all unvisited neighbours
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}"
scc,struct Graph *graph,,null,"
void scc(struct Graph *graph)
{
    // Step I: Create a topological sort of the graph and store it in a stack
    struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
        // Execute topological sort on all elements
        if (graph->visited[i] == 0)
        {
            fillOrder(i, graph, stack);
        }
    }
    // Step 2: Get the transpose graph
    struct Graph *graphT = transpose(graph);
    // Step 3: Perform a simple dfs by popping nodes from stack
    while (stack->top != -1)
    {
        int v = pop(stack);
        if (graphT->visited[v] == 0)
        {
            dfs(graphT, v);
            printf(""\n"");
        }
    }
}"
createNode,int v,,newNode,"
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}"
createGraph,int vertices,,graph,"
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}"
addEdge,"struct Graph *graph, int src, int dest",,null,"
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}"
printGraph,struct Graph *graph,,null,"
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf(""\n Adjacency list of vertex %d\n "", v);
        while (temp)
        {
            printf(""%d -> "", temp->vertex);
            temp = temp->next;
        }
        printf(""\n"");
    }
}"
createStack,,,stack,"
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}"
push,"struct Stack *stack, int element",,null,"
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  // Increment then add, as we start from -1
}"
pop,struct Stack *stack,,INT_MIN | stack->arr[stack->top--],"
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}"
dropQueue,queue Q,,null,"
void dropQueue(queue Q)
{
    NodeT *curr = Q->head;
    while (curr != NULL)
    {
        NodeT *temp = curr->next;
        free(curr);
        curr = temp;
    }
    free(Q);
}"
QueueIsEmpty,queue Q,,(Q->length == 0),"
int QueueIsEmpty(queue Q) { return (Q->length == 0); }"
QueueEnqueue,"queue Q, int v",check whether queue is empty,null,"
void QueueEnqueue(queue Q, int v)
{
    NodeT *new = malloc(sizeof(NodeT));
    assert(new != NULL);
    new->data = v;
    new->next = NULL;
    if (Q->tail != NULL)
    {
        Q->tail->next = new;
        Q->tail = new;
    }
    else
    {
        Q->head = new;
        Q->tail = new;
    }
    Q->length++;
}"
QueueDequeue,queue Q,,d,"
int QueueDequeue(queue Q)
{
    assert(Q->length > 0);
    NodeT *p = Q->head;
    Q->head = Q->head->next;
    if (Q->head == NULL)
    {
        Q->tail = NULL;
    }
    Q->length--;
    int d = p->data;
    free(p);
    return d;
}"
main,,,0,"
int main(void)
{
    Edge e;
    int n;

    printf(""Enter the number of vertices: "");
    scanf(""%d"", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf(""Enter source node: "");
    scanf(""%d"", &src);
    printf(""Enter destination node: "");
    scanf(""%d"", &dest);

    printf(""Enter an edge (from): "");
    while (scanf(""%d"", &e.v) == 1)
    {
        printf(""Enter an edge (to): "");
        scanf(""%d"", &e.w);
        insertEdge(g, e);
        printf(""Enter an edge (from): "");
    }
    printf(""Finished.\n"");

    printf(""The graph has "");
    if (hasHamiltonianPath(g, n, src, dest))
        printf(""a"");
    else
        printf(""no"");
    printf("" Hamiltonian path from %d to %d.\n"", src, dest);

    freeGraph(g);
    return 0;
}"
main,,,0,"
int main(void)
{
    int V = 6;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 4;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 5;
    e.w = 4;
    insertEdge(g, e);
    e.v = 4;
    e.w = 2;
    insertEdge(g, e);
    e.v = 4;
    e.w = 3;
    insertEdge(g, e);
    e.v = 5;
    e.w = 3;
    insertEdge(g, e);
    e.v = 1;
    e.w = 2;
    insertEdge(g, e);
    e.v = 3;
    e.w = 2;
    insertEdge(g, e);

    int src = 0, dest = 5;
    if (findPathDFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf(""%d - "", v);
            v = visited[v];
        }
        printf(""%d\n"", src);
    }
    return 0;
}"
main,,,0,"
int main()
{
    int vertices, edges, source, i, src, dst;
    printf(""Enter the number of vertices\n"");
    scanf(""%d"", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf(""Enter the number of edges\n"");
    scanf(""%d"", &edges);
    for (i = 0; i < edges; i++)
    {
        printf(""Edge %d \nEnter source: "", i + 1);
        scanf(""%d"", &src);
        printf(""Enter destination: "");
        scanf(""%d"", &dst);
        addEdge(graph, src, dst);
    }
    printf(""Enter source of DFS\n"");
    scanf(""%d"", &source);
    printf(""DFS from %d is:\n"", source);
    dfs(graph, source);
    printf(""\n"");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);
    printf(""DFS from 0 is:\n"");
    dfs(graph,0);
    printf(""\n"");*/

    return 0;
}"
dfs,"struct Graph *graph, int vertex",,null,"
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

    // Add vertex to visited list and print it
    graph->visited[vertex] = 1;
    printf(""%d "", vertex);

    // Recursively call the dfs function on all unvisited neighbours
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}"
createNode,int v,,newNode,"
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}"
createGraph,int vertices,,graph,"
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));

    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}"
addEdge,"struct Graph *graph, int src, int dest",,null,"
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}"
printGraph,struct Graph *graph,,null,"
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf(""\n Adjacency list of vertex %d\n "", v);
        while (temp)
        {
            printf(""%d -> "", temp->vertex);
            temp = temp->next;
        }
        printf(""\n"");
    }
}"
warshall,,,null,"
void warshall()
{
    int i, s, t;
    for (s = 0; s < NODES; s++)
        for (t = 0; t < NODES; t++) tc[s][t] = digraph[s][t];

    for (i = 0; i < NODES; i++)
        for (s = 0; s < NODES; s++)
            for (t = 0; t < NODES; t++)
                if (tc[s][i] && tc[i][t])
                    tc[s][t] = 1;
}"
main,,,0,"
int main(void)
{
    warshall();
    int i, j;
    for (i = 0; i < NODES; i++)
    {
        for (j = 0; j < NODES; j++)
        {
            printf(""%d "", tc[i][j]);
        }
        putchar('\n');
    }
    return 0;
}"
main,,,0,"
int main(void)
{
    int V = 10;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 2;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 1;
    e.w = 5;
    insertEdge(g, e);
    e.v = 2;
    e.w = 3;
    insertEdge(g, e);
    e.v = 3;
    e.w = 4;
    insertEdge(g, e);
    e.v = 3;
    e.w = 5;
    insertEdge(g, e);
    e.v = 3;
    e.w = 8;
    insertEdge(g, e);
    e.v = 4;
    e.w = 5;
    insertEdge(g, e);
    e.v = 4;
    e.w = 7;
    insertEdge(g, e);
    e.v = 4;
    e.w = 8;
    insertEdge(g, e);
    e.v = 5;
    e.w = 6;
    insertEdge(g, e);
    e.v = 7;
    e.w = 8;
    insertEdge(g, e);
    e.v = 7;
    e.w = 9;
    insertEdge(g, e);
    e.v = 8;
    e.w = 9;
    insertEdge(g, e);

    int src = 0, dest = 6;
    if (findPathBFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf(""%d - "", v);
            v = visited[v];
        }
        printf(""%d\n"", src);
    }
    return 0;
}"
insertEdge,"Graph g, Edge e",check if vertex is valid in a graph,null,"
void insertEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (!g->edges[e.v][e.w])
    {  // edge e not in graph
        g->edges[e.v][e.w] = 1;
        g->edges[e.w][e.v] = 1;
        g->nE++;
    }
}"
removeEdge,"Graph g, Edge e",,null,"
void removeEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (g->edges[e.v][e.w])
    {  // edge e in graph
        g->edges[e.v][e.w] = 0;
        g->edges[e.w][e.v] = 0;
        g->nE--;
    }
}"
showGraph,Graph g,,null,"
void showGraph(Graph g)
{
    assert(g != NULL);
    int i, j;

    printf(""Number of vertices: %d\n"", g->nV);
    printf(""Number of edges: %d\n"", g->nE);
    for (i = 0; i < g->nV; i++)
        for (j = i + 1; j < g->nV; j++)
            if (g->edges[i][j])
                printf(""Edge %d - %d\n"", i, j);
}"
freeGraph,Graph g,,null,"
void freeGraph(Graph g)
{
    assert(g != NULL);

    int i;
    for (i = 0; i < g->nV; i++) free(g->edges[i]);
    free(g->edges);
    free(g);
}"
insertValueCArray,"CArray *array, int position, int value",,SUCCESS | POSITION_INIT | INVALID_POSITION,"
int insertValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] == 0)
        {
            array->array[position] = value;
            return SUCCESS;
        }
        else
            return POSITION_INIT;
    }
    return INVALID_POSITION;
}"
removeValueCArray,"CArray *array, int position",,POSITION_EMPTY | INVALID_POSITION,"
int removeValueCArray(CArray *array, int position)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
            array->array[position] = 0;
        }
        else
            return POSITION_EMPTY;
    }
    return INVALID_POSITION;
}"
pushValueCArray,"CArray *array, int value",,SUCCESS | ARRAY_FULL,"
int pushValueCArray(CArray *array, int value)
{
    int i;
    int ok = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == 0)
        {
            array->array[i] = value;
            ok = 1;
            break;
        }
    }
    if (ok == 1)
        return SUCCESS;
    else
        return ARRAY_FULL;
}"
updateValueCArray,"CArray *array, int position, int value",,SUCCESS | POSITION_NOT_INIT | INVALID_POSITION,"
int updateValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
            array->array[position] = value;
            return SUCCESS;
        }

        else
            return POSITION_NOT_INIT;
    }
    return INVALID_POSITION;
}"
eraseCArray,CArray *array,,0,"
int eraseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size; i++)
    {
        array->array[i] = 0;
    }
    return 0;
}"
switchValuesCArray,"CArray *array, int position1, int position2",,SUCCESS | INVALID_POSITION,"
int switchValuesCArray(CArray *array, int position1, int position2)
{
    if (position1 >= 0 && position1 < array->size && position2 >= 0 &&
        position2 < array->size)
    {
        int temp = array->array[position1];
        array->array[position1] = array->array[position2];
        array->array[position2] = temp;
        return SUCCESS;
    }
    return INVALID_POSITION;
}"
reverseCArray,CArray *array,,SUCCESS,"
int reverseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size / 2; i++)
    {
        swap(array, i, array->size - i - 1);
    }
    return SUCCESS;
}"
displayCArray,CArray *array,,0,"
int displayCArray(CArray *array)
{
    int i;
    printf(""\nC ARRAY\n"");
    for (i = 0; i < array->size; i++)
    {
        printf(""%d "", array->array[i]);
    }
    printf(""\n"");
    return 0;
}"
blenderCArray,CArray *array,,0,"
int blenderCArray(CArray *array)
{
    srand(time(NULL) * array->size);
    int i;
    int total = array->size * 100;
    for (i = 0; i < total; i++)
    {
        swap(array, rand() % array->size, rand() % array->size);
    }
    return 0;
}"
swap,"CArray *array, int position1, int position2",,null,"
void swap(CArray *array, int position1, int position2)
{
    int temp = array->array[position1];
    array->array[position1] = array->array[position2];
    array->array[position2] = temp;
}"
bubbleSortCArray,CArray *array,,0,"
int bubbleSortCArray(CArray *array)
{
    int i, j;
    for (i = 0; i < array->size - 1; i++)
    {
        for (j = 0; j < array->size - i - 1; j++)
        {
            if (array->array[j] > array->array[j + 1])
            {
                swap(array, j, j + 1);
            }
        }
    }
    return 0;
}"
selectionSortCArray,CArray *array,,0,"
int selectionSortCArray(CArray *array)
{
    int i, j, min;
    for (i = 0; i < array->size - 1; i++)
    {
        min = i;
        for (j = i + 1; j < array->size; j++)
            if (array->array[j] < array->array[min])
                min = j;
        swap(array, min, i);
    }
    return 0;
}"
insertionSortCArray,CArray *array,,0,"
int insertionSortCArray(CArray *array)
{
    int i, j, num;
    for (i = 1; i < array->size; i++)
    {
        num = array->array[i];
        j = i - 1;
        while (j >= 0 && array->array[j] > num)
        {
            array->array[j + 1] = array->array[j];
            j--;
        }
        array->array[j + 1] = num;
    }
    return 0;
}"
valueOcurranceCArray,"CArray *array, int value",,total,"
int valueOcurranceCArray(CArray *array, int value)
{
    int i, total = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == value)
            total++;
    }
    return total;
}"
findMinCArray,CArray *array,,min,"
int findMinCArray(CArray *array)
{
    int i;
    int min = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] < min)
        {
            min = array->array[i];
        }
    }
    return min;
}"
findMaxCArray,CArray *array,,max,"
int findMaxCArray(CArray *array)
{
    int i;
    int max = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] > max)
        {
            max = array->array[i];
        }
    }
    return max;
}"
CArrayTests,,,0,"
int CArrayTests()
{
    printf(""\n"");
    printf("" +-------------------------------------+\n"");
    printf("" |                                     |\n"");
    printf("" |               C Array               |\n"");
    printf("" |                                     |\n"");
    printf("" +-------------------------------------+\n"");
    printf(""\n"");

    CArray *array = getCArray(10);

    int i;
    for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    printf(""Entered array is:\n"");
    displayCArray(array);
    printf(""\nCode: %d\n"", pushValueCArray(array, 11));  // 5

    for (i = 0; i < array->size; i++)
    {
        removeValueCArray(array, i);
    }

    displayCArray(array);

    printf(""\nCode: %d"", removeValueCArray(array, -1));       // 1
    printf(""\nCode: %d\n"", insertValueCArray(array, -1, 1));  // 1

    // Erase
    for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    eraseCArray(array);
    displayCArray(array);  // Should give all 0s

    // Switching
    CArray *arr = getCArray(13);
    for (i = 0; i < arr->size; i++)
    {
        insertValueCArray(arr, i, i + 1);
    }
    displayCArray(arr);
    for (i = 0; i < arr->size / 2; i++)
    {
        switchValuesCArray(arr, i, arr->size - i - 1);
    }

    displayCArray(arr);

    // Or simply...
    reverseCArray(arr);

    displayCArray(arr);

    // Sorting
    srand(time(NULL));
    CArray *barray = getCArray(20);
    for (i = 0; i < barray->size; i++)
    {
        insertValueCArray(barray, i, rand());
    }
    CArray *carray = getCopyCArray(barray);
    CArray *darray = getCopyCArray(barray);
    printf(""\nNot sorted Array:"");
    displayCArray(barray);

    printf(""\nBubble Sort:"");
    clock_t begin1 = clock();
    // Timing bubble sort
    bubbleSortCArray(barray);
    clock_t end1 = clock();
    double time_spent1 = (double)(end1 - begin1) / CLOCKS_PER_SEC;
    displayCArray(barray);

    printf(""\nSelection Sort:"");
    clock_t begin2 = clock();
    // Timing selection sort
    selectionSortCArray(carray);
    clock_t end2 = clock();
    double time_spent2 = (double)(end2 - begin2) / CLOCKS_PER_SEC;
    displayCArray(carray);

    printf(""\nInsertion Sort:"");
    clock_t begin3 = clock();
    // Timing insertion sort
    insertionSortCArray(darray);
    clock_t end3 = clock();
    double time_spent3 = (double)(end3 - begin3) / CLOCKS_PER_SEC;
    displayCArray(carray);

    // Descending order
    reverseCArray(barray);
    // displayCArray(barray);

    //	printf(""\nBlender:"");
    //	blenderCArray(barray);
    //	displayCArray(barray);

    printf(""\nTotal time spent for bubble sort: %lf seconds"", time_spent1);
    printf(""\nTotal time spent for selection sort: %lf seconds"", time_spent2);
    printf(""\nTotal time spent for insertion sort: %lf seconds"", time_spent3);

    // Searching
    CArray *aarray = getCArray(1000);
    for (i = 0; i < aarray->size; i++)
    {
        insertValueCArray(aarray, i, rand() % 100);
    }

    int j = 24;
    printf(""\nOccurrences of the number %d in the array: %d"", j,
           valueOcurranceCArray(aarray, j));
    printf(""\nAnd its positions:\n"");
    CArray *positions = valuePositionsCArray(aarray, j);
    displayCArray(positions);
    // This should all give value of j
    printf(""\nAll %d s"", j);
    for (i = 0; i < positions->size; i++)
    {
        printf(""\nPosition %d has a value of %d"", positions->array[i],
               aarray->array[positions->array[i]]);
    }
    printf(""\nThe list has a minimum value of %d and a maximum value of %d"",
           findMinCArray(aarray), findMaxCArray(aarray));
    insertionSortCArray(aarray);
    // displayCArray(aarray);

    free(arr);
    free(array);
    free(aarray);
    free(barray);
    free(carray);
    free(darray);
    printf(""\n"");
    return 0;
}"
init_hash_set,,,set,"
extern hash_set_t *init_hash_set()
{
    hash_set_t *set = (hash_set_t *)malloc(sizeof(hash_set_t));
    set->keys = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->values = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->length = 0;
    set->capacity = DEFAULT_HASH_SET_CAPACITY;

    return set;
}"
add,"hash_set_t *set, void *value",,"put(set, hash(value), value)","
unsigned add(hash_set_t *set, void *value)
{
    return put(set, hash(value), value);
}"
put,"hash_set_t *set, long long hash, void *value",,"0 | put(set, hash, value) | 1","
unsigned put(hash_set_t *set, long long hash, void *value)
{
    if (contains_hash(set, hash))
    {
        if (set->keys[retrieve_index_from_hash(hash, set->capacity)] == value)
        {
            return 0;
        }

        // collision
        resize(set);

        return put(set, hash, value);
    }

    set->keys[retrieve_index_from_hash(hash, set->capacity)] = value;
    set->values[set->length++] = value;

    return 1;
}"
contains,"hash_set_t *set, void *value",,"set->keys[retrieve_index_from_hash(hash(value), set->capacity)] ==
                   value
               ? 1
               : 0","
int contains(hash_set_t *set, void *value)
{
    return set->keys[retrieve_index_from_hash(hash(value), set->capacity)] ==
                   value
               ? 1
               : 0;
}"
contains_hash,"hash_set_t *set, long long hash",,"set->keys[retrieve_index_from_hash(hash, set->capacity)] ? 1 : 0","
int contains_hash(hash_set_t *set, long long hash)
{
    return set->keys[retrieve_index_from_hash(hash, set->capacity)] ? 1 : 0;
}"
delete,"hash_set_t *set, void *value",,null,"
void delete (hash_set_t *set, void *value)
{
    set->keys[retrieve_index_from_hash(hash(value), set->capacity)] = NULL;
}"
retrieve_index_from_hash,"const long long hash, const unsigned capacity",,(capacity - 1) & (hash ^ (hash >> 12)),"
unsigned retrieve_index_from_hash(const long long hash, const unsigned capacity)
{
    return (capacity - 1) & (hash ^ (hash >> 12));
}"
resize,hash_set_t *set,,null,"
void resize(hash_set_t *set)
{
    void **keys_resized = calloc((set->capacity <<= 1), sizeof(void **));

    for (int i = 0; i < set->length; i++)
    {
        keys_resized[retrieve_index_from_hash(hash(set->values[i]),
                                              set->capacity)] = set->values[i];
    }

    free(set->keys);

    set->keys = keys_resized;

    void **new_values =
        (void **)realloc(set->values, set->capacity * sizeof(void **));
    set->values = new_values;
}"
main,,,0,"
int main()
{
    hash_set_t *set = init_hash_set();

    int v1 = 10, v2 = 20, v3 = 30, v4 = 40, v5 = 50, v6 = 60, v7 = 70;

    printf(""Value %d was add ? %d\n"", v1, add(set, &v1));
    printf(""Value %d was add ? %d\n"", v1, add(set, &v1));
    printf(""contains %d ? %d\n"", v1, contains(set, &v1));

    printf(""Value %d was add ? %d\n"", v2, add(set, &v2));
    printf(""Value %d was add ? %d\n"", v2, add(set, &v2));
    printf(""contains %d ? %d\n"", v2, contains(set, &v2));

    printf(""Value %d was add ? %d\n"", v3, add(set, &v3));
    printf(""Value %d is add ? %d\n"", v3, add(set, &v3));
    printf(""contains %d ? %d\n"", v3, contains(set, &v3));

    printf(""Value %d was add ? %d\n"", v4, add(set, &v4));
    printf(""Value %d was add ? %d\n"", v4, add(set, &v4));
    printf(""contains %d ? %d\n"", v4, contains(set, &v4));

    printf(""Value %d was add ? %d\n"", v5, add(set, &v5));
    printf(""Value %d was add ? %d\n"", v5, add(set, &v5));
    printf(""contains %d ? %d\n"", v5, contains(set, &v5));

    printf(""Value %d is add ? %d\n"", v6, add(set, &v6));
    printf(""Value %d is add ? %d\n"", v6, add(set, &v6));
    printf(""contains %d ? %d\n"", v6, contains(set, &v6));

    printf(""contains %d ? %d\n"", v7, contains(set, &v7));

    delete (set, &v6);

    printf(""contains %d ? %d\n"", v6, contains(set, &v6));

    return 0;
}"
init_dynamic_array,,,da,"
dynamic_array_t *init_dynamic_array()
{
    dynamic_array_t *da = malloc(sizeof(dynamic_array_t));
    da->items = calloc(DEFAULT_CAPACITY, sizeof(void *));
    da->capacity = DEFAULT_CAPACITY;

    return da;
}"
add,"dynamic_array_t *da, const void *value",,copy_value,"
void *add(dynamic_array_t *da, const void *value)
{
    if (da->size >= da->capacity)
    {
        void **newItems =
            realloc(da->items, (da->capacity <<= 1) * sizeof(void **));

        da->items = newItems;
    }

    void *copy_value = retrive_copy_of_value(value);
    da->items[da->size++] = copy_value;

    return copy_value;
}"
put,"dynamic_array_t *da, const void *value, const unsigned index",,INDEX_OUT_OF_BOUNDS | copy_value,"
void *put(dynamic_array_t *da, const void *value, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    free(da->items[index]);
    void *copy_value = retrive_copy_of_value(value);
    da->items[index] = copy_value;

    return copy_value;
}"
get,"dynamic_array_t *da, const unsigned index",,INDEX_OUT_OF_BOUNDS | da->items[index],"
void *get(dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    return da->items[index];
}"
delete,"dynamic_array_t *da, const unsigned index",,null,"
void delete (dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return;

    for (unsigned i = index; i < da->size; i++)
    {
        da->items[i] = da->items[i + 1];
    }

    da->size--;

    free(da->items[da->size]);
}"
contains,"const unsigned size, const unsigned index",,1 | 0,"
unsigned contains(const unsigned size, const unsigned index)
{
    if (size >= 0 && index < size)
        return 1;

    printf(""index [%d] out of bounds!\n"", index);
    return 0;
}"
retrive_copy_of_value,const void *value,,value_copy,"
void *retrive_copy_of_value(const void *value)
{
    void *value_copy = malloc(sizeof(void *));
    memcpy(value_copy, value, sizeof(void *));

    return value_copy;
}"
main,,,0,"
int main()
{
    dynamic_array_t *da = init_dynamic_array();

    for (int i = 1; i <= 50; i++)
    {
        add(da, &i);
    }

    delete (da, 10);

    int value = 1000;

    put(da, &value, 0);

    value = 5000;

    int another_value = 7000;

    add(da, &another_value);

    for (int i = 0; i < da->size; i++)
    {
        printf(""value %d\n"", *(int *)get(da, i));
    }

    int value_for_invalid_index = 10000;

    put(da, &value_for_invalid_index, 150);
    return 0;
}"
main,"int argc, char const *argv[]",,0,"
int main(int argc, char const *argv[])
{
    create();
    enque(5);

    return 0;
}"
create,,,null,"
void create()
{
    head = NULL;
    tail = NULL;
}"
enque,int x,,null,"void enque(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(sizeof(struct node));
        head->data = x;
        head->pre = NULL;
        tail = head;
    }
    else
    {
        tmp = (struct node *)malloc(sizeof(struct node));
        tmp->data = x;
        tmp->next = tail;
        tail = tmp;
    }
}"
deque,,,returnData,"int deque()
{
    int returnData = 0;
    if (head == NULL)
    {
        printf(""ERROR: Deque from empty queue.\n"");
        exit(1);
    }
    else
    {
        returnData = head->data;
        if (head->pre == NULL)
            head = NULL;
        else
            head = head->pre;
        head->next = NULL;
    }
    return returnData;
}"
size,,,count,int size() { return count; }
print_list,char **array,,null,"
void print_list(char **array)
{
    int i;
    for (i = 0; array[i]; i++) printf(""%s"", array[i]);
    printf(""\n"");
}"
main,,,0,"
int main()
{
    List_T list1, list2, list3;
    char **str1 = (char **)malloc(100 * sizeof(char *));

    list1 = List_init();
    list1 = List_push(list1, ""Dang "");
    list1 = List_push(list1, ""Hoang "");
    list1 = List_push(list1, ""Hai "");
    printf(""List 1: "");
    str1 = (char **)List_toArray(list1);
    print_list(str1);

    list2 = List_init();
    list2 = List_list(list2, ""Mentor "", ""Graphics "", ""Siemens"", NULL);
    printf(""List 2: "");
    print_list((char **)List_toArray(list2));

    list3 = List_append(list1, list2);
    printf(""Test append list2 into list1: "");
    print_list((char **)List_toArray(list3));

    return 0;
}"
List_length,L list,,n - 1,"int List_length(L list)
{
    int n;
    for (n = 0; list; list = list->next) n++;
    return n - 1;
}"
createqueue,,,null,void createqueue() { q.front = q.rear = NULL; }
empty,,"This function initializes the queue to empty by making both front and rear as
NULL",1 | 0,"
int empty()
{
    if (q.front == NULL)
        return 1;
    else
        return 0;
}"
insert,int x,,null,"
void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf(""Memory overflow. Unable to insert.\n"");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; /* New node is always last node */

    if (empty())
        q.front = q.rear = pnode;
    else
    {
        (q.rear)->next = pnode;
        q.rear = pnode;
    }
}"
removes,,,x,"
int removes()
{
    int x;
    struct node *p;

    if (empty())
    {
        printf(""Queue Underflow. Unable to remove.\n"");
        exit(1);
    }

    p = q.front;
    x = (q.front)->data;
    q.front = (q.front)->next;
    if (q.front == NULL) /* Queue contained only one node */
        q.rear = NULL;
    free(p);
    return x;
}"
show,,,null,"
void show()
{
    struct node *p;

    if (empty())
        printf(""Queue empty. No data to display \n"");
    else
    {
        printf(""Queue from front to rear is as shown: \n"");

        p = q.front;
        while (p != NULL)
        {
            printf(""%d "", p->data);
            p = p->next;
        }

        printf(""\n"");
    }
}"
destroyqueue,,,null,"
void destroyqueue() { q.front = q.rear = NULL; }"
main,,,0,"
int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf(""\n\n  Menu: \n"");
        printf(""1:Insert \n"");
        printf(""2:Remove \n"");
        printf(""3:exit \n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &ch);

        switch (ch)
        {
        case 1:
            printf(""Enter element to be inserted: "");
            scanf(""%d"", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf(""Element removed is: %d\n"", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}"
getsize,ListNode *head,,0 | size,"int getsize(ListNode *head)
{
    if (!head)
    {
        return 0;
    }
    int size = 1;
    ListNode *temp = head->next;
    while (temp != head)
    {
        temp = temp->next;
        size++;
    }
    return size;
}"
display_list,ListNode *head,,null,"void display_list(ListNode *head)
{
    printf(""\nContents of your linked list: "");
    ListNode *temp;
    temp = head;
    if (head != NULL)
    {
        while (temp->next != head)
        {
            printf(""%"" PRIu64 "" <-> "", temp->value);
            temp = temp->next;
        }
        if (temp->next == head)
        {
            printf(""%"" PRIu64, temp->value);
        }
    }
    else
    {
        printf(""The list is empty"");
    }
    printf(""\n"");
}"
get,"ListNode *list, const int index",,temp->value,"uint64_t get(ListNode *list, const int index)
{
    if (list == NULL || index < 0)
    {
        exit(EXIT_FAILURE);
    }
    ListNode *temp = list;
    for (int i = 0; i < index; ++i)
    {
        temp = temp->next;
    }
    return temp->value;
}"
test,,,null,"static void test()
{
    ListNode *testList = NULL;
    unsigned int array[] = {2, 3, 4, 5, 6};

    assert(getsize(testList) == 0);

    printf(""Testing inserting elements:\n"");
    for (int i = 0; i < 5; ++i)
    {
        display_list(testList);
        testList = insert_at_head(testList, array[i]);
        assert(testList->value == array[i]);
        assert(getsize(testList) == i + 1);
    }

    printf(""\nTesting removing elements:\n"");
    for (int i = 4; i > -1; --i)
    {
        display_list(testList);
        assert(testList->value == array[i]);
        testList = delete_from_head(testList);
        assert(getsize(testList) == i);
    }

    printf(""\nTesting inserting at tail:\n"");
    for (int i = 0; i < 5; ++i)
    {
        display_list(testList);
        testList = insert_at_tail(testList, array[i]);
        assert(get(testList, i) == array[i]);
        assert(getsize(testList) == i + 1);
    }

    printf(""\nTesting removing from tail:\n"");
    for (int i = 4; i > -1; --i)
    {
        display_list(testList);
        testList = delete_from_tail(testList);
        assert(getsize(testList) == i);
        // If list is not empty, assert that accessing the just removed element
        // will wrap around to the list head
        if (testList != NULL)
        {
            assert(get(testList, i) == testList->value);
        }
        else
        {
            // If the list is empty, assert that the elements were removed after
            // the correct number of iterations
            assert(i == 0);
        }
    }
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
main,,,0,"int main()
{
    // examples for better understanding
    example();
    // code here
    return 0;
}"
search,"List *list, double value",,0 | 1,"int search(List *list, double value)
{
    if (list == NULL)
        return 0;
    if (list->value == value)
        return 1;
    search(list->next, value);
}"
print,List *list,,null,"void print(List *list)
{
    if (list != NULL)
    {
        printf(""%f\t"", list->value);
        print(list->next);
    }
}"
example,,,null,"void example()
{
    List *my_list = NULL;
    double node_value = 0;
    int searching;

    my_list = create(node_value);
    my_list = insert(my_list, 3, 1);
    my_list = insert(my_list, 5, 3);
    my_list = insert(my_list, 10, 3);
    my_list = insert(my_list, 20, 3);

    print(my_list);
    searching = search(my_list, 20);
    printf(""\n%d\n"", searching);

    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);

    print(my_list);
    searching = search(my_list, 20);
    printf(""\n%d\n"", searching);
}"
printMiddle,struct Node *head,,null,"void printMiddle(struct Node *head)
{
    struct Node *slow_ptr = head;
    struct Node *fast_ptr = head;

    if (head != NULL)
    {
        while (fast_ptr != NULL && fast_ptr->next != NULL)
        {
            fast_ptr = fast_ptr->next->next;
            slow_ptr = slow_ptr->next;
        }
        printf(""The middle element is [%d]\n\n"", slow_ptr->data);
    }
}"
push,"struct Node **head_ref, int new_data",,null,"
void push(struct Node **head_ref, int new_data)
{
    /* allocate node */
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));

    /* put in the data */
    new_node->data = new_data;

    /* link the old list off the new node */
    new_node->next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref) = new_node;
}"
main,,,0,"int main()
{
    /* Start with the empty list */
    struct Node *head = NULL;
    int i;

    for (i = 5; i > 0; i--)
    {
        push(&head, i);
        printList(head);
        printMiddle(head);
    }

    return 0;
}"
createqueue,,,null,void createqueue() { front = rear = NULL; }
empty,,"This function initializes the queue to empty by making both front and rear as
NULL",1 | 0,"
int empty()
{
    if (front == NULL)
        return 1;
    else
        return 0;
}"
insert,int x,,null,"
void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf(""Memory overflow. Unable to insert.\n"");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; /* New node is always last node */

    if (empty())
        front = rear = pnode;
    else
    {
        rear->next = pnode;
        rear = pnode;
    }
}"
removes,,,min,"
int removes()
{
    int min;
    struct node *follow, *follow1, *p, *p1;

    if (empty())
    {
        printf(""\nQueue Underflow. Unable to remove."");
        exit(1);
    }

    /* finding the node with minimum value in the APQ.*/
    p = p1 = front;
    follow = follow1 = NULL;
    min = front->data;
    while (p != NULL)
    {
        if (p->data < min)
        {
            min = p->data;
            follow1 = follow;
            p1 = p;
        }
        follow = p;
        p = p->next;
    }

    /* Deleting the node with min value */

    if (p1 == front) /* deleting first node.*/
    {
        front = front->next;
        if (front == NULL) /* Deleting the only one node */
            rear = NULL;
    }
    else if (p1 == rear) /* Deleting last node */
    {
        rear = follow1;
        rear->next = NULL;
    }
    else /* deleting any other node.*/
        follow1->next = p1->next;

    free(p1);
    return min; /* DONT FORGET LAST 2 STATEMENTS.*/
}"
show,,DONT FORGET LAST 2 STATEMENTS.,null,"
void show()
{
    struct node *p;

    if (empty())
        printf(""Queue empty. No data to display \n"");
    else
    {
        printf(""Queue from front to rear is as shown: \n"");

        p = front;
        while (p != NULL)
        {
            printf(""%d "", p->data);
            p = p->next;
        }

        printf(""\n"");
    }
}"
destroyqueue,,,null,"
void destroyqueue() { front = rear = NULL; }"
main,,,0,"
int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf(""\n\n  Menu: \n"");
        printf(""1:Insert \n"");
        printf(""2:Remove \n"");
        printf(""3:exit \n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &ch);

        switch (ch)
        {
        case 1:
            printf(""Enter element to be inserted: "");
            scanf(""%d"", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf(""Element removed is: %d\n"", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}"
create,,,null,"void  create()
{
  int  i , n ;
  struct  node  *pnode , *p ;

  printf(""Enter the number of nodes required:\n"") ;
  scanf(""%d"",&n) ;

  printf(""Enter the data value of each node:\n"") ;
  for(i=1 ; i<=n ; i++)
  {
    pnode=(struct node*)malloc(sizeof(struct node)) ;
    if(pnode==NULL)
    {
      printf(""Memory overflow. Unable to create.\n"") ;
      return ;
    }

    scanf(""%d"",&pnode->data) ;

    if(first==NULL)
	 first=last=pnode ;
    else
    {
	  last->next=pnode ;
	  last=pnode ;    /* last keeps track of last node */
    }

    last->next=first ;
  }
}"
deletenode,int k,,null,"void  deletenode(int  k)
{
  struct  node  *p , *follow ;

  /* searching the required node */
  p=first ;
  follow=NULL ;
  while(follow!=last)
  {
    if(p->data==k)
	  break ;
    follow=p ;
    p=p->next ;
  }

  if(follow==last)
    printf(""Required node not found.\n"") ;
  else
  {
    if(p==first&&p==last)  /* deleting the one and the only node */
	  first=last=NULL ;
    else if(p==first)       /* deleting the first node */
    {
      first=first->next ;
      last->next=first ;
    }
    else if(p==last)      /* deleting the last node */
    {
      last=follow ;
      last->next=first ;
    }
    else		/* deleting any other node */
      follow->next=p->next ;

    free(p) ;
  }
}"
traverse,,,null,"void  traverse()
{
  struct  node  *p , *follow ;
  if(first==NULL)
    printf(""Circularly Linked List Empty"") ;
  else
  {
    printf(""Circularly Linked List is as shown: \n"") ;

    p=first ;
    follow = NULL ;
    while(follow!=last)
    {
      printf(""%d "" , p->data) ;
      follow=p ;
      p=p->next ;
    }

    printf(""\n"") ;
  }
}"
main,,,null,"
void main()
{
  int  x , k , ch ;
  clrscr() ;
  do
  {
    printf(""\n Menu: \n"") ;
    printf(""1:Create Linked List \n"") ;
    printf(""2:Delete Node \n"") ;
    printf(""3:Traverse \n"") ;
    printf(""4:Exit \n"") ;

    printf(""\nEnter your choice: "") ;
    scanf(""%d"",&ch) ;

    switch(ch)
    {
      case 1:
      create() ;
      break ;

      case 2:
      printf(""Enter the data value of the node to be deleted: "") ;
      scanf(""%d"",&k) ;
      deletenode(k) ;
      break ;

      case 3:
      traverse() ;
      break ;

      case 4:
      break ;
    }
 }
 while(ch!=4) ;

 getch() ;
}"
insert,"int pos, int d",,0,"
int insert(int pos, int d)
{
    struct node *new;
    new = createnode();
    new->info = d;
    if (pos == 1)
    {
        new->link = NULL;
        if (start == NULL)
        {
            start = new;
        }
        else
        {
            new->link = start;
            start = new;
        }
    }
    else
    {
        struct node *pre = start;
        for (int i = 2; i < pos; i++)
        {
             if (pre == NULL)
            {
                break;
            }
            pre = pre->link;
        }
        if(pre==NULL)
        {
            printf(""Position not found!"");
            return 0;
        }
        new->link = pre->link;
        pre->link = new;
    }
    return 0;
        }"
test,,,null,"
static void test()
{
    insert(1, 39);
    assert(start->info == 39);
    insert(2, 10);
    insert(3, 11);
    deletion(1);
    assert(start->info != 39);

    printf(""Self-tests successfully passed!\n"");
}"
main,,,0,"
int main()
{
    int n = 0, pos = 0, p = 0, num = 0, c = 0;
    printf(""\n1.self test mode"");
    printf(""\n2.interactive mode"");
    printf(""\nenter your choice:"");
    scanf(""%d"", &c);
    if (c == 1)
    {
        test();
    }
    else if (c == 2)
    {
        while (1)
        {
            printf(""\n1.add value at the given location"");
            printf(""\n2.delete value at the given location"");
            printf(""\n3.view list"");
            printf(""\nenter your choice :"");
            scanf(""%d"", &n);
            switch (n)
            {
            case 1:
                printf(""enter the position where the element is to be added :"");
                scanf(""%d"", &p);
                printf(""enter the element is to be added :"");
                scanf(""%d"", &num);
                insert(p, num);
                break;
            case 2:
                printf(""enter the position where the element is to be deleted :"");
                scanf(""%d"", &pos);
                deletion(pos);
                break;
            case 3:
                viewlist();
                break;
            default:
                printf(""\ninvalid choice"");
            }
        }
    }
    else
    {
        printf(""Invalid choice"");
    }
    return 0;
}"
main,,,0,"
int main()
{
    int x = 0, item;
    printf(""\t****stack using linked list****\n"");
    while (x != 4)
    {
        printf(""\n1. Push\n2. Pop\n3. Display\n4. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &x);
        switch (x)
        {
        case 1:
            push(top);
            break;
        case 2:
            pop(top);
            break;
        case 3:
            display(top);
            break;
        case 4:
            return 0;
        }
    }
}"
push,struct node *p,,null,"
void push(struct node *p)
{
    int item;
    struct node *temp;
    temp = (struct node *)malloc(sizeof(struct node));
    printf(""\nEnter element to be inserted: "");
    scanf(""%d"", &item);
    temp->info = item;

    temp->link = top;
    top = temp;

    printf(""Inserted successfully.\n"");
}"
pop,struct node *p,,null,"
void pop(struct node *p)
{
    int item;
    struct node *temp;

    if (top == NULL)
        printf(""\nStack is empty.\n"");
    else
    {
        item = top->info;
        temp = top;
        top = top->link;
        free(temp);
        printf(""\nElement popped is %d.\n"", item);
    }
}"
display,struct node *p,,null,"
void display(struct node *p)
{
    if (top == NULL)
        printf(""\nStack is empty.\n"");
    else
    {
        printf(""\nElements in the stack are:\n"");
        while (p != NULL)
        {
            printf(""\t%d\n"", p->info);
            p = p->link;
        }
        // printf(""%d\n"",p->info);
    }
}"
merge,,,null,"
void merge()
{
    struct node *temp1 = head1;
    struct node *temp2 = head2;

    struct node *holder1 = NULL;
    struct node *holder2 = NULL;
    // Temporary pointer variables to store the address of next node of the two
    // input linked list

    while (temp1 != NULL && temp2 != NULL)
    {
        holder1 = temp1->next;
        // Storing the address of next node of first linked list
        temp1->next = temp2;
        // Making the first node of first linked list point to first node of
        // second linked list

        if (holder1 != NULL)
        {
            // Making the first node of second linked list point to second node
            // of first linked list
            holder2 = temp2->next;
            temp2->next = holder1;
        }
        temp1 = holder1;
        temp2 = holder2;
        // Updating the address location of two pointer variables temp1 and
        // temp2
    }
}"
printlist,struct node *temp,temp2,null,"
void printlist(struct node *temp)
{
    printf(""%d"", temp->data);
    temp = temp->next;
    while (temp != NULL)
    {
        printf(""->%d"", temp->data);
        temp = temp->next;
    }
    printf(""\n"");
}"
main,,,0,"
int main()
{
    // Linked List 1: 1->3->5->7   :   Linked List 2: 2->4->6
    //  making lists
    struct node *one = (struct node *)malloc(sizeof(struct node));
    struct node *two = (struct node *)malloc(sizeof(struct node));
    struct node *three = (struct node *)malloc(sizeof(struct node));
    struct node *four = (struct node *)malloc(sizeof(struct node));
    struct node *five = (struct node *)malloc(sizeof(struct node));
    struct node *six = (struct node *)malloc(sizeof(struct node));
    struct node *seven = (struct node *)malloc(sizeof(struct node));
    // Seven nodes are created

    head1 = one;
    head2 = two;
    // head1 points to first node of first linked list
    // head2 points to first node of second linked list

    one->data = 1;
    one->next = three;

    two->data = 2;
    two->next = four;

    three->data = 3;
    three->next = five;

    four->data = 4;
    four->next = six;

    five->data = 5;
    five->next = seven;

    six->data = 6;
    six->next = NULL;
    // Last node of second input linked list

    seven->data = 7;
    seven->next = NULL;
    // Last node of first input linked list

    printf(""Linked List 1: "");
    printlist(head1);
    printf(""\nLinked List 2: "");
    printlist(head2);

    // Merging the two linked list into single linked list
    merge();

    printf(""\nMerged Linked List: "");
    printlist(head1);  // list one has been modified

    return 0;
}"
main,,,0,"int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf(""Pushing element : 10\n"");
    push(head, 3);
    printf(""Pushing element : 3\n"");
    push(head, 2);
    printf(""Pushing element : 2\n"");
    push(head, 8);
    printf(""Pushing element : 8\n"");
    printf(""Top element = %d \n"", top(head));
    push(head, 1);
    printf(""Pushing element : 1\n"");
    push(head, 7);
    printf(""Pushing element : 7\n"");
    printf(""Top element = %d \n"", top(head));
    pop(head);
    printf(""Popping an element.\n"");
    printf(""Top element = %d \n"", top(head));
    pop(head);
    printf(""Popping an element.\n"");
    printf(""Top element = %d \n"", top(head));
    printf(""\n"");
    return 0;
}"
down_heapify,"Heap *heap, int index",,null,"
void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int maximum = *((heap->p) + index);
    if (left < heap->count && maximum < *((heap->p) + left))
    {
        maximum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && maximum < *((heap->p) + right))
    {
        maximum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, right);
    }
}"
up_heapify,"Heap *heap, int index",,null,"
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) > *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}"
push,"Heap *heap, int x",,null,"
void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}"
pop,Heap *heap,,null,"
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}"
top,Heap *heap,,*(heap->p) | INT_MIN,"
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}"
empty,Heap *heap,,0 | 1,"
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}"
size,Heap *heap,,heap->count,"
int size(Heap *heap) { return heap->count; }"
main,,,0,"int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf(""Pushing element : 10\n"");
    push(head, 3);
    printf(""Pushing element : 3\n"");
    push(head, 2);
    printf(""Pushing element : 2\n"");
    push(head, 8);
    printf(""Pushing element : 8\n"");
    printf(""Top element = %d \n"", top(head));
    push(head, 1);
    printf(""Pushing element : 1\n"");
    push(head, 7);
    printf(""Pushing element : 7\n"");
    printf(""Top element = %d \n"", top(head));
    pop(head);
    printf(""Popping an element.\n"");
    printf(""Top element = %d \n"", top(head));
    pop(head);
    printf(""Popping an element.\n"");
    printf(""Top element = %d \n"", top(head));
    printf(""\n"");
    return 0;
}"
down_heapify,"Heap *heap, int index",,null,"
void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int minimum = *((heap->p) + index);
    if (left < heap->count && minimum > *((heap->p) + left))
    {
        minimum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && minimum > *((heap->p) + right))
    {
        minimum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, right);
    }
}"
up_heapify,"Heap *heap, int index",,null,"
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) < *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}"
push,"Heap *heap, int x",,null,"
void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}"
pop,Heap *heap,,null,"
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}"
top,Heap *heap,,*(heap->p) | INT_MIN,"
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}"
empty,Heap *heap,,0 | 1,"
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}"
size,Heap *heap,,heap->count,"
int size(Heap *heap) { return heap->count; }"
get_hash,char s[],,hash_code % MAXELEMENTS,"int get_hash(char s[])
{
    unsigned int hash_code = 0;

    /* iterates over string at each character */
    for (int counter = 0; s[counter] != '\0'; counter++)
    {
        /* actual computing of the hash code */
        hash_code =
            s[counter] + (hash_code << 6) + (hash_code << 16) - hash_code;
    }

    /* % modulo is for fitting the index in array. */
    return hash_code % MAXELEMENTS;
}"
add_item_label,"Dictionary *dic, char label[], void *item",% modulo is for fitting the index in array.,0 | -1,"
int add_item_label(Dictionary *dic, char label[], void *item)
{
    unsigned int index = get_hash(label);

    /* make sure index is fitting */
    if (index < MAXELEMENTS)
    {
        dic->elements[index] = item;
        return 0;
    }

    /* error case */
    return -1;
}"
add_item_index,"Dictionary *dic, int index, void *item",error case,0 | -1,"
int add_item_index(Dictionary *dic, int index, void *item)
{
    /* make sure whether this place is already given */
    if (!dic->elements[index])
    {
        dic->elements[index] = item;
        return 0;
    }

    /* error case */
    return -1;
}"
get_element_label,"Dictionary *dict, char s[]",error case,dict->elements[index] | NULL,"
void *get_element_label(Dictionary *dict, char s[])
{
    int index = get_hash(s);
    if (dict->elements[index])
    {
        return dict->elements[index];
    }

    printf(""None entry at given label\n"");
    return NULL;
}"
get_element_index,"Dictionary *dict, int index",,dict->elements[index] | NULL,"
void *get_element_index(Dictionary *dict, int index)
{
    if (index >= 0 && index < MAXELEMENTS)
    {
        return dict->elements[index];
    }

    printf(""index out of bounds!\n"");
    return NULL;
}"
destroy,Dictionary *dict,,null,"
void destroy(Dictionary *dict) { free(dict); }"
main,,,0,"
int main(void)
{
    Dictionary *testObj1;
    Dictionary *testObj2;

    int value = 28;

    testObj1 = create_dict();
    testObj2 = create_dict();

    add_item_label(testObj1, ""age"", &value);
    add_item_label(testObj2, ""name"", ""Christian"");

    /*
        test for function add_item_label

        attention:
        The void* pointer must be convert into an int* pointer.
        After that you can dereference it.
    */
    printf(""My age is %d\n"", *((int *)get_element_label(testObj1, ""age"")));
    printf(""My name is %s\n"", get_element_label(testObj2, ""name""));

    /* test for function add_item_index */
    if (!add_item_index(testObj1, 0, &value))
    {
        printf(""My age at index %d is %d\n"", 0,
               *((int *)get_element_index(testObj1, 0)));
    }

    /* error scenario */
    /* get_element_label(testObj,""none""); */

    /* tidy up */
    destroy(testObj1);
    destroy(testObj2);

    return 0;
}"
trie_new,struct trie ** trie,,-1 | 0,"int trie_new (
    struct trie ** trie
)
{
    *trie = calloc(1, sizeof(struct trie));
    if (NULL == *trie) {
        // memory allocation failed
        return -1;
    }
    return 0;
}"
trie_insert,"struct trie * trie, char *word, unsigned word_len",,"0 | -1 | trie_insert(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1
    ) | trie_search(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1,
        /* result = */ result
    )","int trie_insert (
    struct trie * trie,
    char *word,
    unsigned word_len
)
{
    int ret = 0;

    // this is the end of this word; add an end-of-word marker here and we're
    // done.
    if (0 == word_len) {
        trie->end_of_word = true;
        return 0;
    }

    // if you have some more complex mapping, you could introduce one here. In
    // this easy example, we just subtract 'a' (97) from it, meaning that 'a' is 0,
    // 'b' is 1, and so on.
    const unsigned int index = word[0] - 'a';

    // this index is outside the alphabet size; indexing this would mean an
    // out-of-bound memory access (bad!). If you introduce a separate map
    // function for indexing, then you could move the out-of-bounds index in
    // there.
    if (ALPHABET_SIZE <= index) {
        return -1;
    }

    // The index does not exist yet, allocate it.
    if (NULL == trie->children[index]) {
        ret = trie_new(&trie->children[index]);
        if (-1 == ret) {
            // creating new trie node failed
            return -1;
        }
    }
    
    // recurse into the child node
    return trie_insert(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1
    );
}


/*--Search a word in the Trie--*/
int trie_search(
    struct trie * trie,
    char *word,
    unsigned word_len,
    struct trie ** result
)
{
    // we found a match
    if (0 == word_len) {
        *result = trie;
        return 0;
    }

    // same here as in trie_insert, if you have a separate index mapping, add
    // it here. In this example, we just subtract 'a'.
    const unsigned int index = word[0] - 'a';

    // This word contains letters outside the alphabet length; it's invalid.
    // Remember to do this to prevent buffer overflows.
    if (ALPHABET_SIZE <= index) {
        return -1;
    }

    // No match
    if (NULL == trie->children[index]) {
        return -1;
    }

    // traverse the trie
    return trie_search(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1,
        /* result = */ result
    );
}"
trie_search,"struct trie * trie, char *word, unsigned word_len, struct trie ** result",recurse into the child node,"0 | -1 | trie_search(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1,
        /* result = */ result
    )","int trie_search(
    struct trie * trie,
    char *word,
    unsigned word_len,
    struct trie ** result
)
{
    // we found a match
    if (0 == word_len) {
        *result = trie;
        return 0;
    }

    // same here as in trie_insert, if you have a separate index mapping, add
    // it here. In this example, we just subtract 'a'.
    const unsigned int index = word[0] - 'a';

    // This word contains letters outside the alphabet length; it's invalid.
    // Remember to do this to prevent buffer overflows.
    if (ALPHABET_SIZE <= index) {
        return -1;
    }

    // No match
    if (NULL == trie->children[index]) {
        return -1;
    }

    // traverse the trie
    return trie_search(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1,
        /* result = */ result
    );
}

/*---Return all the related words------*/
void trie_print (
    struct trie * trie,
    char prefix[],
    unsigned prefix_len
)
{

    // An end-of-word marker means that this is a complete word, print it.
    if (true == trie->end_of_word) {
        printf(""%.*s\n"", prefix_len, prefix);
    }

    // However, there can be longer words with the same prefix; traverse into
    // those as well.
    for (int i = 0; i < ALPHABET_SIZE; i++) {

        // No words on this character
        if (NULL == trie->children[i]) {
            continue;
        }

        // If you have a separate index mapping, then you'd need the inverse of
        // the map here. Since we subtracted 'a' for the index, we can just add
        // 'a' to get the inverse map function.
        prefix[prefix_len] = i + 'a';

        // traverse the print into the child
        trie_print(trie->children[i], prefix, prefix_len + 1);
    }"
trie_print,"struct trie * trie, char prefix[], unsigned prefix_len",traverse the trie,null,"void trie_print (
    struct trie * trie,
    char prefix[],
    unsigned prefix_len
)
{

    // An end-of-word marker means that this is a complete word, print it.
    if (true == trie->end_of_word) {
        printf(""%.*s\n"", prefix_len, prefix);
    }

    // However, there can be longer words with the same prefix; traverse into
    // those as well.
    for (int i = 0; i < ALPHABET_SIZE; i++) {

        // No words on this character
        if (NULL == trie->children[i]) {
            continue;
        }

        // If you have a separate index mapping, then you'd need the inverse of
        // the map here. Since we subtracted 'a' for the index, we can just add
        // 'a' to get the inverse map function.
        prefix[prefix_len] = i + 'a';

        // traverse the print into the child
        trie_print(trie->children[i], prefix, prefix_len + 1);
    }
}


/*------Demonstrate purposes uses text file called dictionary -------*/

int main() {
    int ret = 0;
    struct trie * root = NULL;
    struct trie * trie = NULL;
    char word[100] = {0};

    // Create a root trie
    ret = trie_new(&root);
    if (-1 == ret) {
        fprintf(stderr, ""Could not create trie\n"");
        exit(1);
    }

    // open the dictionary file
    FILE *fp = fopen(""dictionary.txt"", ""r"");
    if (NULL == fp) {
        fprintf(stderr, ""Error while opening dictionary file"");
        exit(1);
    }

    // insert all the words from the dictionary
    while (1 == fscanf(fp, ""%100s\n"", word)) {
        ret = trie_insert(root, word, strnlen(word, 100));
        if (-1 == ret) {
            fprintf(stderr, ""Could not insert word into trie\n"");
            exit(1);
        }
    }

    while (1) {
        printf(""Enter keyword: "");
        if (1 != scanf(""%100s"", word)) {
            break;
        }

        printf(
            ""\n==========================================================\n"");
        printf(""\n********************* Possible Words ********************\n"");

        ret = trie_search(root, word, strnlen(word, 100), &trie);
        if (-1 == ret) {
            printf(""No results\n"");
            continue;
        }

        trie_print(trie, word, strnlen(word, 100));

        printf(""\n==========================================================\n"");
    }
}"
main,,,,"int main() {
    int ret = 0;
    struct trie * root = NULL;
    struct trie * trie = NULL;
    char word[100] = {0};

    // Create a root trie
    ret = trie_new(&root);
    if (-1 == ret) {
        fprintf(stderr, ""Could not create trie\n"");
        exit(1);
    }

    // open the dictionary file
    FILE *fp = fopen(""dictionary.txt"", ""r"");
    if (NULL == fp) {
        fprintf(stderr, ""Error while opening dictionary file"");
        exit(1);
    }

    // insert all the words from the dictionary
    while (1 == fscanf(fp, ""%100s\n"", word)) {
        ret = trie_insert(root, word, strnlen(word, 100));
        if (-1 == ret) {
            fprintf(stderr, ""Could not insert word into trie\n"");
            exit(1);
        }
    }

    while (1) {
        printf(""Enter keyword: "");
        if (1 != scanf(""%100s"", word)) {
            break;
        }

        printf(
            ""\n==========================================================\n"");
        printf(""\n********************* Possible Words ********************\n"");

        ret = trie_search(root, word, strnlen(word, 100), &trie);
        if (-1 == ret) {
            printf(""No results\n"");
            continue;
        }

        trie_print(trie, word, strnlen(word, 100));

        printf(""\n==========================================================\n"");
    }
}"
max,"int a, int b",,(a > b) ? a : b,"
int max(int a, int b) { return (a > b) ? a : b; }"
nodeHeight,avlNode *node,,-1 | (node->height),"
int nodeHeight(avlNode *node)
{
    if (node == NULL)
        return -1;
    else
        return (node->height);
}"
heightDiff,avlNode *node,,0 | (nodeHeight(node->left) - nodeHeight(node->right)),"
int heightDiff(avlNode *node)
{
    if (node == NULL)
        return 0;
    else
        return (nodeHeight(node->left) - nodeHeight(node->right));
}"
printAVL,"avlNode *node, int level",,null,"
void printAVL(avlNode *node, int level)
{
    int i;
    if (node != NULL)
    {
        printAVL(node->right, level + 1);
        printf(""\n\n"");

        for (i = 0; i < level; i++) printf(""\t"");

        printf(""%d"", node->key);

        printAVL(node->left, level + 1);
    }
}"
printPreOrder,avlNode *node,,null,"
void printPreOrder(avlNode *node)
{
    if (node == NULL)
        return;

    printf(""  %d  "", (node->key));
    printPreOrder(node->left);
    printPreOrder(node->right);
}"
printInOrder,avlNode *node,,null,"
void printInOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printInOrder(node->left);
    printf(""  %d  "", (node->key));
    printInOrder(node->right);
}"
printPostOrder,avlNode *node,,null,"
void printPostOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printPostOrder(node->left);
    printPostOrder(node->right);
    printf(""  %d  "", (node->key));
}"
main,,,0,"
int main()
{
    int choice;
    int flag = 1;
    int insertNum;
    int queryNum;

    avlNode *root = NULL;
    avlNode *tempNode;

    while (flag == 1)
    {
        printf(""\n\nEnter the Step to Run : \n"");

        printf(""\t1: Insert a node into AVL tree\n"");
        printf(""\t2: Delete a node in AVL tree\n"");
        printf(""\t3: Search a node into AVL tree\n"");
        printf(""\t4: printPreOrder (Ro L R) Tree\n"");
        printf(""\t5: printInOrder (L Ro R) Tree\n"");
        printf(""\t6: printPostOrder (L R Ro) Tree\n"");
        printf(""\t7: printAVL Tree\n"");

        printf(""\t0: EXIT\n"");
        scanf(""%d"", &choice);

        switch (choice)
        {
        case 0:
        {
            flag = 0;
            printf(""\n\t\tExiting, Thank You !!\n"");
            break;
        }

        case 1:
        {
            printf(""\n\tEnter the Number to insert: "");
            scanf(""%d"", &insertNum);

            tempNode = findNode(root, insertNum);

            if (tempNode != NULL)
                printf(""\n\t %d Already exists in the tree\n"", insertNum);
            else
            {
                printf(""\n\tPrinting AVL Tree\n"");
                printAVL(root, 1);
                printf(""\n"");

                root = insert(root, insertNum);
                printf(""\n\tPrinting AVL Tree\n"");
                printAVL(root, 1);
                printf(""\n"");
            }

            break;
        }

        case 2:
        {
            printf(""\n\tEnter the Number to Delete: "");
            scanf(""%d"", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf(""\n\t %d Does not exist in the tree\n"", queryNum);
            else
            {
                printf(""\n\tPrinting AVL Tree\n"");
                printAVL(root, 1);
                printf(""\n"");
                root = delete (root, queryNum);

                printf(""\n\tPrinting AVL Tree\n"");
                printAVL(root, 1);
                printf(""\n"");
            }

            break;
        }

        case 3:
        {
            printf(""\n\tEnter the Number to Search: "");
            scanf(""%d"", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf(""\n\t %d : Not Found\n"", queryNum);
            else
            {
                printf(""\n\t %d : Found at height %d \n"", queryNum,
                       tempNode->height);

                printf(""\n\tPrinting AVL Tree\n"");
                printAVL(root, 1);
                printf(""\n"");
            }

            break;
        }

        case 4:
        {
            printf(""\nPrinting Tree preOrder\n"");
            printPreOrder(root);

            break;
        }

        case 5:
        {
            printf(""\nPrinting Tree inOrder\n"");
            printInOrder(root);

            break;
        }

        case 6:
        {
            printf(""\nPrinting Tree PostOrder\n"");
            printPostOrder(root);

            break;
        }

        case 7:
        {
            printf(""\nPrinting AVL Tree\n"");
            printAVL(root, 1);

            break;
        }

        default:
        {
            flag = 0;
            printf(""\n\t\tExiting, Thank You !!\n"");
            break;
        }
        }
    }

    return 0;
}"
endProgramAbruptly,char *errorMessage,,null,"void endProgramAbruptly(char *errorMessage)
{
    fprintf(stderr, ""%s\n"", errorMessage);
    exit(EXIT_FAILURE);
}"
freeTreeMemory,struct Node *node,,null,"void freeTreeMemory(struct Node *node)
{
    if (node != NULL)
    {
        freeTreeMemory(node->left);
        freeTreeMemory(node->right);
        free(node->word);  // freeing node->word because memory was allocated
                           // using malloc
        free(node);  // freeing node because memory was allocated using malloc
    }
}"
getPointerToWord,char *word,,string | NULL,"char *getPointerToWord(char *word)
{
    char *string =
        (char *)malloc((strlen(word) + 1) * sizeof(char));  ///< pointer to string
    // + 1 is for the '\0' character
    if (string != NULL)
    {
        strcpy(string, word);
        return string;
    }
    endProgramAbruptly(
        ""\nA problem occurred while reserving memory for the word\n"");
    return NULL;
}"
closeFile,FILE *file,,null,"void closeFile(FILE *file)
{
    if (fclose(file)) {
        endProgramAbruptly(""\nA Problem Occurred while closing a file\n"");
     }
}"
allocateMemoryForNode,,,node | NULL,"struct Node *allocateMemoryForNode()
{
    struct Node *node =
        (struct Node *)malloc(sizeof(struct Node));  ///< pointer to the node
    if (node != NULL)
    {
        return node;
    }
    endProgramAbruptly(
        ""\nA problem occurred while reserving memory for the structure\n"");
    return NULL;
}"
writeContentOfTreeToFile,"struct Node *node, FILE *file",,null,"void writeContentOfTreeToFile(struct Node *node, FILE *file)
{
    static uint64_t i = 1;  ///< for word numbering in the write file
    if (node != NULL)       // checks if the node is valid
    {
        writeContentOfTreeToFile(
            node->left,
            file);  // calls `writeContentOfTreeToFile` for left sub tree
        fprintf(file, ""%-5lu \t %-9lu \t %s \n"", i++, node->frequency,
                node->word);  // prints the word number, word frequency and word
                              // in tabular format to the file
        writeContentOfTreeToFile(
            node->right,
            file);  // calls `writeContentOfTreeToFile` for right sub tree
    }
}"
addWordToTree,"char *word, struct Node *currentNode",,currentNode,"struct Node *addWordToTree(char *word, struct Node *currentNode)
{
    if (currentNode == NULL)  // checks if `currentNode` is `NULL`
    {
        struct Node *currentNode =
            allocateMemoryForNode();  // allocates memory for new node
        currentNode->word = getPointerToWord(word);  // stores `word` in memory
        currentNode->frequency = 1;  // initializes the word frequency to 1
        currentNode->left = NULL;    // sets left node to `NULL`
        currentNode->right = NULL;   // sets right node to `NULL`
        return currentNode;          // returns pointer to newly created node
    }

    int64_t compared = strcmp(word, currentNode->word);  ///< holds compare state

    if (compared > 0) {
        currentNode->right = addWordToTree(word,
            currentNode->right);  // adds `word` to right sub tree if `word` is
                                  // alphabetically greater than `currentNode->word`
    }
    else if (compared < 0) {
        currentNode->left = addWordToTree(word,
            currentNode->left);  // adds `word` to left sub tree if `word` is
                                 // alphabetically less than `currentNode->word`
    }
    else {
        currentNode->frequency++; // increments `currentNode` frequency if `word` is the same as `currentNode->word`
    }

    return currentNode; // returns pointer to current node
}"
readWordsInFileToTree,"FILE *file, struct Node *root",,,"struct Node *readWordsInFileToTree(FILE *file, struct Node *root)
{
    // longest english word = 45 chars
    // +1 for '\0' = 46 chars
    char *inputString =
        (char *)malloc(46 * sizeof(char));  ///< pointer to the input string

    char inputChar;                ///< temp storage of characters
    bool isPrevCharAlpha = false;  ///< bool to mark the end of a word
    uint8_t pos = 0;  ///< position in inputString to place the inputChar

    while ((inputChar = fgetc(file)) != EOF)
    {
        if (pos > 0)
            isPrevCharAlpha = isalpha(inputString[pos - 1]);

        // checks if character is letter
        if (isalpha(inputChar))
        {
            inputString[pos++] = tolower(inputChar);
            continue;
        }

        // checks if character is ' or - and if it is preceded by a letter eg
        // yours-not, persons' (valid)
        if ((inputChar == '\'' || inputChar == '-') && isPrevCharAlpha)
        {
            inputString[pos++] = inputChar;
            continue;
        }

        // makes sure that there is something valid in inputString
        if (pos == 0)
            continue;

        // if last character is not letter and is not ' then replace by \0
        if (!isPrevCharAlpha && inputString[pos - 1] != '\'')
            pos--;
        inputString[pos] = '\0';
        pos = 0;
        isPrevCharAlpha = false;
        root = addWordToTree(inputString, root);
    }

    // this is to catch the case for the EOF being immediately after the last
    // letter or '
    if (pos > 0)
    {
        if (!isPrevCharAlpha && inputString[pos - 1] != '\'')
            pos--;
        inputString[pos] = '\0';
        root = addWordToTree(inputString, root);
    }"
test,,,null,"static void test()
{
    struct Node *root = NULL;  ///< pointer to the root node
    FILE *file = NULL;         ///< pointer to the file

    file = fopen(""file.txt"", ""w"");  // creates test file in write mode

    fprintf(file,
            ""hey_this, is a. test input \n to a_file"");  // writes test data to
                                                         // test file

    closeFile(file);                // closes test file
    file = fopen(""file.txt"", ""r"");  // reopens test file in read mode

    root = readWordsInFileToTree(file,
                                 root);  // reads words from test file to tree

    // Tests to check if words were added to correct position in tree and also
    // if their frequencies were added correctly
    assert(strcmp(root->word, ""hey"") == 0);
    assert(root->frequency == 1);
    assert(strcmp(root->left->word, ""a"") == 0);
    assert(root->left->frequency == 2);
    assert(strcmp(root->right->word, ""this"") == 0);
    assert(strcmp(root->left->right->word, ""file"") == 0);
    assert(strcmp(root->right->left->word, ""is"") == 0);

    closeFile(file);     // closes test file
    remove(""file.txt"");  // deletes test file from storage

    file = fopen(""wordcount.txt"", ""a"");  // creates write file
    fprintf(file, ""%-5s \t %9s \t %s \n"", ""S/N"", ""FREQUENCY"",
            ""WORD"");  // prints the heading to `wordcount.txt`
    writeContentOfTreeToFile(
        root, file);  // writes content of tree to file (`wordcount.txt`)

    // Here is how the output to `wordcount.txt` should look like
    char *correctString =
        ""S/N   	 FREQUENCY 	 WORD \n""
        ""1     	 2         	 a \n""
        ""2     	 1         	 file \n""
        ""3     	 1         	 hey \n""
        ""4     	 1         	 input \n""
        ""5     	 1         	 is \n""
        ""6     	 1         	 n \n""
        ""7     	 1         	 test \n""
        ""8     	 1         	 this \n""
        ""9     	 1         	 to \n"";

    int16_t inputChar;  // holds the current character in `wordcount.txt`
    uint64_t i = 0;     // holds the current index in `correctString`

    // Checks if the content in `wordcount.txt` is as expected (the same as in
    // `correctString`)
    while ((inputChar = fgetc(file)) != EOF) {
        assert(inputChar == correctString[i++]);
    }

    closeFile(file);          // closes `wordcount.txt`
    remove(""wordcount.txt"");  // deletes `wordcount.txt`

    freeTreeMemory(root);  // frees memory taken up by the tree
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
insert_bt,"node **root, int data",,null,"void insert_bt(node **root, int data)
{
    node *new_node = create_node(data);
    node *temp;  // to be deleted
    node *prev;  // keeps track of the parent of the element deleted
    if (*root == NULL)
    {
        *root = new_node;
    }
    else
    {
        temp = *root;
        prev = NULL;
        while (temp != NULL)
        {
            if (new_node->data > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else if (new_node->data < temp->data)
            {
                prev = temp;
                temp = temp->llink;
            }
            else
            {
                return;
            }
        }

        if (new_node->data > prev->data)
        {
            prev->rlink = new_node;
        }
        else
        {
            prev->llink = new_node;
        }
    }
}"
search,"node *root, int ele",,null,"void search(node *root, int ele)
{
    node *temp = root;
    while (temp != NULL)
    {
        if (temp->data == ele)
        {
            break;
        }
        else if (ele > temp->data)
        {
            temp = temp->rlink;
        }
        else
        {
            temp = temp->llink;
        }
    }

    if (temp == NULL)
    {
        printf(""%s\n"", ""Element not found."");
    }
    else
        printf(""%s\n"", ""Element found."");
}"
inorder_display,node *curr,,null,"void inorder_display(node *curr)
{
    if (curr != NULL)
    {
        inorder_display(curr->llink);
        printf(""%d\t"", curr->data);
        inorder_display(curr->rlink);
    }
}"
postorder_display,node *curr,,null,"void postorder_display(node *curr)
{
    if (curr != NULL)
    {
        postorder_display(curr->llink);
        postorder_display(curr->rlink);
        printf(""%d\t"", curr->data);
    }
}"
preorder_display,node *curr,,null,"void preorder_display(node *curr)
{
    if (curr != NULL)
    {
        printf(""%d\t"", curr->data);
        preorder_display(curr->llink);
        preorder_display(curr->rlink);
    }
}"
delete_bt,"node **root, int ele",,0,"void delete_bt(node **root, int ele)
{
    node *temp;
    node *prev;
    if (*root == NULL)
        return;
    else
    {
        temp = *root;
        prev = NULL;
        // search
        while (temp != NULL)
        {
            if (temp->data == ele)
            {
                break;
            }
            else if (ele > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else
            {
                prev = temp;
                temp = temp->llink;
            }
        }
    }

    if (temp == NULL)
        return;
    else
    {
        node *replacement;  // deleted node's replacement
        node *t;
        if (temp->llink == NULL && temp->rlink == NULL)
        {
            replacement = NULL;
        }
        else if (temp->llink == NULL && temp->rlink != NULL)
        {
            replacement = temp->rlink;
        }
        else if (temp->llink != NULL && temp->rlink == NULL)
        {
            replacement = temp->llink;
        }
        else
        {
            replacement = temp->rlink;  // replaced with inorder successor
            t = replacement;
            while (t->llink != NULL)
            {
                t = t->llink;
            }
            t->llink =
                temp->llink;  // leftmost node of the replacement is linked to
                              // the left child of the deleted node
        }

        if (temp == *root)
        {
            free(*root);
            *root = replacement;
        }
        else if (prev->llink == temp)
        {
            free(prev->llink);
            prev->llink = replacement;
        }
        else if (prev->rlink == temp)
        {
            free(prev->rlink);
            prev->rlink = replacement;
        }
    }
}

/**
 * main function
 */
int main()
{
    printf(""BINARY THREADED TREE: \n"");
    node *root = NULL;
    int choice, n;
    do
    {
        printf(""%s\n"", ""1. Insert into BT"");
        printf(""%s\n"", ""2. Print BT - inorder"");
        printf(""%s\n"", ""3. Print BT - preorder"");
        printf(""%s\n"", ""4. print BT - postorder"");
        printf(""%s\n"", ""5. delete from BT"");
        printf(""%s\n"", ""6. search in BT"");
        printf(""%s\n"", ""Type 0 to exit"");
        scanf(""%d"", &choice);

        switch (choice)
        {
        case 1:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            insert_bt(&root, n);
            break;
        case 2:
            inorder_display(root);
            printf(""\n"");
            break;
        case 3:
            preorder_display(root);
            printf(""\n"");
            break;
        case 4:
            postorder_display(root);
            printf(""\n"");
            break;
        case 5:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            delete_bt(&root, n);
            break;
        case 6:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            search(root, n);
            break;
        }
    } while (choice != 0);
    return 0;
}"
main,,,0,"int main()
{
    printf(""BINARY THREADED TREE: \n"");
    node *root = NULL;
    int choice, n;
    do
    {
        printf(""%s\n"", ""1. Insert into BT"");
        printf(""%s\n"", ""2. Print BT - inorder"");
        printf(""%s\n"", ""3. Print BT - preorder"");
        printf(""%s\n"", ""4. print BT - postorder"");
        printf(""%s\n"", ""5. delete from BT"");
        printf(""%s\n"", ""6. search in BT"");
        printf(""%s\n"", ""Type 0 to exit"");
        scanf(""%d"", &choice);

        switch (choice)
        {
        case 1:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            insert_bt(&root, n);
            break;
        case 2:
            inorder_display(root);
            printf(""\n"");
            break;
        case 3:
            preorder_display(root);
            printf(""\n"");
            break;
        case 4:
            postorder_display(root);
            printf(""\n"");
            break;
        case 5:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            delete_bt(&root, n);
            break;
        case 6:
            printf(""%s\n"", ""Enter a no:"");
            scanf(""%d"", &n);
            search(root, n);
            break;
        }
    } while (choice != 0);
    return 0;
}"
newNode,int data,,node,"
struct node *newNode(int data)
{
    struct node *node = (struct node *)malloc(sizeof(struct node));

    node->leftNode = NULL;
    node->data = data;
    node->rightNode = NULL;

    return node;
}"
main,,,0,"
int main(void)
{
    /* new node can be created here as :-

       struct node *nameOfNode = newNode(data);

       and tree can be formed by creating further nodes at
       nameOfNode->leftNode and so on.
    */

    return 0;
}"
find,"node *root, int data",,"0 | find(root->right, data)","int find(node *root, int data)
{
    // If the root is null, the key's not present
    if (root == NULL)
    {
        return 0;
    }
    else if (data > root->data)
    {
        // If the input key is greater than the root's, search in the right
        // subtree
        return find(root->right, data);
    }"
height,node *root,,0 | (right_h + 1) | (left_h + 1),"int height(node *root)
{
    // If the root is null, this is the bottom of the tree (height 0)
    if (root == NULL)
    {
        return 0;
    }
    else
    {
        // Get the height from both left and right subtrees to check which is
        // the greatest
        int right_h = height(root->right);
        int left_h = height(root->left);

        // The final height is the height of the greatest subtree(left or right)
        // plus 1(which is the root's level)
        if (right_h > left_h)
        {
            return (right_h + 1);
        }
        else
        {
            return (left_h + 1);
        }
    }
}

/** Utilitary procedure to free all nodes in a tree
 * @param root pointer to parent node
 */
void purge(node *root)
{
    if (root != NULL)
    {
        if (root->left != NULL)
        {
            purge(root->left);
        }
        if (root->right != NULL)
        {
            purge(root->right);
        }
        free(root);
        root = NULL;  // reset pointer
    }
}

/** Traversal procedure to list the current keys in the tree in order of value
 * (from the left to the right)
 * @param root pointer to parent node
 */
void inOrder(node *root)
{
    if (root != NULL)
    {
        inOrder(root->left);
        printf(""\t[ %d ]\t"", root->data);
        inOrder(root->right);
    }
}

/** Main funcion */
int main()
{
    // this reference don't change.
    // only the tree changes.
    node *root = NULL;
    int opt = -1;
    int data = 0;

    // event-loop.
    while (opt != 0)
    {
        printf(
            ""\n\n[1] Insert Node\n[2] Delete Node\n[3] Find a Node\n[4] Get ""
            ""current Height\n[5] Print Tree in Crescent Order\n[0] Quit\n"");
        scanf(""%d"", &opt);  // reads the choice of the user

        // processes the choice
        switch (opt)
        {
        case 1:
            printf(""Enter the new node's value:\n"");
            scanf(""%d"", &data);
            root = insert(root, data);
            break;

        case 2:
            printf(""Enter the value to be removed:\n"");
            if (root != NULL)
            {
                scanf(""%d"", &data);
                root = delete (root, data);
            }
            else
            {
                printf(""Tree is already empty!\n"");
            }
            break;

        case 3:
            printf(""Enter the searched value:\n"");
            scanf(""%d"", &data);
            find(root, data) ? printf(""The value is in the tree.\n"")
                             : printf(""The value is not in the tree.\n"");
            break;

        case 4:
            printf(""Current height of the tree is: %d\n"", height(root));
            break;

        case 5:
            inOrder(root);
            break;
        }
    }

    // deletes the tree from the heap.
    purge(root);

    return 0;
}"
purge,node *root,,null,"void purge(node *root)
{
    if (root != NULL)
    {
        if (root->left != NULL)
        {
            purge(root->left);
        }
        if (root->right != NULL)
        {
            purge(root->right);
        }
        free(root);
        root = NULL;  // reset pointer
    }
}"
inOrder,node *root,,null,"void inOrder(node *root)
{
    if (root != NULL)
    {
        inOrder(root->left);
        printf(""\t[ %d ]\t"", root->data);
        inOrder(root->right);
    }
}"
main,,,0,"int main()
{
    // this reference don't change.
    // only the tree changes.
    node *root = NULL;
    int opt = -1;
    int data = 0;

    // event-loop.
    while (opt != 0)
    {
        printf(
            ""\n\n[1] Insert Node\n[2] Delete Node\n[3] Find a Node\n[4] Get ""
            ""current Height\n[5] Print Tree in Crescent Order\n[0] Quit\n"");
        scanf(""%d"", &opt);  // reads the choice of the user

        // processes the choice
        switch (opt)
        {
        case 1:
            printf(""Enter the new node's value:\n"");
            scanf(""%d"", &data);
            root = insert(root, data);
            break;

        case 2:
            printf(""Enter the value to be removed:\n"");
            if (root != NULL)
            {
                scanf(""%d"", &data);
                root = delete (root, data);
            }
            else
            {
                printf(""Tree is already empty!\n"");
            }
            break;

        case 3:
            printf(""Enter the searched value:\n"");
            scanf(""%d"", &data);
            find(root, data) ? printf(""The value is in the tree.\n"")
                             : printf(""The value is not in the tree.\n"");
            break;

        case 4:
            printf(""Current height of the tree is: %d\n"", height(root));
            break;

        case 5:
            inOrder(root);
            break;
        }
    }

    // deletes the tree from the heap.
    purge(root);

    return 0;
}"
segment_tree_build,segment_tree *tree,,null,"void segment_tree_build(segment_tree *tree)
{
    size_t elem_size = tree->elem_size;
    int index = (tree->length - 2);
    size_t b, l, r;
    char *ptr = (char *)tree->root;
    for (; index >= 0; index--)
    {
        b = index * elem_size;
        l = (2 * index + 1) * elem_size;
        r = (2 * index + 2) * elem_size;
        tree->combine(ptr + l, ptr + r, ptr + b);
    }
}"
segment_tree_update,"segment_tree *tree, size_t index, void *val",,null,"void segment_tree_update(segment_tree *tree, size_t index, void *val)
{
    size_t elem_size = tree->elem_size;
    index = index + tree->length - 1;
    char *base = (char *)tree->root;
    char *t = base + index * elem_size;
    memcpy(t, val, elem_size);
    while (index > 0)
    {
        index = ((index - 1) >> 1);
        tree->combine(base + (2 * index + 1) * elem_size,
                      base + (2 * index + 2) * elem_size,
                      base + index * elem_size);
    }
}"
segment_tree_query,"segment_tree *tree, long long l, long long r, void *res",,null,"void segment_tree_query(segment_tree *tree, long long l, long long r, void *res)
{
    size_t elem_size = tree->elem_size;
    memcpy(res, tree->identity, elem_size);
    elem_size = tree->elem_size;
    char *root = (char *)tree->root;
    l += tree->length - 1;
    r += tree->length - 1;
    while (l <= r)
    {
        if (!(l & 1))
        {
            tree->combine(res, root + l * elem_size, res);
        }
        if (r & 1)
        {
            tree->combine(res, root + r * elem_size, res);
        }
        r = (r >> 1) - 1;
        l = (l >> 1);
    }
}"
segment_tree_dispose,segment_tree *tree,,null,"void segment_tree_dispose(segment_tree *tree)
{
    free(tree->root);
    free(tree->identity);
}"
segment_tree_print_int,segment_tree *tree,,null,"void segment_tree_print_int(segment_tree *tree)
{
    char *base = (char *)tree->root;
    size_t i = 0;
    for (; i < 2 * tree->length - 1; i++)
    {
        printf(""%d "", *(int *)(base + i * tree->elem_size));
    }
    printf(""\n"");
}"
minimum,"const void *a, const void *b, void *c",,null,"void minimum(const void *a, const void *b, void *c)
{
    *(int *)c = *(int *)a < *(int *)b ? *(int *)a : *(int *)b;
}"
test,,,null,"static void test()
{
    int32_t arr[10] = {1, 0, 3, 5, 7, 2, 11, 6, -2, 8};
    int32_t identity = __INT32_MAX__;
    segment_tree *tree =
        segment_tree_init(arr, sizeof(*arr), 10, &identity, minimum);
    segment_tree_build(tree);
    int32_t result;
    segment_tree_query(tree, 3, 6, &result);
    assert(result == 2);
    segment_tree_query(tree, 8, 9, &result);
    assert(result == -2);
    result = 12;
    segment_tree_update(tree, 5, &result);
    segment_tree_update(tree, 8, &result);
    segment_tree_query(tree, 0, 3, &result);
    assert(result == 0);
    segment_tree_query(tree, 8, 9, &result);
    assert(result == 8);
    segment_tree_dispose(tree);
}"
main,,,0,"int main()
{
    test();
    return 0;
}"
isLeaf,Node *n,,1 | 0,"
int isLeaf(Node *n)
{
    if (n->left == NULL && n->right == NULL)
    {
        return 1;
    }
    return 0;
}"
checkNode,Node *node,,null,"
void checkNode(Node *node)
{
    // If the node is the root
    if (node == NULL || node->par == NULL)
    {
        return;
    }
    Node *child = node;
    // If it is a black node or its parent is a black node
    if (node->color == 0 || (node->par)->color == 0)
    {
        // Dont Do Anything
        return;
    }

    // Both parent and child are red
    // Check For Uncle
    Node *parent = node->par;
    Node *grandParent = parent->par;

    // If grandParent is NULL, then parent is the root.
    // Just make the root black.
    if (grandParent == NULL)
    {
        parent->color = 0;
        return;
    }

    // If both the children of the grandParent are red
    if (grandParent->right != NULL && (grandParent->right)->color == 1 &&
        grandParent->left != NULL && (grandParent->left)->color == 1)
    {
        // Make the grandParent red and both of its children black
        (grandParent->right)->color = 0;
        (grandParent->left)->color = 0;
        grandParent->color = 1;
        return;
    }
    else
    {
        // The only option left is rotation.
        Node *greatGrandParent = grandParent->par;
        // Right Case
        if (grandParent->right == parent)
        {
            // Right Right Case
            if (parent->right == node)
            {
                grandParent->right = parent->left;
                if (parent->left != NULL)
                {
                    (parent->left)->par = grandParent;
                }
                parent->left = grandParent;
                grandParent->par = parent;

                // Attach to existing Tree;
                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                // Change the colors
                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {  // Right Left Case
                // First step -> Parent Child Rotation
                parent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = parent;
                }
                child->right = parent;
                parent->par = child;

                // Second step -> Child and GrandParent Rotation
                grandParent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = grandParent;
                }
                child->left = grandParent;
                grandParent->par = child;

                // Attach to the existing tree
                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                // Change The Colors
                child->color = 0;
                grandParent->color = 1;
            }
        }
        else
        {  // Left Case
            // Left Left Case
            if (parent->left == node)
            {
                grandParent->left = parent->right;
                if (parent->right != NULL)
                {
                    (parent->right)->par = grandParent;
                }
                parent->right = grandParent;
                grandParent->par = parent;

                // Attach to existing Tree;
                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                // Change the colors
                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {  // Left Right Case

                // First step -> Parent Child Rotation
                parent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = parent;
                }
                child->left = parent;
                parent->par = child;

                // Second step -> Child and GrandParent Rotation
                grandParent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = grandParent;
                }
                child->right = grandParent;
                grandParent->par = child;

                // Attach to the existing tree
                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                // Change The Colors
                child->color = 0;
                grandParent->color = 1;
            }
        }
    }
}"
insertNode,"int val, Node **root",,null,"
void insertNode(int val, Node **root)
{
    Node *buffRoot = *root;
    while (buffRoot)
    {
        if (buffRoot->val > val)
        {
            // Go left
            if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                // Insert The Node
                Node *toInsert = newNode(val, buffRoot);
                buffRoot->left = toInsert;
                buffRoot = toInsert;

                // Check For Double Red Problems
                break;
            }
        }
        else
        {
            // Go right
            if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                // Insert The Node
                Node *toInsert = newNode(val, buffRoot);
                buffRoot->right = toInsert;
                buffRoot = toInsert;

                // Check For Double Red Problems
                break;
            }
        }
    }

    while (buffRoot != *root)
    {
        checkNode(buffRoot);
        if (buffRoot->par == NULL)
        {
            *root = buffRoot;
            break;
        }
        buffRoot = buffRoot->par;
        if (buffRoot == *root)
        {
            buffRoot->color = 0;
        }
    }
}"
checkForCase2,"Node *toDelete, int delete, int fromDirection, Node **root",,null,"
void checkForCase2(Node *toDelete, int delete, int fromDirection, Node **root)
{
    if (toDelete == (*root))
    {
        (*root)->color = 0;
        return;
    }

    if (!delete &&toDelete->color == 1)
    {
        if (!fromDirection)
        {
            if (toDelete->right != NULL)
            {
                toDelete->right->color = 1;
            }
        }
        else
        {
            if (toDelete->left != NULL)
            {
                toDelete->left->color = 1;
            }
        }
        toDelete->color = 0;
        return;
    }

    // Get the sibling for further inspection
    Node *sibling;
    Node *parent = toDelete->par;
    int locateChild = 0;  // 0 if toDeleted is left of its parent else 1
    if (parent->right == toDelete)
    {
        sibling = parent->left;
        locateChild = 1;
    }
    else
    {
        sibling = parent->right;
    }

    // Case 2.1. i.e. if the any children of the sibling is red
    if ((sibling->right != NULL && sibling->right->color == 1) ||
        (sibling->left != NULL && sibling->left->color == 1))
    {
        if (sibling->right != NULL && sibling->right->color == 1)
        {
            // Sibling is left and child is right. i.e. LEFT RIGHT ROTATION
            if (locateChild == 1)
            {
                int parColor = parent->color;

                // Step 1: Left rotate sibling
                sibling = leftRotate(sibling->right);

                // Step 2: Right rotate updated sibling
                parent = rightRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Step 3: Update the colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->right->right)
                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
            else
            {  // Sibling is right and child is also right. i.e. LEFT LEFT
               // ROTATION

                int parColor = parent->color;

                // Left Rotate the sibling
                parent = leftRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Update Colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->left->left)
                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->left;
                    free(toDelete);
                }
            }
        }
        else
        {
            // Sibling is right and child is left. i.e. RIGHT LEFT ROTATION
            if (locateChild == 0)
            {
                int parColor = parent->color;

                // Step 1: Right rotate sibling
                sibling = rightRotate(sibling->left);

                // printf(""%d - reached\n"", sibling->val);
                // return;

                // Step 2: Left rotate updated sibling
                parent = leftRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Step 3: Update the colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->left->left)
                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->right;
                    free(toDelete);
                }
            }
            else
            {  // Sibling is left and child is also left. i.e. RIGHT RIGHT
               // ROTATION

                int parColor = parent->color;

                // Right Rotate the sibling
                parent = rightRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Update Colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->right->right)
                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
        }
    }
    else if (sibling->color == 0)
    {  // Make the sibling red and recur for its parent

        // Recolor the sibling
        sibling->color = 1;

        // Delete if necessary
        if (delete)
        {
            if (locateChild)
            {
                toDelete->par->right = toDelete->left;
                if (toDelete->left != NULL)
                {
                    toDelete->left->par = toDelete->par;
                }
            }
            else
            {
                toDelete->par->left = toDelete->right;
                if (toDelete->right != NULL)
                {
                    toDelete->right->par = toDelete->par;
                }
            }
        }

        checkForCase2(parent, 0, locateChild, root);
    }
    else
    {  // Bring the sibling on top and apply 2.1 or 2.2 accordingly
        if (locateChild)
        {  // Right Rotate

            toDelete->par->right = toDelete->left;
            if (toDelete->left != NULL)
            {
                toDelete->left->par = toDelete->par;
            }

            parent = rightRotate(sibling);

            // Check if the root is rotated
            if (parent->par == NULL)
            {
                *root = parent;
            }

            parent->color = 0;
            parent->right->color = 1;
            checkForCase2(parent->right, 0, 1, root);
        }
        else
        {  // Left Rotate

            toDelete->par->left = toDelete->right;
            if (toDelete->right != NULL)
            {
                toDelete->right->par = toDelete->par;
            }
            parent = leftRotate(sibling);

            // Check if the root is rotated
            if (parent->par == NULL)
            {
                *root = parent;
            }

            printf(""\nroot - %d - %d\n"", parent->val, parent->left->val);

            parent->color = 0;
            parent->left->color = 1;
            checkForCase2(parent->left, 0, 0, root);
        }
    }
}"
deleteNode,"int val, Node **root",,null,"
void deleteNode(int val, Node **root)
{
    Node *buffRoot = *root;

    // Search for the element in the tree
    while (1)
    {
        if (val == buffRoot->val)
        {
            // Node Found
            break;
        }

        if (val > buffRoot->val)
        {
            if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                printf(""Node Not Found!!!"");
                return;
            }
        }
        else
        {
            if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                printf(""Node Not Found!!!"");
                return;
            }
        }
    }

    Node *toDelete = buffRoot;

    // Look for the leftmost of right node or right most of left node
    if (toDelete->left != NULL)
    {
        toDelete = toDelete->left;
        while (toDelete->right != NULL)
        {
            toDelete = toDelete->right;
        }
    }
    else if (toDelete->right != NULL)
    {
        toDelete = toDelete->right;
        while (toDelete->left != NULL)
        {
            toDelete = toDelete->left;
        }
    }

    if (toDelete == *root)
    {
        *root = NULL;
        return;
    }

    // Swap the values
    buffRoot->val = toDelete->val;
    toDelete->val = val;

    // Checking for case 1
    if (toDelete->color == 1 ||
        (toDelete->left != NULL && toDelete->left->color == 1) ||
        (toDelete->right != NULL && toDelete->right->color == 1))
    {
        // if it is a leaf
        if (toDelete->left == NULL && toDelete->right == NULL)
        {
            // Delete instantly
            if (toDelete->par->left == toDelete)
            {
                toDelete->par->left = NULL;
            }
            else
            {
                toDelete->par->right = NULL;
            }
        }
        else
        {  // else its child should be red

            // Check for the exitstence of left node
            if (toDelete->left != NULL)
            {
                // The node should be right to its parent
                toDelete->par->right = toDelete->left;
                toDelete->left->par = toDelete->par;
                toDelete->left->color = 1;
            }
            else
            {  // else the right node should be red
                toDelete->par->left = toDelete->right;
                toDelete->right->par = toDelete->par;
                toDelete->right->color = 1;
            }
        }

        // Remove the node from memory
        free(toDelete);
    }
    else
    {  // Case 2
        checkForCase2(toDelete, 1, ((toDelete->par->right == toDelete)), root);
    }
}"
printInorder,Node *root,,null,"
void printInorder(Node *root)
{
    if (root != NULL)
    {
        printInorder(root->left);
        printf(""%d c-%d "", root->val, root->color);
        printInorder(root->right);
    }
}"
checkBlack,"Node *temp, int c",,null,"
void checkBlack(Node *temp, int c)
{
    if (temp == NULL)
    {
        printf(""%d "", c);
        return;
    }
    if (temp->color == 0)
    {
        c++;
    }
    checkBlack(temp->left, c);
    checkBlack(temp->right, c);
}"
main,,,,"
int main()
{
    Node *root = NULL;
    int scanValue, choice = 1;
    printf(
        ""1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - Quit\n\nPlease ""
        ""Enter the Choice - "");
    scanf(""%d"", &choice);
    while (choice)
    {
        switch (choice)
        {
        case 1:
            printf(""\n\nPlease Enter A Value to insert - "");
            scanf(""%d"", &scanValue);
            if (root == NULL)
            {
                root = newNode(scanValue, NULL);
                root->color = 0;
            }
            else
            {
                insertNode(scanValue, &root);
            }
            printf(""\nSuccessfully Inserted %d in the tree\n\n"", scanValue);
            break;
        case 2:
            printf(""\n\nPlease Enter A Value to Delete - "");
            scanf(""%d"", &scanValue);
            deleteNode(scanValue, &root);
            printf(""\nSuccessfully Inserted %d in the tree\n\n"", scanValue);
            break;
        case 3:
            printf(""\nInorder Traversel - "");
            printInorder(root);
            printf(""\n\n"");
            // checkBlack(root,0);
            // printf(""\n"");
            break;
        default:
            if (root != NULL)
            {
                printf(""Root - %d\n"", root->val);
            }
        }
        printf(
            ""1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - ""
            ""Quit\n\nPlease Enter the Choice - "");
        scanf(""%d"", &choice);
    }
}"
inOrderTraversal,struct node *node,,null,"
void inOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    inOrderTraversal(node->leftNode);
    printf(""\t%d\t"", node->data);
    inOrderTraversal(node->rightNode);
}"
preOrderTraversal,struct node *node,,null,"
void preOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    printf(""\t%d\t"", node->data);
    preOrderTraversal(node->leftNode);
    preOrderTraversal(node->rightNode);
}"
postOrderTraversal,struct node *node,,null,"
void postOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    postOrderTraversal(node->leftNode);
    postOrderTraversal(node->rightNode);
    printf(""\t%d\t"", node->data);
}"
main,,,0,"
int main(void)
{
    /* traversals can be done by simply invoking the
       function with a pointer to the root node.
    */

    return 0;
}"
cleanup,,,null,void cleanup() { WSACleanup(); }
main,,,0,"int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror(""WSA Startup error: \n"");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = ""Hello from client"";
    struct sockaddr_in servaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror(""socket creation failed"");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    servaddr.sin_addr.s_addr = INADDR_ANY;

    int n;
    unsigned int len;

    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&servaddr, sizeof(servaddr));
    printf(""Hello message sent.\n"");

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&servaddr, &len);
    buffer[n] = '\0';
    printf(""Server : %s\n"", buffer);

    close(sockfd);
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char recvbuff[1024],
        sendbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t ClientLen;  /// size of address

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf(""Server is running...\n"");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }
    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf(""Server is listening...\n"");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf(""Server is connected...\n"");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the parent to send data
     *
     * The parent process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the child to receive data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;

    #ifdef _WIN32
    #ifdef FORK_WINDOWS
    pid = fork();
    #endif
    #else
    pid = fork();
    #endif

    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(conn, recvbuff, sizeof(recvbuff), 0);
            printf(""\nCLIENT : %s\n"", recvbuff);
            sleep(5);
            // break;
        }
    }
    else  /// Parent process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf(""\nType message here: "");
            fgets(sendbuff, 1024, stdin);
            send(conn, sendbuff, strlen(sendbuff) + 1, 0);
            printf(""\nMessage Sent!\n"");
            sleep(5);
            // break;
        }
    }

    /// Close socket
    close(sockfd);
    printf(""Server is offline...\n"");
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char recv_msg[1024],
        success_message[] =
            ""Command Executed Successfully!\n"";  ///< character arrays to read
                                                 /// and store string data
                                                 /// for communication & Success
                                                 /// message

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t clientLength = sizeof(client_addr);  /// size of address

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    printf(""Server is Connected Successfully...\n"");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The server receives data from the client which is a command. It then
     * executes the command.
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        bzero(recv_msg, sizeof(recv_msg));
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&client_addr, &clientLength);
        printf(""Command Output: \n"");
        system(recv_msg);
        printf(""Command Executed\n"");
        sendto(sockfd, success_message, sizeof(success_message), 0,
               (struct sockaddr *)&client_addr, clientLength);
    }

    /// Close socket
    close(sockfd);
    printf(""Server is offline...\n"");
    return 0;
}"
cleanup,,,null,void cleanup() { WSACleanup(); }
main,,,0,"int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror(""WSA Startup error: \n"");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = ""Hello from server"";
    struct sockaddr_in servaddr, cliaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror(""socket creation failed"");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;  // IPv4
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

    // Bind the socket with the server address
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    unsigned int len;
    int n;
    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&cliaddr, &len);
    buffer[n] = '\0';
    printf(""Client : %s\n"", buffer);
    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&cliaddr, len);
    printf(""Hello message sent.\n"");

    close(sockfd);

    return 0;
}"
cleanup,,,null,void cleanup() { WSACleanup(); }
func,int sockfd,,null,"void func(int sockfd)
{
    char buff[MAX];
    int n;
    // infinite loop for chat
    for (;;)
    {
        bzero(buff, MAX);

        // read the message from client and copy it in buffer
        read(sockfd, buff, sizeof(buff));
        // print buffer which contains the client contents
        printf(""From client: %s\t To client : "", buff);
        bzero(buff, MAX);
        n = 0;
        // copy server message in the buffer
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }

        // and send that buffer to client
        write(sockfd, buff, sizeof(buff));

        // if msg contains ""Exit"" then server exit and chat ended.
        if (strncmp(""exit"", buff, 4) == 0)
        {
            printf(""Server Exit...\n"");
            break;
        }
    }
}"
main,,,0,"int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror(""WSA Startup error: \n"");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    unsigned int len;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        perror(""socket creation failed...\n"");
        exit(0);
    }
    else
    {
        printf(""Socket successfully created..\n"");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(PORT);

    // Binding newly created socket to given IP and verification
    if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)
    {
        perror(""socket bind failed...\n"");
        exit(0);
    }
    else
    {
        printf(""Socket successfully binded..\n"");
    }

    // Now server is ready to listen and verification
    if ((listen(sockfd, 5)) != 0)
    {
        perror(""Listen failed...\n"");
        exit(0);
    }
    else
    {
        printf(""Server listening..\n"");
    }
    len = sizeof(cli);

    // Accept the data packet from client and verification
    connfd = accept(sockfd, (SA *)&cli, &len);
    if (connfd < 0)
    {
        perror(""server acccept failed...\n"");
        exit(0);
    }
    else
    {
        printf(""server acccept the client...\n"");
    }

    // Function for chatting between client and server
    func(connfd);

    // After chatting close the socket
    close(sockfd);
    return 0;
}"
func,int sockfd,,null,"void func(int sockfd)
{
    char buff[MAX];
    int n;
    for (;;)
    {
        bzero(buff, sizeof(buff));
        printf(""Enter the string : "");
        n = 0;
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }
        write(sockfd, buff, sizeof(buff));
        bzero(buff, sizeof(buff));
        read(sockfd, buff, sizeof(buff));
        printf(""From Server : %s"", buff);
        if ((strncmp(buff, ""exit"", 4)) == 0)
        {
            printf(""Client Exit...\n"");
            break;
        }
    }
}"
cleanup,,,null,void cleanup() { WSACleanup(); }
main,,,0,"int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror(""WSA Startup error: \n"");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        printf(""socket creation failed...\n"");
        exit(0);
    }
    else
    {
        printf(""Socket successfully created..\n"");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    servaddr.sin_port = htons(PORT);

    // connect the client socket to server socket
    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)
    {
        printf(""connection with the server failed...\n"");
        exit(0);
    }
    else
    {
        printf(""connected to the server..\n"");
    }

    // function for chat
    func(sockfd);

    // close the socket
    close(sockfd);
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char send_msg[1024],
        recv_msg[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t serverLength = sizeof(server_addr);  ///< length of socket

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf(""Client is running...\n"");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf(""Client is Connected Successfully...\n"");

    /**
     * Communication between client and server
     *
     * The client sends data to the server after taking the input
     * from the user
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        printf(""\nEnter Command To Be Executed Remotely: \n"");
        fgets(send_msg, sizeof(send_msg), stdin);
        sendto(sockfd, send_msg, sizeof(send_msg), 0,
               (struct sockaddr *)&server_addr, serverLength);
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&server_addr, &serverLength);
        printf(""Server Reply: %s\n"", recv_msg);
    }

    /// Close Socket
    close(sockfd);
    printf(""Client is offline...\n"");
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char server_msg[10000],
        client_msg[10000];  ///< character arrays to read and store string data
                            /// for communication
    struct sockaddr_in server_addr,
        client_addr;  ///< asic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;    /// Domain/Family to be used
    server_addr.sin_port = htons(PORT);  /// Port to be used
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf(""Server is running...\n"");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf(""Server is listening...\n"");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf(""Server is connected...\n"");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the SERVER is prompted to type a message which is read from
     * stdin and then sent over the connection that was established - the socket
     * - to be received by the client (send())
     *
     * The SERVER then waits for the client to reply. It then receives the reply
     * in the string variable and displays it (recv())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&server_msg, sizeof(server_msg));
        bzero(&client_msg, sizeof(client_msg));

        /// Send message
        printf(""\nEnter message here: "");
        fgets(server_msg, 10000, stdin);
        send(conn, server_msg, strlen(server_msg) + 1, 0);

        /// Receive Message
        recv(conn, client_msg, sizeof(client_msg), 0);
        printf(""\nClient Message: %s\n"", client_msg);
    }

    /// Close socket
    close(sockfd);
    printf(""Server is offline...\n"");
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    char serverResponse[10000],
        clientResponse[10000];  ///< Character arrays to read and store string
                                /// data for communication

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf(""Client is running...\n"");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf(""Client is connected...\n"");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the CLIENT receives the servers message and displays it (recv())
     *
     * The CLIENT is then prompted to type in a message and send it to the
     * server. (send())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&serverResponse, sizeof(serverResponse));
        bzero(&clientResponse, sizeof(clientResponse));

        /// Receive Message
        recv(sockfd, serverResponse, sizeof(serverResponse), 0);
        printf(""\nServer message: %s \n"", serverResponse);

        /// Send Message
        printf(""\nEnter message here: "");
        fgets(clientResponse, 10000, stdin);
        send(sockfd, clientResponse, strlen(clientResponse) + 1, 0);
    }

    /// Close Socket
    close(sockfd);
    printf(""Client is offline...\n"");
    return 0;
}"
error,,,null,"void error()
{
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
}"
main,,,0,"int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char sendbuff[1024],
        recvbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf(""Client is running...\n"");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf(""Client is connected...\n"");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the parent to receive data
     *
     * The parent process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the child to send data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;
    pid = fork();

    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf(""\nType message here: "");
            fgets(sendbuff, 1024, stdin);
            send(sockfd, sendbuff, strlen(sendbuff) + 1, 0);
            printf(""\nMessage sent!\n"");
            sleep(5);
            // break;
        }
    }
    else  /// Parent Process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(sockfd, recvbuff, sizeof(recvbuff), 0);
            printf(""\nSERVER: %s\n"", recvbuff);
            sleep(5);
            // break;
        }
    }

    /// Close Socket
    close(sockfd);
    printf(""Client is offline...\n"");
    return 0;
}"
display,"int *arr, int n",,null,"
void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }

    printf(""\n"");
}"
swap,"int *first, int *second",,null,"
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}"
cycleSort,"int *arr, int n",,null,"
void cycleSort(int *arr, int n)
{
    // count number of memory writes
    int writes = 0;

    // traverse array elements and put it to on
    // the right place
    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)
    {
        // initialize item as starting point
        int item = arr[cycle_start];

        // Find position where we put the item. We basically
        // count all smaller elements on right side of item.
        int pos = cycle_start;
        for (int i = cycle_start + 1; i < n; i++)
            if (arr[i] < item)
                pos++;

        // If item is already in correct position
        if (pos == cycle_start)
            continue;

        // ignore all duplicate elements
        while (item == arr[pos]) pos += 1;

        // put the item to it's right position
        if (pos != cycle_start)
        {
            swap(&item, &arr[pos]);
            writes++;
        }

        // Rotate rest of the cycle
        while (pos != cycle_start)
        {
            pos = cycle_start;

            // Find position where we put the element
            for (int i = cycle_start + 1; i < n; i++)
                if (arr[i] < item)
                    pos += 1;

            // ignore all duplicate elements
            while (item == arr[pos]) pos += 1;

            // put the item to it's right position
            if (item != arr[pos])
            {
                swap(&item, &arr[pos]);
                writes++;
            }
        }
    }"
main,,,0,"
int main()
{
    int n;  // Size of array elements

    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);

    cycleSort(arr, n);
    printf(""Sorted array: "");
    display(arr, n);

    free(arr);
    return 0;
}"
display,"int *arr, int n",,null,"void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
}"
binarySearch,"int *arr, int key, int low, int high",,"(key > arr[low]) ? (low + 1) : low | mid + 1 | binarySearch(arr, key, low, mid - 1) | binarySearch(arr, key, mid + 1, high)","
int binarySearch(int *arr, int key, int low, int high)
{
    if (low >= high)
        return (key > arr[low]) ? (low + 1) : low;
    int mid = low + (high - 1) / 2;
    if (arr[mid] == key)
        return mid + 1;
    else if (arr[mid] > key)
        return binarySearch(arr, key, low, mid - 1);
    else
        return binarySearch(arr, key, mid + 1, high);
}"
insertionSort,"int *arr, int size",,0,"void insertionSort(int *arr, int size)
{
    int i, j, key, index;
    for (i = 0; i < size; i++)
    {
        j = i - 1;
        key = arr[i];
        /* Use binrary search to find exact key's index */
        index = binarySearch(arr, key, 0, j);
        /* Move all elements greater than key from [index...j]
         * to one position */
        while (j >= index)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Insert key value in right place */
        arr[j + 1] = key;
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);

    insertionSort(arr, n);

    printf(""Sorted array: "");
    display(arr, n);

    free(arr);
    return 0;
}"
main,"int argc, const char *argv[]",,0,"
int main(int argc, const char *argv[])
{
    int n;
    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);

    insertionSort(arr, n);

    printf(""Sorted array: "");
    display(arr, n);

    free(arr);
    return 0;
}"
display,"int arr[], int n",,null,"void display(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }

    printf(""\n"");
}"
swap,"int *first, int *second",,null,"void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}"
partition,"int arr[], int lower, int upper",,(i + 1),"int partition(int arr[], int lower, int upper)
{
    int i = (lower - 1);

    int pivot = arr[upper];  // Selects last element as the pivot value

    int j;
    for (j = lower; j < upper; j++)
    {
        if (arr[j] <= pivot)
        {  // if current element is smaller than the pivot

            i++;  // increment the index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }

    swap(&arr[i + 1], &arr[upper]);  // places the last element i.e, the pivot
                                     // to its correct position

    return (i + 1);
}"
quickSort,"int arr[], int lower, int upper",,null,"void quickSort(int arr[], int lower, int upper)
{
    if (upper > lower)
    {
        // partitioning index is returned by the partition method , partition
        // element is at its correct poition

        int partitionIndex = partition(arr, lower, upper);

        // Sorting elements before and after the partition index
        quickSort(arr, lower, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, upper);
    }
}"
main,,,0,"
int main()
{
    int n;
    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(sizeof(int) * n);
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    quickSort(arr, 0, n - 1);

    printf(""Sorted array: "");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11
    getchar();
    free(arr);
    return 0;
}"
getBig,"int *a, int i, int right, int pivot",,k | right + 1,"
int getBig(int *a, int i, int right, int pivot)
{
    for (int k = i; k <= right; k++)
    {
        if (a[k] > pivot)
            return k;
    }
    return right + 1;
}"
getSmall,"int *a, int j, int left, int pivot",,k | -1,"
int getSmall(int *a, int j, int left, int pivot)
{
    for (int k = j; k >= left; k--)
    {
        if (a[k] < pivot)
            return k;
    }
    return -1;
}"
swap,"int *a, int *b",,null,"
void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}"
random_quick,"int *a, int left, int right",,null,"
void random_quick(int *a, int left, int right)
{
    if (left >= right)
        return;
    int index = left + (rand() % (right - left)), i = left, j = right;
    int pivot_index = index;
    int pivot = a[index];
    // storing index of element greater than pivot
    i = getBig(a, i, right, pivot);
    // storing index of element smaller than pivot
    j = getSmall(a, j, left, pivot);
    while (i <= j)
    {
        swap(&a[i], &a[j]);
        i = getBig(a, i, right, pivot);
        j = getSmall(a, j, left, pivot);
    }
    // after separating the smaller and greater elements, there are 3 cases
    // possible
    if (pivot_index > j && pivot_index > i)
    {
        // case 1. When the pivot element index is greater than both i and j
        swap(&a[i], &a[pivot_index]);
        random_quick(a, left, i - 1);
        random_quick(a, i + 1, right);
    }
    else if (pivot_index < j && pivot_index < i)
    {
        // case 2. When the pivot element index is smaller than both i and j
        swap(&a[j], &a[pivot_index]);
        random_quick(a, left, j - 1);
        random_quick(a, j + 1, right);
    }
    else
    {
        // the pivot element is at its origin position.
        random_quick(a, left, pivot_index - 1);
        random_quick(a, pivot_index + 1, right);
    }
}"
main,,,,"
int main()
{
    srand(time(0));
    int num;
    scanf(""%d"", &num);
    int *arr = (int *)malloc(num * sizeof(int));
    for (int i = 0; i < num; i++)
    {
        scanf(""%d"", &arr[i]);
    }
    random_quick(arr, 0, num - 1);
    for (int i = 0; i < num; i++)
    {
        printf(""%d "", arr[i]);
    }

    free(arr);
    printf(""\n"");
}"
swap,"int32_t *first, int32_t *second",,null,"void swap(int32_t *first, int32_t *second)
{
    int32_t temp = *first;
    *first = *second;
    *second = temp;
}"
oddEvenSort,"int *arr, int size",,null,"void oddEvenSort(int *arr, int size)
{
    bool isSorted = false;
    while(!isSorted)
    {
        isSorted = true;
        int32_t i;

        // Even phase
        for(i = 0; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }

        // Odd phase
        for(i = 1; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }
    }
}"
test,,,null,"static void test()
{
    int32_t arr1[] = {-9, 2, 3, 1};
    int32_t arr1Soln[] = {-9, 1, 2, 3};
    int32_t arr2[] = {9, 7, 5, 3, 8, 2, 1, 4, 0, 6};
    int32_t arr2Soln[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    oddEvenSort(arr1, 4);
    oddEvenSort(arr2, 10);

     for (int32_t i = 0; i < 4; i++)
     {
         assert(arr1[i] == arr1Soln[i]);    
     }

    for (int32_t i = 0; i < 10; i++)
    {
        assert(arr2[i] == arr2Soln[i]);    
    }
    printf(""All tests have passed!\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
vecswap,"int i, int j, int n, char *x[]",,null,"
void vecswap(int i, int j, int n, char *x[])
{
    while (n-- > 0)
    {
        swap(i, j);
        i++;
        j++;
    }
}"
ssort1,"char *x[], int n, int depth",,null,"
void ssort1(char *x[], int n, int depth)
{
    int a, b, c, d, r, v;
    if (n <= 1)
        return;
    a = rand() % n;
    swap(0, a);
    v = i2c(0);
    a = b = 1;
    c = d = n - 1;
    for (;;)
    {
        while (b <= c && (r = i2c(b) - v) <= 0)
        {
            if (r == 0)
            {
                swap(a, b);
                a++;
            }
            b++;
        }
        while (b <= c && (r = i2c(c) - v) >= 0)
        {
            if (r == 0)
            {
                swap(c, d);
                d--;
            }
            c--;
        }
        if (b > c)
            break;
        swap(b, c);
        b++;
        c--;
    }
    r = min(a, b - a);
    vecswap(0, b - r, r, x);
    r = min(d - c, n - d - 1);
    vecswap(b, n - r, r, x);
    r = b - a;
    ssort1(x, r, depth);
    if (i2c(r) != 0)
        ssort1(x + r, a + n - d - 1, depth + 1);
    r = d - c;
    ssort1(x + n - r, r, depth);
}"
ssort1main,"char *x[], int n",,null,"
void ssort1main(char *x[], int n) { ssort1(x, n, 0); }"
vecswap2,"char **a, char **b, int n",ssort2 -- Faster Version of Multikey Quicksort,null,"
void vecswap2(char **a, char **b, int n)
{
    while (n-- > 0)
    {
        char *t = *a;
        *a++ = *b;
        *b++ = t;
    }
}"
inssort,"char **a, int n, int d",,null,"
void inssort(char **a, int n, int d)
{
    char **pi, **pj, *s, *t;
    for (pi = a + 1; --n > 0; pi++)
        for (pj = pi; pj > a; pj--)
        {
            // Inline strcmp: break if *(pj-1) <= *pj
            for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)
                ;
            if (*s <= *t)
                break;
            swap2(pj, pj - 1);
        }
}"
ssort2,"char **a, int n, int depth",,null,"
void ssort2(char **a, int n, int depth)
{
    int d, r, partval;
    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;
    if (n < 10)
    {
        inssort(a, n, depth);
        return;
    }
    pl = a;
    pm = a + (n / 2);
    pn = a + (n - 1);
    if (n > 30)
    {  // On big arrays, pseudomedian of 9
        d = (n / 8);
        pl = med3(pl, pl + d, pl + 2 * d);
        pm = med3(pm - d, pm, pm + d);
        pn = med3(pn - 2 * d, pn - d, pn);
    }
    pm = med3(pl, pm, pn);
    swap2(a, pm);
    partval = ptr2char(a);
    pa = pb = a + 1;
    pc = pd = a + n - 1;
    for (;;)
    {
        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)
        {
            if (r == 0)
            {
                swap2(pa, pb);
                pa++;
            }
            pb++;
        }
        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)
        {
            if (r == 0)
            {
                swap2(pc, pd);
                pd--;
            }
            pc--;
        }
        if (pb > pc)
            break;
        swap2(pb, pc);
        pb++;
        pc--;
    }
    pn = a + n;
    r = min(pa - a, pb - pa);
    vecswap2(a, pb - r, r);
    r = min(pd - pc, pn - pd - 1);
    vecswap2(pb, pn - r, r);
    if ((r = pb - pa) > 1)
        ssort2(a, r, depth);
    if (ptr2char(a + r) != 0)
        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);
    if ((r = pd - pc) > 1)
        ssort2(a + n - r, r, depth);
}"
ssort2main,"char **a, int n",,null,"
void ssort2main(char **a, int n) { ssort2(a, n, 0); }"
cleanup1,Tptr p,,null,"
void cleanup1(Tptr p)
{
    if (p)
    {
        cleanup1(p->lokid);
        cleanup1(p->eqkid);
        cleanup1(p->hikid);
        free(p);
    }
}"
insert2,char *s,,null,"
void insert2(char *s)
{
    int d;
    char *instr = s;

    Tptr pp, *p;
    p = &root;
    pp = *p;
    while (pp == *p)
    {
        if ((d = *s - pp->splitchar) == 0)
        {
            if (*s++ == 0)
                return;
            p = &(pp->eqkid);
        }
        else if (d < 0)
            p = &(pp->lokid);
        else
            p = &(pp->hikid);
    }
    for (;;)
    {
        // *p = (Tptr) malloc(sizeof(Tnode));
        if (bufn-- == 0)
        {
            buffer = (Tptr)malloc(BUFSIZE * sizeof(Tnode));
            freearr[freen++] = (void *)buffer;
            bufn = BUFSIZE - 1;
        }
        *p = buffer++;
        pp = *p;
        pp->splitchar = *s;
        pp->lokid = pp->eqkid = pp->hikid = 0;
        if (*s++ == 0)
        {
            if (storestring)
                pp->eqkid = (Tptr)instr;
            return;
        }
        p = &(pp->eqkid);
    }
}"
cleanup2,,,null,"
void cleanup2()
{
    int i;
    for (i = 0; i < freen; i++) free(freearr[i]);
}"
search1,char *s,Search Algorithms,1 | 0,"
int search1(char *s)
{
    Tptr p;
    p = root;
    while (p)
    {
        if (*s < p->splitchar)
            p = p->lokid;
        else if (*s == p->splitchar)
        {
            if (*s++ == 0)
                return 1;
            p = p->eqkid;
        }
        else
            p = p->hikid;
    }
    return 0;
}"
search2,char *s,,1 | 0,"
int search2(char *s)
{
    int d, sc;
    Tptr p;
    sc = *s;
    p = root;
    while (p)
    {
        if ((d = sc - p->splitchar) == 0)
        {
            if (sc == 0)
                return 1;
            sc = *++s;
            p = p->eqkid;
        }
        else if (d < 0)
            p = p->lokid;
        else
            p = p->hikid;
    }
    return 0;
}"
pmsearch,"Tptr p, char *s",,null,"
void pmsearch(Tptr p, char *s)
{
    if (!p)
        return;
    nodecnt++;
    if (*s == '.' || *s < p->splitchar)
        pmsearch(p->lokid, s);
    if (*s == '.' || *s == p->splitchar)
        if (p->splitchar && *s)
            pmsearch(p->eqkid, s + 1);
    if (*s == 0 && p->splitchar == 0)
        srcharr[srchtop++] = (char *)p->eqkid;
    if (*s == '.' || *s > p->splitchar)
        pmsearch(p->hikid, s);
}"
nearsearch,"Tptr p, char *s, int d",,null,"
void nearsearch(Tptr p, char *s, int d)
{
    if (!p || d < 0)
        return;
    nodecnt++;
    if (d > 0 || *s < p->splitchar)
        nearsearch(p->lokid, s, d);
    if (p->splitchar == 0)
    {
        if ((int)strlen(s) <= d)
            srcharr[srchtop++] = (char *)p->eqkid;
    }
    else
        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);
    if (d > 0 || *s > p->splitchar)
        nearsearch(p->hikid, s, d);
}"
main,"int argc, char *argv[]",,,"
int main(int argc, char *argv[])
{
    char *arr[NUMBER_OF_STRING] = {""apple"", ""cat"", ""boy""};

    ssort1main(arr, NUMBER_OF_STRING);

    for (int i = 0; i < NUMBER_OF_STRING; i++)
    {
        printf(""%s "", arr[i]);
    }
}"
show_data,"int *arr, long len",,null,"void show_data(int *arr, long len)
{
    for (long i = 0; i < len; i++) printf(""%3d "", arr[i]);
    printf(""\n"");
}"
swap,"int *a, int *b",,null,"inline void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}"
shell_sort,"int *array, long LEN",,null,"void shell_sort(int *array, long LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    long i, j, g;

    for (g = 0; g < gap_len; g++)
    {  // for each gap
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {  // from gap position to the end
            int tmp = array[i];

            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)
                array[j] = array[j - gap];
            array[j] = tmp;
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf(""%s\t"", data[i]);
#endif
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    int i;
    long size = 500;
    if (argc == 2)
        size = atol(argv[1]);
    else if (argc > 2)
        fprintf(stderr, ""Usage: ./shell_sort [number of values]\n"");

    int *array = (int *)malloc(size * sizeof(int));
    int range = 500;  // range of array values
    double time_spent;

    srand(time(NULL));  // initialize random number generator
    for (i = 0; i < size; i++)
        // fill array with random integers
        array[i] = rand() % range + 1;

    show_data(array, size);   // show array before sorting
    clock_t t1 = clock();     // start timer
    shell_sort(array, size);  // sort the array
    clock_t t2 = clock();     // end timer

    printf(""Data Sorted\n"");
    show_data(array, size);  // display array after sorting

    printf(""Time spent sorting: %.4g s\n"", (t2 - t1) / CLOCKS_PER_SEC);

    free(array);
    return 0;
}"
insertionSort,"int *arr, int size",,null,"void insertionSort(int *arr, int size)
{
    for (int i = 1; i < size; i++)
    {
        int j = i - 1;
        int key = arr[i];
        /* Move all elements greater than key to one position */
        while (j >= 0 && key < arr[j])
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Find a correct position for key */
        arr[j + 1] = key;
    }
}"
test,,,null,"static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    insertionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,"int argc, const char *argv[]",,0,"
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
swap,"int8_t *first, int8_t *second",,null,"void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}"
findIndex,"const int8_t *arr, const uint8_t size",,0 | min_index,"uint8_t findIndex(const int8_t *arr, const uint8_t size)
{
    if (size == 1)
    {
        return 0;
    }

    // marking recursive call to reach starting element
    uint8_t min_index = findIndex(arr, size - 1);

    if (arr[size - 1] < arr[min_index])
    {
        min_index = size - 1;
    }

    return min_index;
}"
selectionSort,"int8_t *arr, const uint8_t size",,null,"void selectionSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    /* findIndex(arr, size) returned the index having min value*/
    uint8_t min_index = findIndex(arr, size);
    /* arr[min_index] is the minimum value in the array*/

    if (min_index != 0)
    {
        swap(&arr[0], &arr[min_index]);
    }

    /*sorted the remaining array recursively*/
    selectionSort(arr + 1, size - 1);
}"
test,,,null,"static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    selectionSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,,,0,"int main()
{
    /* Intializes random number generator */
    srand(time(NULL));

    test();  // run self-test implementations
    return 0;
}"
flip,"int arr[], int i",,null,"void flip(int arr[], int i)
{
    int temp, start = 0;

    while (start < i)
    {
        temp = arr[start];
        arr[start] = arr[i];
        arr[i] = temp;
        start++;
        i--;
    }
}"
findMax,"int arr[], int n",,maxElementIdx,"
int findMax(int arr[], int n)
{
    int maxElementIdx, i;

    for (maxElementIdx = 0, i = 0; i < n; ++i)
        if (arr[i] > arr[maxElementIdx])
            maxElementIdx = i;

    return maxElementIdx;
}"
pancakeSort,"int *arr, int n",,0,"
void pancakeSort(int *arr, int n)
{
    // Start from the complete array and one by one reduce current size by one
    for (int curr_size = n; curr_size > 1; --curr_size)
    {
        // Find index of the maximum element in arr[0..curr_size-1]
        int maxElementIdx = findMax(arr, curr_size);

        // Move the maximum element to end of current array if it's not already
        // at the end
        if (maxElementIdx != curr_size - 1)
        {
            // To move at the end, first move maximum number to beginning
            flip(arr, maxElementIdx);

            // Now move the maximum number to end by reversing current array
            flip(arr, curr_size - 1);
        }
    }
}

// Displays the array, passed to this method
void display(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }

    printf(""\n"");
}

#define N 50

// Driver program to test above function
int main()
{
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */

    printf(""Original array: "");
    display(arr, N);

    pancakeSort(arr, N);
    printf(""Sorted array: "");
    display(arr, N);

    return 0;
}"
display,"int arr[], int n",,null,"
void display(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }

    printf(""\n"");
}"
main,,,0,"
int main()
{
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */

    printf(""Original array: "");
    display(arr, N);

    pancakeSort(arr, N);
    printf(""Sorted array: "");
    display(arr, N);

    return 0;
}"
swap,"int *first, int *second",,null,"void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}"
bubbleSort,"int *arr, int size",,null,"void bubbleSort(int *arr, int size)
{
    if (size == 1)
    {
        return;
    }
    bool swapped = false;
    for (int i = 0; i < size - 1; ++i)
    {
        if (arr[i] > arr[i + 1])
        {
            swap(arr + i, arr + i + 1);
            swapped = true;
        }
    }
    if (swapped)
    {
        bubbleSort(arr, size - 1);
    }
}"
test,,,null,"void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,,,0,"int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
InsertionSort,struct Node *list,,list | nodeList,"struct Node *InsertionSort(struct Node *list)
{
    struct Node *k, *nodeList;
    /* need at least two items to sort */
    if (list == NULL || list->next == NULL)
    {
        return list;
    }

    nodeList = list;
    k = list->next;
    nodeList->next = NULL; /* 1st node is new list */
    while (k != NULL)
    {
        struct Node *ptr;
        /* check if insert before first */
        if (nodeList->data > k->data)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = nodeList;
            nodeList = tmp;
            continue;
        }

        // from begin up to end
        // finds [i] > [i+1]
        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)
        {
            if (ptr->next->data > k->data)
                break;
        }

        // if found (above)
        if (ptr->next != NULL)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = ptr->next;
            ptr->next = tmp;
            continue;
        }
        else
        {
            ptr->next = k;
            k = k->next;  // important for the while
            ptr->next->next = NULL;
            continue;
        }
    }
    return nodeList;
}"
getBucketIndex,int value,,value / INTERVAL,"
int getBucketIndex(int value) { return value / INTERVAL; }"
print,int ar[],,null,"
void print(int ar[])
{
    int i;
    for (i = 0; i < NARRAY; ++i)
    {
        printf(""%d "", ar[i]);
    }
    printf(""\n"");
}"
printBuckets,struct Node *list,,null,"
void printBuckets(struct Node *list)
{
    struct Node *cur = list;
    while (cur)
    {
        printf(""%d "", cur->data);
        cur = cur->next;
    }
}"
main,,,0,"
int main(void)
{
    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};

    printf(""Initial array\n"");
    print(array);
    printf(""------------\n"");

    BucketSort(array);
    printf(""------------\n"");
    printf(""Sorted array\n"");
    print(array);
    return 0;
}"
shuffle,"int *a, int n",,null,"
void shuffle(int *a, int n)
{
    int i, t, r;
    for (i = 0; i < n; i++)
    {
        t = a[i];
        r = rand() % n;
        a[i] = a[r];
        a[r] = t;
    }
}"
sort,"int *a, int n",,null,"
void sort(int *a, int n)
{
    while (!check_sorted(a, n)) shuffle(a, n);
}"
main,,,,"
int main()
{
    int numbers[6];
    int i;
    printf(""Enter 6 numbers unsorted \n\n"");
    for (i = 0; i < 6; i++)
    {
        scanf(""%d"", &numbers[i]);
    }
    sort(numbers, 6);
    for (i = 0; i < 6; i++) printf(""%d "", numbers[i]);
    printf(""\n"");
}"
swap,"int *a, int *b",,null,"
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}"
shakersort,"int *a, int n",,null,"
void shakersort(int *a, int n)
{
    int p, i;
    for (p = 1; p <= n / 2; p++)
    {
        for (i = p - 1; i < n - p; i++)
            if (a[i] > a[i + 1])
            {
                swap(&a[i], &a[i + 1]);
            }
        for (i = n - p - 1; i >= p; i--)
            if (a[i] < a[i - 1])
            {
                swap(&a[i], &a[i - 1]);
            }
    }
}"
main,,,0,"
int main()
{
    int n;
    scanf(""%d"", &n);
    int *arr = (int *)malloc(n * sizeof(int));
    int i;
    for (i = 0; i < n; i++) scanf(""%d "", &arr[i]);
    shakersort(arr, n);
    for (i = 0; i < n; i++) printf(""%d "", arr[i]);
    free(arr);
    return 0;
}"
sort,"int *numbers, int size",,null,"
void sort(int *numbers, int size)
{
    int gap = size;
    while (gap > 1)  // gap = 1 means that the array is sorted
    {
        gap = gap / SHRINK;
        int i = 0;
        while ((i + gap) < size)
        {  // similiar to the Shell Sort
            if (numbers[i] > numbers[i + gap])
            {
                int tmp = numbers[i];
                numbers[i] = numbers[i + gap];
                numbers[i + gap] = tmp;
            }
            i++;
        }
    }
}"
display,"int *array, int n",,null,"
void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf(""%d "", array[i]);
    printf(""\n"");
}"
main,,,0,"
int main()
{
    int size = 6;
    int *numbers = malloc(size * sizeof(int));
    printf(""Insert %d unsorted numbers: \n"", size);
    int i;
    for (i = 0; i < size; ++i) scanf(""%d"", &numbers[i]);
    printf(""Initial array: "");
    display(numbers, size);
    sort(numbers, size);
    printf(""Sorted array: "");
    display(numbers, size);
    free(numbers);
    return 0;
}"
largest,"int a[], int n",,large,"
int largest(int a[], int n)
{
    int large = a[0], i;
    for (i = 1; i < n; i++)
    {
        if (large < a[i])
            large = a[i];
    }
    return large;
}"
RadixSort,"int a[], int n",,null,"
void RadixSort(int a[], int n)
{
    int bucket[10][10], bucket_count[10];
    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;

    large = largest(a, n);
    printf(""The large element %d\n"", large);
    while (large > 0)
    {
        NOP++;
        large /= 10;
    }

    for (pass = 0; pass < NOP; pass++)
    {
        for (i = 0; i < 10; i++)
        {
            bucket_count[i] = 0;
        }
        for (i = 0; i < n; i++)
        {
            remainder = (a[i] / divisor) % 10;
            bucket[remainder][bucket_count[remainder]] = a[i];
            bucket_count[remainder] += 1;
        }

        i = 0;
        for (k = 0; k < 10; k++)
        {
            for (j = 0; j < bucket_count[k]; j++)
            {
                a[i] = bucket[k][j];
                i++;
            }
        }
        divisor *= 10;

        for (i = 0; i < n; i++) printf(""%d  "", a[i]);
        printf(""\n"");
    }
}"
main,,,0,"
int main()
{
    int i, n, a[10];
    printf(""Enter the number of elements :: "");
    scanf(""%d"", &n);
    printf(""Enter the elements :: "");
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &a[i]);
    }
    RadixSort(a, n);
    printf(""The sorted elements are ::  "");
    for (i = 0; i < n; i++) printf(""%d  "", a[i]);
    printf(""\n"");
    return 0;
}"
RecursionInsertionSort,"int *arr, int size",,null,"void RecursionInsertionSort(int *arr, int size)
{
    if(size <= 0)
    {
        return;
    }
    
    // marking recursive call to reach starting element
    RecursionInsertionSort(arr,size-1);
    
    int key = arr[size-1];
    int j = size-2;
    // swapping logic for insertion sort
    while(j >= 0 && arr[j] > key)
    {
        arr[j+1] = arr[j];
        j--;
    }
    arr[j+1] = key;
}"
test,,,null,"static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50;/* signed random numbers */
    }
    RecursionInsertionSort(arr, size);
    for (int i = 0; i < size  ; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,"int argc, const char *argv[]","Test function
@returns None",0,"int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
display,"const int *arr, int n",,null,"void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }

    printf(""\n"");
}"
bead_sort,"int *a, size_t len",,null,"void bead_sort(int *a, size_t len)
{
    int i, j, max, sum;
    unsigned char *beads;

    for (i = 1, max = a[0]; i < len; i++)
        if (a[i] > max)
            max = a[i];

    beads = calloc(1, max * len);

    /* mark the beads */
    for (i = 0; i < len; i++)
        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;

    for (j = 0; j < max; j++)
    {
        /* count how many beads are on each post */
        for (sum = i = 0; i < len; i++)
        {
            sum += BEAD(i, j);
            BEAD(i, j) = 0;
        }
        /* mark bottom sum beads */
        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
    }

    for (i = 0; i < len; i++)
    {
        for (j = 0; j < max && BEAD(i, j); j++)
            ;
        a[i] = j;
    }
    free(beads);
}"
main,"int argc, const char *argv[]",,0,"int main(int argc, const char *argv[])
{
    int n;
    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8 1 2 3

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);

    bead_sort(arr, n);

    printf(""Sorted array: "");
    display(arr, n);

    free(arr);
    return 0;
}"
sort,"int *numbers, int size",,null,"
void sort(int *numbers, int size)
{
    int pos = 0;
    while (pos < size)
    {
        if (numbers[pos] >= numbers[pos - 1])
            pos++;
        else
        {
            int tmp = numbers[pos - 1];
            numbers[pos - 1] = numbers[pos];
            numbers[pos] = tmp;
            pos--;

            if (pos == 0)
                pos = 1;
        }
    }
}"
display,"int *array, int n",,null,"
void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf(""%d "", array[i]);
    printf(""\n"");
}"
main,,,0,"
int main()
{
    int size = 6;
    int i;
    int *numbers = malloc(size * sizeof(int));
    printf(""Insert %d unsorted numbers: \n"", size);
    for (i = 0; i < size; ++i) scanf(""%d"", &numbers[i]);
    printf(""Initial array: "");
    display(numbers, size);
    sort(numbers, size);
    printf(""Sorted array: "");
    display(numbers, size);
    free(numbers);
    return 0;
}"
mergesort,"int x[], int n",,null,"
void mergesort(int x[], int n)
{
    int temp[50], i, j, k, lb1, lb2, ub1, ub2, size;

    size = 1;
    while (size < n)
    {
        lb1 = 0;
        k = 0;

        while (lb1 + size < n)
        {
            lb2 = lb1 + size;
            ub1 = lb2 - 1;
            if (ub1 + size < n)
                ub2 = ub1 + size;
            else
                ub2 = n - 1;

            i = lb1;
            j = lb2;

            while (i <= ub1 && j <= ub2)
                if (x[i] < x[j])
                    temp[k++] = x[i++];
                else
                    temp[k++] = x[j++];

            while (i <= ub1) temp[k++] = x[i++];

            while (j <= ub2) temp[k++] = x[j++];

            lb1 = ub2 + 1;
        }

        for (i = 0; i <= ub2; i++) x[i] = temp[i];

        size = size * 2;

        show(x, n);
    }
}"
show,"int x[], int n",,null,"
void show(int x[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf(""%d "", x[i]);
    printf(""\n\n"");
}"
swap,"int *a, int *b",,null,"
void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}"
partition,"int arr[], int low, int high",,j,"
int partition(int arr[], int low, int high)
{
    int pivot = arr[low];
    int i = low - 1, j = high + 1;

    while (1)
    {
        /* Find leftmost element >= pivot */
        do
        {
            i++;
        } while (arr[i] < pivot);

        /* Find rightmost element <= pivot */
        do
        {
            j--;
        } while (arr[j] > pivot);

        /* if two pointers met */
        if (i >= j)
            return j;

        swap(&arr[i], &arr[j]);
    }
}"
partitionSort,"int arr[], int low, int high",,null,"
void partitionSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int value = partition(arr, low, high);
        partitionSort(arr, low, value);
        partitionSort(arr, value + 1, high);
    }
}"
printArray,"int arr[], int n",,null,"
void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf(""%d "", arr[i]);
    printf(""\n"");
}"
main,,,0,"
int main()
{
    int arr[20];
    int i, range = 100;
    for (i = 0; i < 20; i++)
    {
        arr[i] = rand() % range + 1;
    }
    int size = sizeof arr / sizeof arr[0];
    printf(""Array: \n"");
    printArray(arr, size);
    partitionSort(arr, 0, size - 1);
    printf(""Sorted Array: \n"");
    printArray(arr, size);

    return 0;
}"
MAX,"int *ar, int size",,max,"
int MAX(int *ar, int size)
{
    int i, max = ar[0];
    for (i = 0; i < size; i++)
    {
        if (ar[i] > max)
            max = ar[i];
    }
    return max;
}"
countSort,"int *arr, int n, int place",,null,"
void countSort(int *arr, int n, int place)
{
    int i, freq[range] = {0};
    int *output = (int *)malloc(n * sizeof(int));

    // Store count of occurrences in freq[]
    for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;

    // Change freq[i] so that it contains the actual position of the digit in
    // output[]
    for (i = 1; i < range; i++) freq[i] += freq[i - 1];

    // Build the output array
    for (i = n - 1; i >= 0; i--)
    {
        output[freq[(arr[i] / place) % range] - 1] = arr[i];
        freq[(arr[i] / place) % range]--;
    }

    // Copy the output array to arr[], so it contains numbers according to the
    // current digit
    for (i = 0; i < n; i++) arr[i] = output[i];
    free(output);
}"
display,"int *arr, int N",,null,"
void display(int *arr, int N)
{
    for (int i = 0; i < N; i++) printf(""%d, "", arr[i]);
    putchar('\n');
}"
main,"int argc, const char *argv[]",,0,"
int main(int argc, const char *argv[])
{
    int n;
    printf(""Enter size of array:\n"");
    scanf(""%d"", &n);  // E.g. 8

    printf(""Enter the elements of the array\n"");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }

    printf(""Original array: "");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    int max;
    max = MAX(arr, n);

    radixsort2(arr, n, max);

    printf(""Sorted array: "");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11

    free(arr);
    return 0;
}"
main,,,0,"
int main()
{
    int arr[100], i, n;

    printf(""How many elements do you want to sort: "");
    scanf(""%d"", &n);
    for (i = 0; i < n; i++) scanf("" %d"", &arr[i]);
    stoogesort(arr, 0, n - 1);
    printf(""Sorted array : \n"");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
    return 0;
}"
stoogesort,"int arr[], int i, int j",,null,"
void stoogesort(int arr[], int i, int j)
{
    int temp, k;
    if (arr[i] > arr[j])
    {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    if ((i + 1) >= j)
        return;
    k = (int)((j - i + 1) / 3);
    stoogesort(arr, i, j - k);
    stoogesort(arr, i + k, j);
    stoogesort(arr, i, j - k);
}"
swap,"int *first, int *second",,null,"void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}"
selectionSort,"int *arr, int size",,null,"void selectionSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        int min_index = i;
        for (int j = i + 1; j < size; j++)
        {
            if (arr[min_index] > arr[j])
            {
                min_index = j;
            }
        }
        if (min_index != i)
        {
            swap(arr + i, arr + min_index);
        }
    }
}"
test,,,null,"static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    selectionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,"int argc, const char *argv[]","Test function
@returns None",0,"int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
show_data,"int arr[], int len",,null,"
void show_data(int arr[], int len)
{
    int i;

    for (i = 0; i < len; i++) printf(""%3d "", arr[i]);
    printf(""\n"");
}"
swap,"int *a, int *b",,null,"
void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}"
shellSort,"int array[], int len",,null,"
void shellSort(int array[], int len)
{
    int i, j, gap;

    for (gap = len / 2; gap > 0; gap = gap / 2)
        for (i = gap; i < len; i++)
            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)
                swap(&array[j], &array[j + gap]);
}"
main,"int argc, char *argv[]",,0,"
int main(int argc, char *argv[])
{
    int i;
    int array[ELEMENT_NR];
    int range = 500;
    int size;
    clock_t start, end;
    double time_spent;

    srand(time(NULL));
    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;

    size = ARRAY_LEN(array);

    show_data(array, size);
    start = clock();
    shellSort(array, size);
    end = clock();
    time_spent = (double)(end - start) / CLOCKS_PER_SEC;

    printf(""Data Sorted\n"");
    show_data(array, size);

    printf(""%s\n"", notation);
    printf(""Time spent sorting: %.4g ms\n"", time_spent * 1e3);

    return 0;
}"
max_heapify,"int *a, int i, int n",,null,"
void max_heapify(int *a, int i, int n)
{
    int j, temp;
    temp = a[i];
    j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j + 1] > a[j])
            j = j + 1;
        if (temp > a[j])
        {
            break;
        }
        else if (temp <= a[j])
        {
            a[j / 2] = a[j];
            j = 2 * j;
        }
    }
    a[j / 2] = temp;
    return;
}"
heapsort,"int *a, int n",,null,"
void heapsort(int *a, int n)
{
    int i, temp;
    for (i = n; i >= 2; i--)
    {
        temp = a[i];
        a[i] = a[1];
        a[1] = temp;
        max_heapify(a, 1, i - 1);
    }
}"
build_maxheap,"int *a, int n",,null,"
void build_maxheap(int *a, int n)
{
    int i;
    for (i = n / 2; i >= 1; i--)
    {
        max_heapify(a, i, n);
    }
}"
main,,,,"
int main()
{
    int n, i;
    printf(""Enter number of elements of array\n"");
    scanf(""%d"", &n);
    int a[20];
    for (i = 1; i <= n; i++)
    {
        printf(""Enter Element %d\n"", i);
        scanf(""%d"", a + i);
    }

    build_maxheap(a, n);
    heapsort(a, n);
    printf(""Sorted Output\n"");
    for (i = 1; i <= n; i++)
    {
        printf(""%d\n"", a[i]);
    }

    getchar();
}"
swap,"int *a, int *b",,null,"void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}"
merge,"int *a, int l, int r, int n",,null,"void merge(int *a, int l, int r, int n)
{
    int *b = (int *)malloc(n * sizeof(int)); /* dynamic memory must be freed */
    if (b == NULL)
    {
        printf(""Can't Malloc! Please try again."");
        exit(EXIT_FAILURE);
    }
    int c = l;
    int p1, p2;
    p1 = l;
    p2 = ((l + r) / 2) + 1;
    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))
    {
        if (a[p1] <= a[p2])
        {
            b[c++] = a[p1];
            p1++;
        }
        else
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    if (p2 == r + 1)
    {
        while ((p1 < ((l + r) / 2) + 1))
        {
            b[c++] = a[p1];
            p1++;
        }
    }
    else
    {
        while ((p2 < r + 1))
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    for (c = l; c < r + 1; c++) a[c] = b[c];

    free(b);
}"
merge_sort,"int *a, int n, int l, int r","@brief Perform merge of segments.
@param a array to sort
@param l left index for merge
@param r right index for merge
@param n total number of elements in the array",null,"void merge_sort(int *a, int n, int l, int r)
{
    if (r - l == 1)
    {
        if (a[l] > a[r])
            swap(&a[l], &a[r]);
    }
    else if (l != r)
    {
        merge_sort(a, n, l, (l + r) / 2);
        merge_sort(a, n, ((l + r) / 2) + 1, r);
        merge(a, l, r, n);
    }

    /* no change if l == r */
}"
main,,,1 | 0,"int main(void)
{
    int *a, n, i;
    printf(""Enter Array size: "");
    scanf(""%d"", &n);
    if (n <= 0) /* exit program if arraysize is not greater than 0 */
    {
        printf(""Array size must be Greater than 0!\n"");
        return 1;
    }
    a = (int *)malloc(n * sizeof(int));
    if (a == NULL) /* exit program if can't malloc memory */
    {
        printf(""Can't Malloc! Please try again."");
        return 1;
    }
    for (i = 0; i < n; i++)
    {
        printf(""Enter number[%d]: "", i);
        scanf(""%d"", &a[i]);
    }

    merge_sort(a, n, 0, n - 1);
    printf(""Sorted Array: "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", a[i]);
    }
    printf(""\n"");

    free(a);

    return 0;
}"
pigeonholeSort,"int arr[], int size",,0,"
void pigeonholeSort(int arr[], int size)
{
    int i, j, min = arr[0], max = arr[0], range;

    // Getting range of the array using max and min
    for (i = 1; i < size; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }
    range = max - min + 1;

    // Make 'holes' and put array's numbers in holes
    int *holes = (int *)malloc(sizeof(int) * range);
    for (i = 0; i < range; i++)
    {
        holes[i] = 0;
    }
    for (i = 0; i < size; i++)
    {
        holes[arr[i] - min]++;
    }

    // Copy the numbers back to the original array
    j = 0;
    for (i = 0; i < range; i++)
    {
        while (holes[i] > 0)
        {
            arr[j] = i + min;
            holes[i]--;
            j++;
        }
    }

    free(holes);
}

int main()
{
    int i, n;

    printf(""Enter the size of the array: "");
    scanf(""%d"", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf(""Number #%d: "", i + 1);
        scanf(""%d"", &arr[i]);
    }

    printf(""You entered:  "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    pigeonholeSort(arr, n);
    printf(""\nSorted array: "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");

    free(arr);
    return 0;
}"
main,,,0,"
int main()
{
    int i, n;

    printf(""Enter the size of the array: "");
    scanf(""%d"", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf(""Number #%d: "", i + 1);
        scanf(""%d"", &arr[i]);
    }

    printf(""You entered:  "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    pigeonholeSort(arr, n);
    printf(""\nSorted array: "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");

    free(arr);
    return 0;
}"
bubble_sort,int* array_sort,,null,"void bubble_sort(int* array_sort)
{
	bool is_sorted = false;

    /* keep iterating over entire array
     * and swaping elements out of order
     * until it is sorted */
    while (!is_sorted)
    {
		is_sorted = true;

        /* iterate over all elements */
        for (int i = 0; i < MAX - 1; i++)
        {
            /* check if adjacent elements are out of order */
            if (array_sort[i] > array_sort[i + 1])
            {
                /* swap elements */
                int change_place = array_sort[i];
                array_sort[i] = array_sort[i + 1];
                array_sort[i + 1] = change_place;
                /* elements out of order were found
                 * so we reset the flag to keep ordering
                 * until no swap operations are executed */
                is_sorted = false;
            }
        }
    }
}"
test,,,null,"static void test() {
    /* simple int array for testing */
	int array_sort[MAX] = {0};

    /* populate our test array with 
     * random integer numbers */
    for (int i = 0; i < MAX; i++)
    {
        array_sort[i] = rand() % 101;
    }

    /* sort array */
    bubble_sort(array_sort);

    /* check if array ir correctly ordered */	
    for (int i = 0; i < MAX - 1; i++)
    {
        assert(array_sort[i] <= array_sort[i+1]);
    }
}"
main,,"@brief Test implementations
@returns void",0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
swap,"int8_t *first, int8_t *second",,null,"void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}"
heapifyDown,"int8_t *arr, const uint8_t size",,null,"void heapifyDown(int8_t *arr, const uint8_t size)
{
    uint8_t i = 0;

    while (2 * i + 1 < size)
    {
        uint8_t maxChild = 2 * i + 1;

        if (2 * i + 2 < size && arr[2 * i + 2] > arr[maxChild])
        {
            maxChild = 2 * i + 2;
        }

        if (arr[maxChild] > arr[i])
        {
            swap(&arr[i], &arr[maxChild]);
            i = maxChild;
        }
        else
        {
            break;
        }
    }
}"
heapifyUp,"int8_t *arr, uint8_t i",,null,"void heapifyUp(int8_t *arr, uint8_t i)
{
    while (i > 0 && arr[(i - 1) / 2] < arr[i])
    {
        swap(&arr[(i - 1) / 2], &arr[i]);
        i = (i - 1) / 2;
    }
}"
heapSort,"int8_t *arr, const uint8_t size",,null,"void heapSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    for (uint8_t i = 0; i < size; i++)
    {
        // Pushing `arr[i]` to the heap

        /*heapifyUp Adjusts arr[i] to the correct position in the heap*/
        heapifyUp(arr, i);
    }

    for (uint8_t i = size - 1; i >= 1; i--)
    {
        // Moving current root to the end
        swap(&arr[0], &arr[i]);

        // `heapifyDown` adjusts new root to the correct position in the heap
        heapifyDown(arr, i);

    }
}"
test,,Pushing `arr[i]` to the heap,null,"static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    heapSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,,,0,"int main()
{
    // Intializes random number generator
    srand(time(NULL));

    test(); // run self-test implementations
    return 0;
}"
cocktailSort,"int arr[], int size",,null,"
void cocktailSort(int arr[], int size)
{
    int i, changed = TRUE, temp, start = 0, end = size - 1;

    while (changed)
    {
        changed = FALSE;
        for (i = start; i < end; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                changed = TRUE;
            }
        }
        end--;

        if (changed == FALSE)
        {
            break;
        }
        changed = FALSE;

        for (i = end - 1; i >= start; i--)
        {
            if (arr[i + 1] < arr[i])
            {
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
                changed = TRUE;
            }
        }
        start++;
    }
}"
main,,,0,"
int main()
{
    int i, n;

    printf(""Enter the size of the array: "");
    scanf(""%d"", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf(""Number #%d: "", i + 1);
        scanf(""%d"", &arr[i]);
    }

    printf(""You entered:  "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    cocktailSort(arr, n);
    printf(""\nSorted array: "");
    for (i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");

    free(arr);
    return 0;
}"
main,,,0,"
int main()
{
    int i, n, l = 0;

    printf(""Enter size of array = "");
    scanf(""%d"", &n);

    int *a = (int *)malloc(n * sizeof(int));
    printf(""Enter %d elements in array :\n"", n);
    for (i = 0; i < n; i++)
    {
        scanf(""%d"", &a[i]);
        if (a[i] > l)
            l = a[i];
    }

    int *b = (int *)malloc((l + 1) * sizeof(int));
    memset(b, 0, (l + 1) * sizeof(b[0]));

    for (i = 0; i < n; i++) b[a[i]]++;  // hashing number to array index

    for (i = 0; i < (l + 1); i++)  // unstable , stabilized by prefix sum array
    {
        if (b[i] > 0)
        {
            while (b[i] != 0)  // for case when number exists more than once
            {
                printf(""%d "", i);
                b[i]--;
            }
        }
    }

    free(a);
    free(b);
    return 0;
}"
patienceSort,"int *array, int length",,0,"void patienceSort(int *array, int length) {
    // An array of pointers used to store each pile
    int* *piles = (int* *) malloc(sizeof(int*) * length);
    for (int i = 0; i < length; ++i) {
        piles[i] = malloc(sizeof(int) * length);
    }

    // pileSizes keep track of the indices of each pile's topmost element, hence 0 means only one element
    // Note how calloc() is used to initialize the sizes of all piles to zero
    int *pileSizes = (int*) calloc(length,sizeof(int));

    // This initializes the first pile, note how using an array of pointers allowed us to access elements through two subscripts
    // The first subscript indicates which pile we are accessing, the second subscript indicates the location being accessed in that pile
    piles[0][0] = array[0];
    int pileCount = 1;

    for (int i = 1; i < length; ++i) {
        // This will be used to keep track whether an element has been added to an existing pile
        int flag = 1;

        for (int j = 0; j < pileCount; ++j) {
            if(piles[j][pileSizes[j]] > array[i]) {
                // We have found a pile this element can be added to
                piles[j][pileSizes[j] + 1] = array[i];
                pileSizes[j]++;
                flag--;
                break;
            }
        }

        if(flag) {
            // The element in question can not be added to any existing piles, creating a new pile
            piles[pileCount][0] = array[i];
            pileCount++;
        }
    }

    // This will keep track of the minimum value of all 'exposed' elements and which pile that value is from
    int min, minLocation;

    for (int i = 0; i < length; ++i) {
        // Since there's no guarantee the first pile will be depleted slower than other piles,
        // Example: when all elements are equal, in that case the first pile will be depleted immediately
        // We can't simply initialize min to the top most element of the first pile,
        // this loop finds a value to initialize min to.
        for (int j = 0; j < pileCount; ++j) {
            if(pileSizes[j] < 0) {
                continue;
            }
            min = piles[j][pileSizes[j]];
            minLocation = j;
            break;
        }

        for (int j = 0; j < pileCount; ++j) {
            if(pileSizes[j] < 0) {
                continue;
            }
            if(piles[j][pileSizes[j]] < min) {
                min = piles[j][pileSizes[j]];
                minLocation = j;
            }
        }

        array[i] = min;
        pileSizes[minLocation]--;
    }

    // Deallocate memory
    free(pileSizes);
    for (int i = 0; i < length; ++i) {
        free(piles[i]);
    }
    free(piles);
}

/**
 * @brief Helper function to print an array
 * @param array pointer to the array
 * @param length length of the target array
 * @returns void
 */
void printArray(int *array,int length) {
    printf(""Array:"");
    for (int i = 0; i < length; ++i) {
        printf(""%d"",array[i]);
        if (i != length - 1) putchar(',');
    }
    putchar('\n');
}

/**
 * @brief Testing Helper function
 * @param array pointer to the array to be used for testing
 * @param length length of the target array
 * @returns void
 */

void testArray(int *array,int length) {
    printf(""Before sorting:\n"");
    printArray(array,length);

    patienceSort(array,length);

    printf(""After sorting:\n"");
    printArray(array,length);

    for (int i = 0; i < length - 1; ++i) {
        assert(array[i] <= array[i + 1]);
    }
    printf(""All assertions have passed!\n\n"");
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test() {
    int testArray1[] = {2,8,7,1,3,5,6,4};
    int testArray2[] = {2,2,5,1,3,5,6,4};
    int testArray3[] = {1,2,3,4,5,6,7,8};
    int testArray4[] = {8,7,6,5,4,3,2,1};

    testArray(testArray1,8);
    testArray(testArray2,8);
    testArray(testArray3,8);
    testArray(testArray4,8);

    printf(""Testing successfully completed!\n"");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() {
    test();  // run self-test implementations
    return 0;
}"
printArray,"int *array,int length",,null,"void printArray(int *array,int length) {
    printf(""Array:"");
    for (int i = 0; i < length; ++i) {
        printf(""%d"",array[i]);
        if (i != length - 1) putchar(',');
    }
    putchar('\n');
}"
testArray,"int *array,int length",,null,"void testArray(int *array,int length) {
    printf(""Before sorting:\n"");
    printArray(array,length);

    patienceSort(array,length);

    printf(""After sorting:\n"");
    printArray(array,length);

    for (int i = 0; i < length - 1; ++i) {
        assert(array[i] <= array[i + 1]);
    }
    printf(""All assertions have passed!\n\n"");
}"
test,,,null,"static void test() {
    int testArray1[] = {2,8,7,1,3,5,6,4};
    int testArray2[] = {2,2,5,1,3,5,6,4};
    int testArray3[] = {1,2,3,4,5,6,7,8};
    int testArray4[] = {8,7,6,5,4,3,2,1};

    testArray(testArray1,8);
    testArray(testArray2,8);
    testArray(testArray3,8);
    testArray(testArray4,8);

    printf(""Testing successfully completed!\n"");
}"
main,,,0,"int main() {
    test();  // run self-test implementations
    return 0;
}"
display,"const int *arr, int n",,null,"void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
}"
swap,"int *first, int *second",,null,"void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}"
bubbleSort,"int *arr, int size",,null,"void bubbleSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {                         /* for each array index */
        bool swapped = false; /* flag to check if any changes had to be made */
        /* perform iterations until no more changes were made or outer loop
            executed for all array indices */
        for (int j = 0; j < size - 1 - i; j++)
        { /* for each element in the array */
            if (arr[j] > arr[j + 1])
            { /* if the order of successive elements needs update */
                swap(&arr[j], &arr[j + 1]);
                swapped = true; /* set flag */
            }
        }
        if (!swapped)
        {
            /* since no more updates we made, the array is already sorted
                this is an optimization for early termination */
            break;
        }
    }
}"
test,,,null,"void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}"
main,"int argc, const char *argv[]",,0,"int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
calculateNearst,"observation* o, cluster clusters[], int k",,index,"int calculateNearst(observation* o, cluster clusters[], int k)
{
    double minD = DBL_MAX;
    double dist = 0;
    int index = -1;
    int i = 0;
    for (; i < k; i++)
    {
        /* Calculate Squared Distance*/
        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +
               (clusters[i].y - o->y) * (clusters[i].y - o->y);
        if (dist < minD)
        {
            minD = dist;
            index = i;
        }
    }
    return index;
}"
calculateCentroid,"observation observations[], size_t size, cluster* centroid",,null,"void calculateCentroid(observation observations[], size_t size,
                       cluster* centroid)
{
    size_t i = 0;
    centroid->x = 0;
    centroid->y = 0;
    centroid->count = size;
    for (; i < size; i++)
    {
        centroid->x += observations[i].x;
        centroid->y += observations[i].y;
        observations[i].group = 0;
    }
    centroid->x /= centroid->count;
    centroid->y /= centroid->count;
}"
printEPS,"observation pts[], size_t len, cluster cent[], int k",,null,"void printEPS(observation pts[], size_t len, cluster cent[], int k)
{
    int W = 400, H = 400;
    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;
    double scale = 0, cx = 0, cy = 0;
    double* colors = (double*)malloc(sizeof(double) * (k * 3));
    int i;
    size_t j;
    double kd = k * 1.0;
    for (i = 0; i < k; i++)
    {
        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;
        *(colors + 3 * i + 1) = (7 * i % k) / kd;
        *(colors + 3 * i + 2) = (9 * i % k) / kd;
    }

    for (j = 0; j < len; j++)
    {
        if (max_x < pts[j].x)
        {
            max_x = pts[j].x;
        }
        if (min_x > pts[j].x)
        {
            min_x = pts[j].x;
        }
        if (max_y < pts[j].y)
        {
            max_y = pts[j].y;
        }
        if (min_y > pts[j].y)
        {
            min_y = pts[j].y;
        }
    }
    scale = W / (max_x - min_x);
    if (scale > (H / (max_y - min_y)))
    {
        scale = H / (max_y - min_y);
    };
    cx = (max_x + min_x) / 2;
    cy = (max_y + min_y) / 2;

    printf(""%%!PS-Adobe-3.0 EPSF-3.0\n%%%%BoundingBox: -5 -5 %d %d\n"", W + 10,
           H + 10);
    printf(
        ""/l {rlineto} def /m {rmoveto} def\n""
        ""/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n""
        ""/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath ""
        ""	gsave 1 setgray fill grestore gsave 3 setlinewidth""
        "" 1 setgray stroke grestore 0 setgray stroke }def\n"");
    for (int i = 0; i < k; i++)
    {
        printf(""%g %g %g setrgbcolor\n"", *(colors + 3 * i),
               *(colors + 3 * i + 1), *(colors + 3 * i + 2));
        for (j = 0; j < len; j++)
        {
            if (pts[j].group != i)
            {
                continue;
            }
            printf(""%.3f %.3f c\n"", (pts[j].x - cx) * scale + W / 2,
                   (pts[j].y - cy) * scale + H / 2);
        }
        printf(""\n0 setgray %g %g s\n"", (cent[i].x - cx) * scale + W / 2,
               (cent[i].y - cy) * scale + H / 2);
    }
    printf(""\n%%%%EOF"");

    // free accquired memory
    free(colors);
}"
test,,,null,"static void test()
{
    size_t size = 100000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 5;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}"
test2,,,null,"void test2()
{
    size_t size = 1000000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 11;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}"
main,,,0,"int main()
{
    srand(time(NULL));
    test();
    /* test2(); */
    return 0;
}"
new_adaline,"const int num_features, const double eta",,ada,"struct adaline new_adaline(const int num_features, const double eta)
{
    if (eta <= 0.f || eta >= 1.f)
    {
        fprintf(stderr, ""learning rate should be > 0 and < 1\n"");
        exit(EXIT_FAILURE);
    }

    // additional weight is for the constant bias term
    int num_weights = num_features + 1;
    struct adaline ada;
    ada.eta = eta;
    ada.num_weights = num_weights;
    ada.weights = (double *)malloc(num_weights * sizeof(double));
    if (!ada.weights)
    {
        perror(""Unable to allocate error for weights!"");
        return ada;
    }

    // initialize with random weights in the range [-50, 49]
    for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;
    // ada.weights[i] = (double)(rand() % 100) - 50);

    return ada;
}"
delete_adaline,struct adaline *ada,,null,"void delete_adaline(struct adaline *ada)
{
    if (ada == NULL)
        return;

    free(ada->weights);
}"
adaline_activation,double x,,x > 0 ? 1 : -1,int adaline_activation(double x) { return x > 0 ? 1 : -1; }
adaline_get_weights_str,const struct adaline *ada,,out,"char *adaline_get_weights_str(const struct adaline *ada)
{
    static char out[100];  // static so the value is persistent

    sprintf(out, ""<"");
    for (int i = 0; i < ada->num_weights; i++)
    {
        sprintf(out, ""%s%.4g"", out, ada->weights[i]);
        if (i < ada->num_weights - 1)
            sprintf(out, ""%s, "", out);
    }
    sprintf(out, ""%s>"", out);
    return out;
}"
adaline_predict,"struct adaline *ada, const double *x, double *out",,adaline_activation(y),"int adaline_predict(struct adaline *ada, const double *x, double *out)
{
    double y = ada->weights[ada->num_weights - 1];  // assign bias value

    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];

    if (out)  // if out variable is not NULL
        *out = y;

    // quantizer: apply ADALINE threshold function
    return adaline_activation(y);
}"
adaline_fit_sample,"struct adaline *ada, const double *x, const int y",,correction_factor,"double adaline_fit_sample(struct adaline *ada, const double *x, const int y)
{
    /* output of the model with current weights */
    int p = adaline_predict(ada, x, NULL);
    int prediction_error = y - p;  // error in estimation
    double correction_factor = ada->eta * prediction_error;

    /* update each weight, the last weight is the bias term */
    for (int i = 0; i < ada->num_weights - 1; i++)
    {
        ada->weights[i] += correction_factor * x[i];
    }
    ada->weights[ada->num_weights - 1] += correction_factor;  // update bias

    return correction_factor;
}"
adaline_fit,"struct adaline *ada, double **X, const int *y, const int N",,null,"void adaline_fit(struct adaline *ada, double **X, const int *y, const int N)
{
    double avg_pred_error = 1.f;

    int iter;
    for (iter = 0;
         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);
         iter++)
    {
        avg_pred_error = 0.f;

        // perform fit for each sample
        for (int i = 0; i < N; i++)
        {
            double err = adaline_fit_sample(ada, X[i], y[i]);
            avg_pred_error += fabs(err);
        }
        avg_pred_error /= N;

        // Print updates every 200th iteration
        // if (iter % 100 == 0)
        printf(""\tIter %3d: Training weights: %s\tAvg error: %.4f\n"", iter,
               adaline_get_weights_str(ada), avg_pred_error);
    }

    if (iter < MAX_ADALINE_ITER)
        printf(""Converged after %d iterations.\n"", iter);
    else
        printf(""Did not converged after %d iterations.\n"", iter);
}"
test1,double eta,,null,"void test1(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 10;  // number of sample points
    const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},
                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},
                                   {-9, 2}, {-10, -15}};

    double **X = (double **)malloc(N * sizeof(double *));
    const int Y[10] = {1,  -1, 1, -1, -1,
                       -1, 1,  1, 1,  -1};  // corresponding y-values
    for (int i = 0; i < N; i++)
    {
        X[i] = (double *)saved_X[i];
    }

    printf(""------- Test 1 -------\n"");
    printf(""Model before fit: %s\n"", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf(""Model after fit: %s\n"", adaline_get_weights_str(&ada));

    double test_x[] = {5, -3};
    int pred = adaline_predict(&ada, test_x, NULL);
    printf(""Predict for x=(5,-3): % d\n"", pred);
    assert(pred == -1);
    printf("" ...passed\n"");

    double test_x2[] = {5, 8};
    pred = adaline_predict(&ada, test_x2, NULL);
    printf(""Predict for x=(5, 8): % d\n"", pred);
    assert(pred == 1);
    printf("" ...passed\n"");

    // for (int i = 0; i < N; i++)
    //     free(X[i]);
    free(X);
    delete_adaline(&ada);
}"
test2,double eta,,null,"void test2(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 500;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;
    }

    printf(""------- Test 2 -------\n"");
    printf(""Model before fit: %s\n"", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf(""Model after fit: %s\n"", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[2];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;

        test_x[0] = x0;
        test_x[1] = x1;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf(""Predict for x=(% 3.2f,% 3.2f): % d\n"", x0, x1, pred);

        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;
        assert(pred == expected_val);
        printf("" ...passed\n"");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}"
test3,double eta,,null,"void test3(double eta)
{
    struct adaline ada = new_adaline(6, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 200;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        X[i][2] = x2;
        X[i][3] = x0 * x0;
        X[i][4] = x1 * x1;
        X[i][5] = x2 * x2;
        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
    }

    printf(""------- Test 3 -------\n"");
    printf(""Model before fit: %s\n"", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf(""Model after fit: %s\n"", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[6];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        test_x[0] = x0;
        test_x[1] = x1;
        test_x[2] = x2;
        test_x[3] = x0 * x0;
        test_x[4] = x1 * x1;
        test_x[5] = x2 * x2;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf(""Predict for x=(% 3.2f,% 3.2f): % d\n"", x0, x1, pred);

        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
        assert(pred == expected_val);
        printf("" ...passed\n"");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    srand(time(NULL));  // initialize random number generator

    double eta = 0.1;  // default value of eta
    if (argc == 2)     // read eta value from commandline argument if present
        eta = strtof(argv[1], NULL);

    test1(eta);

    printf(""Press ENTER to continue...\n"");
    getchar();

    test2(eta);

    printf(""Press ENTER to continue...\n"");
    getchar();

    test3(eta);

    return 0;
}"
_random,"double a, double b",,((b - a) * r / 100.f) + a,"double _random(double a, double b)
{
    int r = rand() % 100;
    return ((b - a) * r / 100.f) + a;
}"
save_nd_data,"const char *fname, double **X, int num_points, int num_features",,-1 | 0,"int save_nd_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, ""wt"");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, ""File error (%s): "", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, ""%.4g"", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fprintf(fp, "","");          // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fprintf(fp, ""\n"");   // start a new line
    }
    fclose(fp);
    return 0;
}"
kohonen_get_min_1d,"double const *X, int N, double *val, int *idx",,null,"void kohonen_get_min_1d(double const *X, int N, double *val, int *idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // check each value
    {
        if (X[i] < val[0])  // if a lower value is found
        {                   // save the value and its index
            idx[0] = i;
            val[0] = X[i];
        }
    }
}"
kohonen_update_weights,"double const *x, double *const *W, double *D, int num_out, int num_features, double alpha, int R",,null,"void kohonen_update_weights(double const *x, double *const *W, double *D,
                            int num_out, int num_features, double alpha, int R)
{
    int j, k;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each output point
    for (j = 0; j < num_out; j++)
    {
        D[j] = 0.f;
        // compute Euclidian distance of each output
        // point from the current sample
        for (k = 0; k < num_features; k++)
            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_idx;
    double d_min;
    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);

    // step 3a: get the neighborhood range
    int from_node = max(0, d_min_idx - R);
    int to_node = min(num_out, d_min_idx + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (j = from_node; j < to_node; j++)
        for (k = 0; k < num_features; k++)
            // update weights of nodes in the neighborhood
            W[j][k] += alpha * (x[k] - W[j][k]);
}"
kohonen_som_tracer,"double **X, double *const *W, int num_samples, int num_features, int num_out, double alpha_min",,null,"void kohonen_som_tracer(double **X, double *const *W, int num_samples,
                        int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double alpha = 1.f;
    double *D = (double *)malloc(num_out * sizeof(double));

    // Loop alpha from 1 to alpha_min
    for (; alpha > alpha_min; alpha -= 0.01, iter++)
    {
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            const double *x = X[sample];
            // update weights for the current input pattern sample
            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);
        }

        // every 10th iteration, reduce the neighborhood range
        if (iter % 10 == 0 && R > 1)
            R--;
    }

    free(D);
}"
test_circle,"double *const *data, int N",,null,"void test_circle(double *const *data, int N)
{
    const double R = 0.75, dr = 0.3;
    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi
    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double r = _random(a_r, b_r);      // random radius
        double theta = _random(a_t, b_t);  // random theta
        data[i][0] = r * cos(theta);       // convert from polar to cartesian
        data[i][1] = r * sin(theta);
    }
}"
test1,,,null,"void test1()
{
    int j, N = 500;
    int features = 2;
    int num_out = 50;

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // number of clusters nodes * 2
    double **W = (double **)malloc(num_out * sizeof(double *));

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));
#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_circle(X, N);  // create test data around circumference of a circle
    save_nd_data(""test1.csv"", X, N, features);  // save test data points
    save_nd_data(""w11.csv"", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.1);  // train the SOM
    save_nd_data(""w12.csv"", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
}"
test_lamniscate,"double *const *data, int N",,null,"void test_lamniscate(double *const *data, int N)
{
    const double dr = 0.2;
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double dx = _random(-dr, dr);     // random change in x
        double dy = _random(-dr, dr);     // random change in y
        double theta = _random(0, M_PI);  // random theta
        data[i][0] = dx + cos(theta);     // convert from polar to cartesian
        data[i][1] = dy + sin(2. * theta) / 2.f;
    }
}"
test2,,,null,"void test2()
{
    int j, N = 500;
    int features = 2;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_lamniscate(X, N);  // create test data around the lamniscate
    save_nd_data(""test2.csv"", X, N, features);  // save test data points
    save_nd_data(""w21.csv"", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data(""w22.csv"", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}"
test_3d_classes,"double *const *data, int N",,null,"void test_3d_classes(double *const *data, int N)
{
    const double R = 0.1;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}"
test3,,,null,"void test3()
{
    int j, N = 200;
    int features = 3;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_3d_classes(X, N);  // create test data around the lamniscate
    save_nd_data(""test3.csv"", X, N, features);  // save test data points
    save_nd_data(""w31.csv"", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data(""w32.csv"", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}"
get_clock_diff,"clock_t start_t, clock_t end_t",,(double)(end_t - start_t) / (double)CLOCKS_PER_SEC,"double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf(""Using OpenMP based parallelization\n"");
#else
    printf(""NOT using OpenMP based parallelization\n"");
#endif
    clock_t start_clk = clock();
    test1();
    clock_t end_clk = clock();
    printf(""Test 1 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test2();
    end_clk = clock();
    printf(""Test 2 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test3();
    end_clk = clock();
    printf(""Test 3 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));
    printf(
        ""(Note: Calculated times include: creating test sets, training ""
        ""model and writing files to disk.)\n\n"");
    return 0;
}"
kohonen_data_3d,"const struct kohonen_array_3d *arr, int x, int y, int z",,arr->data + offset,"double *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)
{
    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;
    return arr->data + offset;
}"
_random,"double a, double b",,((b - a) * (rand() % 100) / 100.f) + a,"double _random(double a, double b)
{
    return ((b - a) * (rand() % 100) / 100.f) + a;
}"
save_2d_data,"const char *fname, double **X, int num_points, int num_features",,-1 | 0,"int save_2d_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, ""wt"");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, ""File error (%s): "", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, ""%.4g"", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fputc(',', fp);            // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fputc('\n', fp);     // start a new line
    }
    fclose(fp);
    return 0;
}"
save_u_matrix,"const char *fname, struct kohonen_array_3d *W",,-1 | 0,"int save_u_matrix(const char *fname, struct kohonen_array_3d *W)
{
    FILE *fp = fopen(fname, ""wt"");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, ""File error (%s): "", fname);
        perror(msg);
        return -1;
    }

    int R = max(W->dim1 >> 3, 2); /* neighborhood range */

    for (int i = 0; i < W->dim1; i++)  // for each x
    {
        for (int j = 0; j < W->dim2; j++)  // for each y
        {
            double distance = 0.f;
            int k;

            int from_x = max(0, i - R);
            int to_x = min(W->dim1, i + R + 1);
            int from_y = max(0, j - R);
            int to_y = min(W->dim2, j + R + 1);
            int l;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : distance)
#endif
            for (l = from_x; l < to_x; l++)  // scan neighborhoor in x
            {
                for (int m = from_y; m < to_y; m++)  // scan neighborhood in y
                {
                    double d = 0.f;
                    for (k = 0; k < W->dim3; k++)  // for each feature
                    {
                        double *w1 = kohonen_data_3d(W, i, j, k);
                        double *w2 = kohonen_data_3d(W, l, m, k);
                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);
                        // distance += w1[0] * w1[0];
                    }
                    distance += sqrt(d);
                    // distance += d;
                }
            }

            distance /= R * R;              // mean distance from neighbors
            fprintf(fp, ""%.4g"", distance);  // print the mean separation
            if (j < W->dim2 - 1)            // if not the last column
                fputc(',', fp);             // suffix comma
        }
        if (i < W->dim1 - 1)  // if not the last row
            fputc('\n', fp);  // start a new line
    }
    fclose(fp);
    return 0;
}"
get_min_2d,"double **X, int N, double *val, int *x_idx, int *y_idx",,null,"void get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // traverse each x-index
    {
        for (int j = 0; j < N; j++)  // traverse each y-index
        {
            if (X[i][j] < val[0])  // if a lower value is found
            {                      // save the value and its index
                x_idx[0] = i;
                y_idx[0] = j;
                val[0] = X[i][j];
            }
        }
    }
}"
kohonen_update_weights,"const double *X, struct kohonen_array_3d *W, double **D, int num_out, int num_features, double alpha, int R",,d_min,"double kohonen_update_weights(const double *X, struct kohonen_array_3d *W,
                              double **D, int num_out, int num_features,
                              double alpha, int R)
{
    int x, y, k;
    double d_min = 0.f;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each 2D output point
    for (x = 0; x < num_out; x++)
    {
        for (y = 0; y < num_out; y++)
        {
            D[x][y] = 0.f;
            // compute Euclidian distance of each output
            // point from the current sample
            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);
            }
            D[x][y] = sqrt(D[x][y]);
        }
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_x, d_min_y;
    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);

    // step 3a: get the neighborhood range
    int from_x = max(0, d_min_x - R);
    int to_x = min(num_out, d_min_x + R + 1);
    int from_y = max(0, d_min_y - R);
    int to_y = min(num_out, d_min_y + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (x = from_x; x < to_x; x++)
    {
        for (y = from_y; y < to_y; y++)
        {
            /* you can enable the following normalization if needed.
               personally, I found it detrimental to convergence */
            // const double s2pi = sqrt(2.f * M_PI);
            // double normalize = 1.f / (alpha * s2pi);

            /* apply scaling inversely proportional to distance from the
               current node */
            double d2 =
                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);
            double scale_factor = exp(-d2 / (2.f * alpha * alpha));

            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                // update weights of nodes in the neighborhood
                w[0] += alpha * scale_factor * (X[k] - w[0]);
            }
        }
    }
    return d_min;
}"
kohonen_som,"double **X, struct kohonen_array_3d *W, int num_samples, int num_features, int num_out, double alpha_min",,null,"void kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,
                 int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double **D = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < num_out; i++)
        D[i] = (double *)malloc(num_out * sizeof(double));

    double dmin = 1.f;  // average minimum distance of all samples

    // Loop alpha from 1 to slpha_min
    for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;
         alpha -= 0.001, iter++)
    {
        dmin = 0.f;
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            // update weights for the current input pattern sample
            dmin += kohonen_update_weights(X[sample], W, D, num_out,
                                           num_features, alpha, R);
        }

        // every 20th iteration, reduce the neighborhood range
        if (iter % 100 == 0 && R > 1)
            R--;

        dmin /= num_samples;
        printf(""iter: %5d\t alpha: %.4g\t R: %d\td_min: %.4g\r"", iter, alpha, R,
               dmin);
    }
    putchar('\n');

    for (int i = 0; i < num_out; i++) free(D[i]);
    free(D);
}"
test_2d_classes,"double *const *data, int N",,null,"void test_2d_classes(double *const *data, int N)
{
    const double R = 0.3;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][2] = {
        // centres of each class cluster
        {.5, .5},   // centre of class 1
        {.5, -.5},  // centre of class 2
        {-.5, .5},  // centre of class 3
        {-.5, -.5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);

        /* The follosing can also be used
        for (int j = 0; j < 2; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}"
test1,,,null,"void test1()
{
    int j, N = 300;
    int features = 2;
    int num_out = 30;  // image size - N x N

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_2d_classes(X, N);  // create test data around circumference of a circle
    save_2d_data(""test1.csv"", X, N, features);  // save test data points
    save_u_matrix(""w11.csv"", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix(""w12.csv"", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}"
test_3d_classes1,"double *const *data, int N",,null,"void test_3d_classes1(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}"
test2,,,null,"void test2()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;  // image size - N x N

    // 3D space, hence size = number of rows * 3
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++)
                {  // preallocate with random initial weights
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes1(X, N);                     // create test data
    save_2d_data(""test2.csv"", X, N, features);  // save test data points
    save_u_matrix(""w21.csv"", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix(""w22.csv"", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}"
test_3d_classes2,"double *const *data, int N",,null,"void test_3d_classes2(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 8;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, .5, -.5},   // centre of class 2
        {.5, -.5, .5},   // centre of class 3
        {.5, -.5, -.5},  // centre of class 4
        {-.5, .5, .5},   // centre of class 5
        {-.5, .5, -.5},  // centre of class 6
        {-.5, -.5, .5},  // centre of class 7
        {-.5, -.5, -.5}  // centre of class 8
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}"
test3,,,null,"void test3()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes2(X, N);  // create test data around the lamniscate
    save_2d_data(""test3.csv"", X, N, features);  // save test data points
    save_u_matrix(""w31.csv"", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 0.01);  // train the SOM
    save_u_matrix(""w32.csv"", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}"
get_clock_diff,"clock_t start_t, clock_t end_t",,(double)(end_t - start_t) / (double)CLOCKS_PER_SEC,"double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf(""Using OpenMP based parallelization\n"");
#else
    printf(""NOT using OpenMP based parallelization\n"");
#endif
    clock_t start_clk, end_clk;

    start_clk = clock();
    test1();
    end_clk = clock();
    printf(""Test 1 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test2();
    end_clk = clock();
    printf(""Test 2 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test3();
    end_clk = clock();
    printf(""Test 3 completed in %.4g sec\n"",
           get_clock_diff(start_clk, end_clk));

    printf(""(Note: Calculated times include: writing files to disk.)\n\n"");
    return 0;
}"
modular_multiplicative_inverse,"unsigned int a, unsigned int m",,0 | x[1],"int modular_multiplicative_inverse(unsigned int a, unsigned int m)
{
    int x[2] = {1, 0};
    div_t div_result;

    if (m == 0) {
        return 0;
    }
    a %= m;
    if (a == 0) {
        return 0;
    }

    div_result.rem = a;

    while (div_result.rem > 0)
    {
        div_result = div(m, a);

        m = a;
        a = div_result.rem;

        // Calculate value of x for this iteration
        int next = x[1] - (x[0] * div_result.quot);

        x[1] = x[0];
        x[0] = next;
    }

    return x[1];
}"
inverse_key,affine_key_t key,,inverse,"affine_key_t inverse_key(affine_key_t key)
{
    affine_key_t inverse;

    inverse.a = modular_multiplicative_inverse(key.a, ALPHABET_SIZE);

    // Turn negative results positive
    inverse.a += ALPHABET_SIZE;
    inverse.a %= ALPHABET_SIZE;

    inverse.b = -(key.b % ALPHABET_SIZE) + ALPHABET_SIZE;

    return inverse;
}"
affine_encrypt,"char *s, affine_key_t key",,null,"void affine_encrypt(char *s, affine_key_t key)
{
    for (int i = 0; s[i] != '\0'; i++)
    {
        int c = (int)s[i] - Z95_CONVERSION_CONSTANT;

        c *= key.a;
        c += key.b;
        c %= ALPHABET_SIZE;

        s[i] = (char)(c + Z95_CONVERSION_CONSTANT);
    }
}"
affine_decrypt,"char *s, affine_key_t key",,null,"void affine_decrypt(char *s, affine_key_t key)
{
    affine_key_t inverse = inverse_key(key);

    for (int i = 0; s[i] != '\0'; i++)
    {
        int c = (int)s[i] - Z95_CONVERSION_CONSTANT;

        c += inverse.b;
        c *= inverse.a;
        c %= ALPHABET_SIZE;

        s[i] = (char)(c + Z95_CONVERSION_CONSTANT);
    }
}"
test_string,"const char *s, const char *ciphertext, int a, int b",,null,"void test_string(const char *s, const char *ciphertext, int a, int b)
{
    char *copy = malloc((strlen(s) + 1) * sizeof(char));
    strcpy(copy, s);

    affine_key_t key = {a, b};

    affine_encrypt(copy, key);
    assert(strcmp(copy, ciphertext) == 0);  // assert that the encryption worked

    affine_decrypt(copy, key);
    assert(strcmp(copy, s) ==
           0);  // assert that we got the same string we started with

    free(copy);
}"
tests,,,null,"static void tests()
{
    test_string(""Hello!"", ""&3ddy2"", 7, 11);
    test_string(""TheAlgorithms/C"", ""DNC}=jHS2zN!7;E"", 67, 67);
    test_string(""0123456789"", ""840,($ {ws"", 91, 88);
    test_string(""7W@;cdeRT9uL"", ""JDfa*we?z&bL"", 77, 76);
    test_string(""~Qr%^-+++$leM"", ""r'qC0$sss;Ahf"", 8, 90);
    test_string(""The quick brown fox jumps over the lazy dog"",
                ""K7: .*6<4 =-0(1 90' 5*2/, 0):- +7: 3>%& ;08"", 94, 0);
    test_string(
        ""One-1, Two-2, Three-3, Four-4, Five-5, Six-6, Seven-7, Eight-8, ""
        ""Nine-9, Ten-10"",
        ""H&60>\\2*uY0q\\2*p4660E\\2XYn40x\\2XDB60L\\2VDI0 ""
        ""\\2V6B6&0S\\2%D=p;0'\\2tD&60Z\\2*6&0>j"",
        51, 18);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    tests();
    return 0;
}"
rot13,char *s,,null,"void rot13(char *s) {
    for (int i = 0; s[i]; i++) {
        if (s[i] >= 'A' && s[i] <= 'Z') {
            s[i] = 'A' + ((s[i] - 'A' + 13) % 26);
        } else if (s[i] >= 'a' && s[i] <= 'z') {
            s[i] = 'a' + ((s[i] - 'a' + 13) % 26);
        }
    } 
}"
test,,,null,"static void test() {
    char test_01[] = ""The more I C, the less I see."";
    rot13(test_01);
    assert(strcmp(test_01, ""Gur zber V P, gur yrff V frr."") == 0);

    char test_02[] = ""Which witch switched the Swiss wristwatches?"";
    rot13(test_02);
    assert(strcmp(test_02, ""Juvpu jvgpu fjvgpurq gur Fjvff jevfgjngpurf?"") == 0);

    char test_03[] = ""Juvpu jvgpu fjvgpurq gur Fjvff jevfgjngpurf?"";
    rot13(test_03);
    assert(strcmp(test_03, ""Which witch switched the Swiss wristwatches?"") == 0);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main() {
    test();  // run self-test implementations
    return 0;
}"
is_palindromic,unsigned int n,,reversed == n,"int is_palindromic(unsigned int n)
{
    unsigned int reversed = 0, t = n;

    while (t > 0)
    {
        reversed = 10 * reversed + (t % 10);
        t /= 10;
    }
    return reversed == n;
}"
main,,,0,"int main(void)
{
    unsigned int i, j, max = 0;
    for (i = 100; i <= 999; i++)
    {
        for (j = 100; j <= 999; j++)
        {
            unsigned int p = i * j;
            if (is_palindromic(p) && p > max)
            {
                max = p;
            }
        }
    }
    printf(""%u\n"", max);
    return 0;
}"
is_in,"uint64_t N, uint64_t *D, uint64_t L",,1 | 0,"char is_in(uint64_t N, uint64_t *D, uint64_t L)
{
    uint64_t i;
    for (i = 0; i < L; i++)
    {
        if (D[i] == N)
        {
            return 1;
        }
    }
    return 0;
}"
get_divisors,"uint64_t N, uint64_t *D",,1 | num,"uint64_t get_divisors(uint64_t N, uint64_t *D)
{
    uint64_t q, r;
    int64_t i, num = 0;

    if (N == 1)
    {
        D[0] = 1;
        return 1;
    }

    // search till sqrt(N)
    // because after this, the pair of divisors will repeat themselves
    for (i = 1; i * i <= N + 1; i++)
    {
        r = N % i;  // get reminder

        // reminder = 0 if 'i' is a divisor of 'N'
        if (r == 0)
        {
            q = N / i;
            if (!is_in(i, D, num))  // if divisor was already stored
            {
                D[num] = i;
                num++;
            }
            if (!is_in(q, D, num))  // if divisor was already stored
            {
                D[num] = q;
                num++;
            }
        }

        if (num == MAX_LENGTH)
        {  // limit of array reached, allocate more space
            D = (uint64_t *)realloc(D, MAX_LENGTH * sizeof(uint64_t) << 1);
        }
    }
    return num;
}"
sigma2,uint64_t N,,sum % MOD_LIMIT,"uint64_t sigma2(uint64_t N)
{
    uint64_t sum = 0, L;
    int64_t i;
    uint64_t *D = (uint64_t *)malloc(MAX_LENGTH * sizeof(uint64_t));

    L = get_divisors(N, D);
    for (i = 1; i < L; i++)
    {
        uint64_t DD = (D[i] * D[i]) % MOD_LIMIT;
        sum += DD;
    }

    free(D);
    return sum % MOD_LIMIT;
}"
sigma,uint64_t N,,sum % MOD_LIMIT,"uint64_t sigma(uint64_t N)
{
    uint64_t s, sum = 0;
    int64_t i;

#ifdef _OPENMP
// parallelize on threads
#pragma omp parallel for reduction(+ : sum)
#endif
    for (i = 0; i <= N; i++)
    {
        s = sigma2(i);
        sum += s;
    }
    return sum % MOD_LIMIT;
}"
main,"int argc, char **argv",,-1 | 0,"int main(int argc, char **argv)
{
    uint64_t N = 1000;

    if (argc == 2)
    {
        N = strtoll(argv[1], NULL, 10);
    }
    else if (argc > 2)
    {
        fprintf(stderr, ""Wrong number of input arguments!\n"");
        printf(""Usage:\t ./sol1.c [N=1000]"");
        return -1;
    }

    clock_t start_time = clock();
    uint64_t result = sigma(N);
    double dtime = clock() - start_time;

    printf(""N = %"" PRIu64 ""\nSum: %"" PRIu64 ""\n"", N, result);
    printf(""Time taken: %.4gms\n"", dtime * 1e3 / CLOCKS_PER_SEC);

    return 0;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    long long max_len = 0, max_len_num = 0;
    long long MAX_NUM = 1000000;

    if (argc ==
        2) /* set commandline argumnet as the maximum iteration number */
    {
        MAX_NUM = atoll(argv[1]);
        printf(""Maximum number: %lld\n"", MAX_NUM);
    }

    long long i;
#ifdef _OPENMP
#pragma omp parallel for shared(max_len, max_len_num) schedule(guided)
#endif
    for (i = 1; i < MAX_NUM; i++)
    {
        long long L = collatz(i);
        if (L > max_len)
        {
            max_len = L;     /* length of sequence */
            max_len_num = i; /* starting number */
        }

#if defined(_OPENMP) && defined(DEBUG)
        printf(""Thread: %2d\t %3lld: \t%5lld\n"", omp_get_thread_num(), i, L);
#elif defined(DEBUG)
        printf(""%3lld: \t%5lld\n"", i, L);
#endif
    }

    printf(""Start: %3lld: \tLength: %5lld\n"", max_len_num, max_len);

    return 0;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    int N = 20;

    if (argc == 2)
        N = atoi(argv[1]);

    printf(""Number of ways to traverse diagonal of %dx%d grid = %llu\n"", N, N,
           number_of_paths(N));

    return 0;
}"
get_number,"FILE *fp, char *buffer, uint8_t *out_int",,-1 | 0,"int get_number(FILE *fp, char *buffer, uint8_t *out_int)
{
    long l = fscanf(fp, ""%s\n"", buffer);
    if (!l)
    {
        perror(""Error reading line."");
        return -1;
    }
    // printf(""Number: %s\t length: %ld, %ld\n"", buffer, strlen(buffer), l);

    long L = strlen(buffer);

    for (int i = 0; i < L; i++)
    {
        if (buffer[i] < 0x30 || buffer[i] > 0x39)
        {
            perror(""found inavlid character in the number!"");
            return -1;
        }
        else
        {
            out_int[L - i - 1] = buffer[i] - 0x30;
        }
    }

    return 0;
}"
add_numbers,"uint8_t *a, uint8_t *b, uint8_t N",,0,"int add_numbers(uint8_t *a, uint8_t *b, uint8_t N)
{
    int carry = 0;
    uint8_t *c = b; /* accumulate the result in the array 'b' */

    for (int i = 0; i < N; i++)
    {
        // printf(""\t%d + %d + %d "", a[i], b[i], carry);
        c[i] = carry + a[i] + b[i];  // NOLINT // This is a known false-positive
        if (c[i] > 9)                /* check for carry */
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf(""= %d, %d\n"", carry, c[i]);
    }

    for (int i = N; i < N + 10; i++)
    {
        if (carry == 0)
        {
            break;
        }
        // printf(""\t0 + %d + %d "", b[i], carry);
        c[i] = carry + c[i];
        if (c[i] > 9)
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf(""= %d, %d\n"", carry, c[i]);
    }
    return 0;
}"
print_number,"uint8_t *number, uint8_t N, int8_t num_digits_to_print",,-1 | 0,"int print_number(uint8_t *number, uint8_t N, int8_t num_digits_to_print)
{
    uint8_t start_pos = N - 1;
    uint8_t end_pos;

    /* skip all initial zeros */
    while (number[start_pos] == 0) start_pos--;

    /* if end_pos < 0, print all digits */
    if (num_digits_to_print < 0)
    {
        end_pos = 0;
    }
    else if (num_digits_to_print <= start_pos)
    {
        end_pos = start_pos - num_digits_to_print + 1;
    }
    else
    {
        fprintf(stderr, ""invalid number of digits argumet!\n"");
        return -1;
    }

    for (int i = start_pos; i >= end_pos; i--) putchar(number[i] + 0x30);

    putchar('\n');

    return 0;
}"
main,,,-1 | 0,"int main(void)
{
    /* number of digits of the large number */
    const int N = 10;
    /* number of digits in output number */
    const int N2 = N + 10;

    // const char N = 50, N2 = N+10;          /* length of numbers */
    char *txt_buffer =
        (char *)calloc(N + 5, sizeof(char)); /* temporary buffer */
    uint8_t *number = (uint8_t *)calloc(
        N, sizeof(uint8_t)); /* array to store digits of a large number */
    uint8_t *sum = (uint8_t *)calloc(
        N2, sizeof(uint8_t)); /* array to store the sum of the large
numbers. For safety, we make it twice the length of a number. */

    FILE *fp = fopen(""num.txt"", ""rt""); /* open text file to read */
    if (!fp)
    {
        perror(""Unable to open file 'num.txt'."");
        free(txt_buffer);
        free(sum);
        free(number);
        return -1;
    }

    int count = 0;
    get_number(fp, txt_buffer, sum); /* 0 + = first_number = first_number */
    do
    {
        count++;
        if (get_number(fp, txt_buffer, number) != 0)
        {
            break;
        }
        add_numbers(number, sum, N);
    } while (!feof(fp));

    printf(""\nSum   : "");
    print_number(sum, N2, -1);

    printf(""first 10 digits: \t"");
    print_number(sum, N2, 10);

    fclose(fp); /* close file */
    free(txt_buffer);
    free(sum);
    free(number);
    return 0;
}"
main,,,0,"int main(void)
{
    int N = 1000;

    for (int a = 1; a < 300; a++)
    {
        long tmp1 = N * N - 2 * a * N;
        long tmp2 = 2 * (N - a);
        div_t tmp3 = div(tmp1, tmp2);
        int b = tmp3.quot;
        int c = N - a - b;

        if (a * a + b * b == c * c)
        {
            printf(""%d x %d x %d = %ld\n"", a, b, c, (long int)a * b * c);
            return 0;
        }
    }

    return 0;
}"
main,,,0,"int main(void)
{
    for (int a = 1; a < 300; a++)
        for (int b = a + 1; b < 400; b++)
            for (int c = b + 1; c < 500; c++)
            {
                if (a * a + b * b == c * c)
                    if (a + b + c == 1000)
                    {
                        printf(""%d x %d x %d = %ld\n"", a, b, c,
                               (long int)a * b * c);
                        return 0;
                    }
            }

    return 0;
}"
main,,,0,"int main()
{
    int n = 0;
    int sum = 0;
    int i = 1;
    int j = 2;
    int temp;
    scanf(""%d"", &n);

    while (j <= n)
    {
        if ((j & 1) == 0)  // can also use(j%2 == 0)
            sum += j;
        temp = i;
        i = j;
        j = temp + i;
    }

    printf(""%d\n"", sum);
    return 0;
}"
main,,,0,"int main()
{
    int n = 0;
    scanf(""%d"", &n);
    int prime = 1;
    int i = 2;
    while (i * i <= n)
    {
        while (n % i == 0)
        {
            prime = i;
            n /= i;
        }
        i += 1;
    }
    if (n > 1)
        prime = n;
    printf(""%d\n"", prime);
    return 0;
}"
isprime,int no,,1 | 0,"char isprime(int no)
{
    int sq;

    if (no == 2)
    {
        return 1;
    }
    else if (no % 2 == 0)
    {
        return 0;
    }
    sq = ((int)(sqrt(no))) + 1;
    for (int i = 3; i < sq; i += 2)
    {
        if (no % i == 0)
        {
            return 0;
        }
    }
    return 1;
}"
main,,,0,"int main()
{
    int maxNumber = 0;
    int n = 0;
    int n1;
    scanf(""%d"", &n);
    if (isprime(n) == 1)
        printf(""%d"", n);
    else
    {
        while (n % 2 == 0)
        {
            n = n / 2;
        }
        if (isprime(n) == 1)
        {
            printf(""%d\n"", n);
        }
        else
        {
            n1 = ((int)(sqrt(n))) + 1;
            for (int i = 3; i < n1; i += 2)
            {
                if (n % i == 0)
                {
                    if (isprime((int)(n / i)) == 1)
                    {
                        maxNumber = n / i;
                        break;
                    }
                    else if (isprime(i) == 1)
                    {
                        maxNumber = i;
                    }
                }
            }
            printf(""%d\n"", maxNumber);
        }
    }
    return 0;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    unsigned long sum = 0;
    unsigned int MAX_N = 500;
    if (argc == 2)
        MAX_N = atoi(argv[1]);

    /*
     * We use an array of flags to check if a number at the index was:
     * not-processed = 0
     * is amicable = 1
     * not amicable = -1
     */
    char *flags = (char *)calloc(MAX_N, sizeof(char));

    clock_t start_time = clock();
    int i;
    /* there are no such numbers till 10. Lets search from there on */
    for (i = 10; i < MAX_N; i++)
    {
        if (flags[i] != 0)
            /* already processed, skip */
            continue;

        unsigned int b = sum_of_divisors(i);
        if (b >= MAX_N)
            flags[i] = -1;
        else if (flags[b] == -1)
            continue;

        unsigned int c = sum_of_divisors(b);
        if (c == i && b != i)
        {
            /* found amicable */
            flags[b] = 1;
            flags[i] = 1;
            sum += b + i;
#ifdef DEBUG
            printf(""Amicable: %4d : %4d\n"", i, b);
#endif
        }
        else
        {
            flags[i] = -1;
            if (b < MAX_N)
                flags[b] = -1;
        }
    }

    clock_t end_time = clock();

    printf(""\nTime taken: %.4g millisecond\n"",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf(""Sum of all numbers = %lu\n"", sum);

    free(flags);
    return 0;
}"
shell_sort,"char data[][MAX_NAME_LEN], int LEN",,null,"void shell_sort(char data[][MAX_NAME_LEN], int LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    int i, j, g;

    for (g = 0; g < gap_len; g++)
    {
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {
            char tmp_buffer[MAX_NAME_LEN];
            strcpy(tmp_buffer, data[i]);

            for (j = i; j >= gap && strcmp(data[j - gap], tmp_buffer) > 0;
                 j -= gap)
                strcpy(data[j], data[j - gap]);
            strcpy(data[j], tmp_buffer);
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf(""%s\t"", data[i]);
#endif
}"
lazy_sort,"char data[][MAX_NAME_LEN], int LEN",,null,"void lazy_sort(char data[][MAX_NAME_LEN], int LEN)
{
    int i, j;
    for (i = 0; i < LEN; i++)
    {
        for (j = i + 1; j < LEN; j++)
        {
            if (strcmp(data[i], data[j]) > 0)
            {
                char tmp_buffer[MAX_NAME_LEN];
                strcpy(tmp_buffer, data[i]);
                strcpy(data[i], data[j]);
                strcpy(data[j], tmp_buffer);
            }
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf(""%s\t"", data[i]);
#endif
}"
main,"int argc, char **argv",,-1 | 0,"int main(int argc, char **argv)
{
    unsigned long COUNT = 0;
    char *fname = ""names.txt"";
    char names[MAX_NAMES][MAX_NAME_LEN];
    short method = 0; /* sorting algorithm to use. 0 = lazy, 1 = shell-sort */

    if (argc == 2)
        method = atoi(argv[1]);

    FILE *fp = fopen(fname, ""rt"");
    if (!fp)
    {
        perror(""Unable to open file"");
        return -1;
    }

    /*
     * Loops to get total number of rows and columns in the file
     */
    do
    {
        int ret = fscanf(fp, ""\""%[^\"",]\"","", names[COUNT++]);
        if (ret <= 0)
            continue;
        // printf(""%s\t"", names[COUNT - 1]);
    } while (!feof(fp));
    fclose(fp);

    printf(""\nTotal number of names: %lu\n"", COUNT);

    if (method == 0)
    {
        clock_t start_time = clock();
        shell_sort(names, COUNT);
        clock_t end_time = clock();
        printf(""\nShell sort: %.4g millisecond\n"",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }
    else if (method == 1)
    {
        clock_t start_time = clock();
        lazy_sort(names, COUNT);
        clock_t end_time = clock();
        printf(""\nLazy sort: %.4g millisecond\n"",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }

    long sum_score = 0;
    clock_t start_time = clock();
    int i;

#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum_score)
#endif
#ifdef DEBUG
    for (i = 935; i < 940; i++)
#else
    for (i = 0; i < COUNT; i++)
#endif
    {
        long score = 0;
        /* score the alphabets in i^th name */
        for (int j = 0; names[i][j] != '\0'; j++)
            score += names[i][j] - 'A' +
                     1; /* convert ASCII character to integer score */
        sum_score += score * (i + 1);
#ifdef DEBUG
        printf(""Name: %s\tScore: %u x %u = %lu\n"", names[i], score, i + 1,
               (unsigned long)score * (i + 1));
#endif
    }
    clock_t end_time = clock();
    printf(""Scoring time: %.4g millisecond\n"",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);

    printf(""Total Score = %lu\n"", sum_score);

    return 0;
}"
count_divisors,long long n,,num_divisors,"long count_divisors(long long n)
{
    long num_divisors = 0;

    for (long long i = 1; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            num_divisors += 2;
        else if (i * i == n)
            num_divisors += 1;

    return num_divisors;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    int MAX_DIVISORS = 500;
    long i = 1, num_divisors;
    long long triangle_number = 1;

    if (argc == 2)
        MAX_DIVISORS = atoi(argv[1]);

    while (1)
    {
        i++;
        triangle_number += i;
        num_divisors = count_divisors(triangle_number);
        if (num_divisors > MAX_DIVISORS)
            break;
    }

    printf(""First Triangle number with more than %d divisors: %lld\n"",
           MAX_DIVISORS, triangle_number);

    return 0;
}"
main,,,0,"int main(void)
{
    unsigned s1 = 0, s2 = 0, i;
    for (i = 1; i <= 100; i++)
    {
        s1 += i * i;
        s2 += i;
    }
    unsigned ans = s2 * s2 - s1;
    printf(""%u\n"", ans);
    return 0;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    int position = 0, num_bad_chars = 0;
    int num_digits = 4;
    char ch;
    unsigned char num, num_prev;
    unsigned char *buffer = NULL;
    long long int prod = 1, max_prod = 0;

    /* if second command-line argument is given,
     * use it as the number of digits to compute
     * successive product for
     */
    if (argc == 2)
        num_digits = atoi(argv[1]);

    /* allocate memory to store past values */
    buffer = calloc(num_digits, sizeof(unsigned char));
    if (!buffer)
    {
        perror(""Unable to allocate memory for buffer"");
        return -1;
    }

    /* open file to read digits from */
    FILE *fp = fopen(""digits.txt"", ""rt"");
    if (!fp)
    {
        perror(""Unable to open file"");
        free(buffer); /* free allocated memory */
        return -1;
    }

    /* loop through all digits in the file */
    do
    {
        /* get character from file */
        ch = getc(fp);

        /* the ASCII codes of digits is between 0x30 and 0x39.
         * any character not in this range implies an invalid character
         */
        if (ch < 0x30 || ch > 0x39)
        {
            num_bad_chars++; /* this is used to get the bad characters in the
                                sequence of 13 characters */
            continue;
        }
        else if (num_bad_chars > 0)
            num_bad_chars--;

        num = ch - 0x30;      /* convert character digit to number */
        num_prev = buffer[0]; /* previous n^th digit */

        /* left shift the buffer -
         *  using a for loop or a faster memory move
         */
        memmove(buffer, buffer + 1, num_digits - 1);
        /*
        for (int i = 1; i < num_digits; i++)
            buffer[i-1] = buffer[i];
        */

        buffer[num_digits - 1] = num; /* save the latest number in buffer */

        if (num_prev != 0)
        {
            /* since product is accumulated, the new product can be obtained by
             * simply multiplying the new digit and dividing with the oldest
             * digit
             */
            prod /= num_prev; /* divide first to avoid over-flows */
            prod *= num;
        }
        else
        {
            prod = 1;
            for (int i = 0; i < num_digits; i++)
            {
                if (buffer[i] == 0)
                {
                    prod = 0;
                    break; /* break innermost for-loop */
                }
                prod *= buffer[i];
            }
        }

        /* check if a new maxima was found */
        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - num_bad_chars - num_digits - 1;
        }
    } while (!feof(fp)); /* loop till end of file is reached */

    printf(""Maximum product: %lld\t Location: %d^th position\n\t"", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); /* move cursor to identified position in file */
    /* loop through all digits */
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); /* get character */
        /* skip invalid character */
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf(""%c x "", ch);
        else
            printf(""%c = %lld\n"", ch, max_prod);
    }

    fclose(fp);   /* close file */
    free(buffer); /* free allocated memory */

    return 0;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    int position = 0;
    int num_digits = 4;
    long long int prod, max_prod = 0;

    /* if second command-line argument is ge=iven,
     * use it as the number of digits to compute
     * successive product for
     */
    if (argc == 2)
        num_digits = atoi(argv[1]);

    /* open file to read digits from */
    FILE *fp = fopen(""digits.txt"", ""rt"");
    if (!fp)
    {
        perror(""Unable to open file"");
        return -1;
    }

    /* loop through all digits in the file */
    do
    {
        /* get product of 'num_digits' from current position in file */
        prod = get_product(fp, ftell(fp), num_digits);

        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - 1;
        }
    } while (!feof(fp)); /* loop till end of file is reached */

    printf(""Maximum product: %lld\t Location: %d^th position\n\t"", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); /* move cursor to identified position in file */
    /* loop through all digits */
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); /* get character */
        /* skip invalid character */
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf(""%c x "", ch);
        else
            printf(""%c = %lld\n"", ch, max_prod);
    }

    fclose(fp); /* close file */

    return 0;
}"
print_digit,const big_int *my_int,,null,"void print_digit(const big_int *my_int)
{
    printf(""\tValue : %d\n\tNext : %p\n\tPrev : %p\n"", my_int->value,
           my_int->next_digit, my_int->prev_digit);
}"
remove_digits,"big_int *digit, int N",,"0 | remove_digits(digit->next_digit, N - 1) | remove_digits(digit->next_digit, 0)","char remove_digits(big_int *digit, int N)
{
    if (digit == NULL)
        return 0;

    if (digit->next_digit == NULL)
    {
        free(digit);
        digit = NULL;
        return 0;
    }

    if (N > 0)
        return remove_digits(digit->next_digit, N - 1);

    return remove_digits(digit->next_digit, 0);
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    unsigned int N = 5;
    big_int *ptr = add_digit(NULL, 1); /* start with 1 */
    const big_int *ptr0 = ptr;         /* save the first location */
    unsigned long sum_digits = 0;
    unsigned long num_digits = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    clock_t start_time = clock();

    for (unsigned int i = 1; i <= N; i++)
    {
        int carry = 0;
#ifdef DEBUG
        printf(""%3d: "", i);
#endif
        ptr = (big_int *)ptr0; /* multiply every digit with i */
        while (ptr)
        {
#ifdef DEBUG
            printf(""%p\t"", ptr);
#endif
            unsigned int tmp = ptr->value * i + carry;
            if (tmp >= 10)
            {
                div_t tmp2 = div(tmp, 10);
                carry = tmp2.quot;
                tmp = tmp2.rem;
            }
            else
                carry = 0;

            if (carry > 0 && ptr->next_digit == NULL)
                add_digit(ptr, 0);

            ptr->value = tmp;

            if (i == N)
                /*
                 * sum digits on the last iteration
                 * this avoid having another loop over all digits
                 */
                sum_digits += tmp;

            if (ptr->next_digit)
                /* more digits available */
                ptr = ptr->next_digit;
            else
                /* no more digits left - reached MSB */
                break;
        }
#ifdef DEBUG
        printf(""\n"");
#endif
    }

    clock_t end_time = clock();

#ifdef DEBUG
    printf(""ptr = %p\n"", ptr);
    printf(""%d! = "", N);
#endif

    /* Notice that in the loop above, we make sure that at the end of the loop,
     * ptr is pointing to the last digit. Thus we can avoid using another loop.
     */
    // ptr = &my_int;
    // /* move ptr to the MSB digit */
    // while (ptr->next_digit)
    //     ptr = ptr->next_digit;
    do
    {
        putchar(ptr->value + 0x30); /* convert digit to ASCII char */
        ptr = ptr->prev_digit;
        num_digits++;
    } while (ptr); /* after coming to units place, there will be no valid ptr */

    printf(""\nTime taken: %.4g millisecond\n"",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf(
        ""Digit Sum = %lu\tNumber of digits = %lu\tStorage space = %.3gkb\t \n"",
        sum_digits, num_digits, num_digits * sizeof(big_int) / 1024.0);

    remove_digits((big_int *)ptr0, -1);
    return 0;
}"
get_month_days,short month,,28 | 30 | 31,"char get_month_days(short month)
{
    if (month == 1) /* February has 28 days. Adjust leap year in the loop */
        return 28;
    else if (month <= 6) /* odd months till July have 30 days - Jan = 0 (even)*/
    {
        if (month & 0x01)
            return 30;
        else
            return 31;
    }

    // else if (month >= 7) /* odd months after July have 31 days*/

    if (month & 0x01)
        return 31;

    return 30;
}"
is_leap_year,short year,,1 | 0,"char is_leap_year(short year)
{
    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)))
        return 1;

    return 0;
}"
main,"int argc, char **argv",,0,"int main(int argc, char **argv)
{
    int count_sundays = 0;
    const short start_year = 1901;
    const short end_year = 2000;

    /*
     * Let us identify days i.e., Sunday thru Saturday with integers - 0 thru 6
     * respectively Jan 1 1901 was a Tuesday
     */
    char start_day = 2;

    for (int year = start_year; year <= end_year; year++)
    {
        char is_leap = is_leap_year(year);
        for (char month = 0; month < 12; month++)
        {
            /*
             * These two for-loops count the start of day for the next month.
             * Hence, we have to skip the last December count
             */
            if (year == end_year && month == 11)
                continue;

            int days = get_month_days(month);

            if (is_leap && month == 1) /* for a leap year february, add a day */
                days++;

#ifdef DEBUG
            if (year == end_year)
            {
                printf(""Year: %d\t Month: %d\t Days: %d\t First of day: %s\n"",
                       year, month, days, day_string(start_day));
            }
#endif

            /* Main Algorithm:
             * every week has 7 days hence, the start of next day would be
             * modulo 7 add to this, the current start date and ensure the
             * result is still modulo 7!
             */
            start_day = ((days % 7) + start_day) % 7;

            /* If start-day is a Sunday, increment counter */
            if (start_day == 0)
                count_sundays++;
        }
    }

    printf(
        ""Total number of Sundays that happened on the 1st of a month in the ""
        ""last century: %d\n"",
        count_sundays);

    return 0;
}"
compare,"const void *a, const void *b",,(*(unsigned short *)a - *(unsigned short *)b),"int compare(const void *a, const void *b)
{
    return (*(unsigned short *)a - *(unsigned short *)b);
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    unsigned short max_digits = 0, max_idx_number = 0;

    clock_t start_time = clock();
    short deno;
#ifdef _OPENMP
#pragma omp for
#endif
    for (deno = 2; deno < MAX_DENO; deno++)
    {
        unsigned short remainders[MAX_LEN];
        unsigned short rem = 1, *rem_ptr = remainders;
        memset(remainders, (unsigned short)-1,
               MAX_LEN * sizeof(unsigned short));
        // remainders[0] = 1;
        // printf(""1/%-4u\t "", deno);
        unsigned short index = 0, num_digits;

        while (rem != 0)
        {
            rem = (rem * 10) % deno;
            if (rem == 0)
            {
                index = 0;
                break;
            }
            rem_ptr = (unsigned short *)bsearch(
                &rem, remainders, MAX_LEN, sizeof(unsigned short), compare);
            // printf(""%2d, "", rem);
            // printf(""(%14p), "", rem_ptr);
            if (rem_ptr != NULL)
                break;
            remainders[index] = rem;
            rem_ptr = remainders;
            index++;
        }

        num_digits = index - (rem_ptr - remainders);
        // printf(""\n\t(%14p, %14p, %4u, %4u)\n"", rem_ptr, remainders, index,
        // num_digits);
#ifdef _OPENMP
#pragma omp critical
        {
#endif
            if (num_digits > max_digits)
            {
                max_digits = num_digits;
                max_idx_number = deno;
                // printf(""\t (%u, %u)\n "", max_digits, max_idx_number);
            }
#ifdef _OPENMP
        }
#endif
    }
    clock_t end_time = clock();

    printf(""Time taken: %.4g ms\n"",
           1e3 * (double)(end_time - start_time) / CLOCKS_PER_SEC);
    printf(""Maximum digits: %hu\t Denominator: %hu\n"", max_digits,
           max_idx_number);

    return 0;
}"
check_number,unsigned long long n,,0 | 1,"static int check_number(unsigned long long n)
{
    for (size_t i = 0; i < 7; ++i)
    {
        if (n % divisors[i] != 0)
        {
            return 0;
        }
    }

    return 1;
}"
main,,,0,"int main(void)
{
    for (unsigned long long n = 20;; n += 20)
    {
        if (check_number(n))
        {
            printf(""Result: %llu\n"", n);
            break;
        }
    }
    return 0;
}"
check_number,unsigned long long n,,0 | 1,"static char check_number(unsigned long long n)
{
    for (unsigned long long i = 1; i <= 20; ++i)
    {
        if (n % i != 0)
        {
            return 0;
        }
    }

    return 1;
}"
main,,,0,"int main(void)
{
    for (unsigned long long n = 1;; ++n)
    {
        if (check_number(n))
        {
            printf(""Result: %llu\n"", n);
            break;
        }
    }

    return 0;
}"
main,,,0,"int main(void)
{
    unsigned long ans = 1;
    unsigned long i;
    for (i = 1; i <= 20; i++)
    {
        ans = lcm(ans, i);
    }
    printf(""%lu\n"", ans);
    return 0;
}"
print_number,"unsigned char *number, int N",,0,"int print_number(unsigned char *number, int N)
{
    int start_pos = N - 1;

    /* skip all initial zeros */
    while (number[start_pos] == 0) start_pos--;

    for (int i = start_pos; i >= 0; i--) putchar(number[i] + 0x30);

    return 0;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    unsigned char
        fn[MAX_DIGITS + 1]; /* array to store digits of a large number */
    unsigned char fn1[MAX_DIGITS + 1];
    unsigned char sum[MAX_DIGITS + 1];

    memset(fn, 0, MAX_DIGITS);
    memset(fn1, 0, MAX_DIGITS);
    memset(sum, 0, MAX_DIGITS);

    fn[0] = 1;
    fn1[1] = 1;

    unsigned int index = 1, digit_count = 1;

    clock_t start_time = clock();
    do
    {
        digit_count = add_numbers(fn, fn1, sum, digit_count);
        // digit_count = get_digits(sum);

        // printf(""%5u (%u) (%u) "", index, digit_count, get_digits(sum));
        // print_number(sum, digit_count);
        // putchar('\n');

        if (digit_count == MAX_DIGITS)
        {
            break;
        }
        memcpy(fn, fn1, MAX_DIGITS);
        memcpy(fn1, sum, MAX_DIGITS);
        index++;
    } while (digit_count < MAX_DIGITS);
    clock_t end_time = clock();

    printf(""Time taken: %.4g ms\n"",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf(""The nth term for %d digits: %u \n"", MAX_DIGITS, index--);
    print_number(sum, digit_count);

    return 0;
}"
main,"int argc, char *argv[]",,-1 | 0,"int main(int argc, char *argv[])
{
    long n = 100;
    long long sum = 0;
    char *sieve = NULL;

    if (argc == 2)         /* if command line argument is provided */
        n = atol(argv[1]); /* use that as the upper limit */

    /* allocate memory for the sieve */
    sieve = calloc(n, sizeof(*sieve));
    if (!sieve)
    {
        perror(""Unable to allocate memory!"");
        return -1;
    }

    /* build sieve of Eratosthenes
        In the array,
        * if i^th cell is '1', then 'i' is composite
        * if i^th cell is '0', then 'i' is prime
    */
    for (long i = 2; i < sqrtl(n); i++)
    {
        /* if i^th element is prime, mark all its multiples
        as composites */
        if (!sieve[i])
        {
            for (long j = i * i; j < n + 1; j += i)
            {
                sieve[j] = 1;
            }
            sum += i;
        }
    }

    for (long i = sqrtl(n) + 1; i < n; i++)
        if (!sieve[i])
            sum += i;

    free(sieve);

    printf(""%ld: %lld\n"", n, sum);

    return 0;
}"
is_prime,unsigned long n,,0 | 1,"char is_prime(unsigned long n)
{
    for (unsigned long i = 2; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            return 0;

    return 1;
}"
main,"int argc, char *argv[]",,0,"int main(int argc, char *argv[])
{
    unsigned long n = 100;

    if (argc == 2)         /* if command line argument is provided */
        n = atol(argv[1]); /* use that as the upper limit */

    printf(""%ld: %llu\n"", n, sum_of_primes(n));

    return 0;
}"
get_perfect_number,unsigned long N,,ret,"char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
#ifdef DEBUG
    printf(""%5lu: %5lu : %d\n"", N, sum, ret);
#endif
    return ret;
}"
is_abundant,unsigned long N,,"abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0 | abundant_flags[N >> 3] & (1 << (N & 7))
               ? 1
               : 0","char is_abundant(unsigned long N)
{
    // return abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0;
    return abundant_flags[N >> 3] & (1 << (N & 7))
               ? 1
               : 0; /* optimized modulo operation */
}"
is_sum_of_abundant,unsigned long N,return abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0;,1 | 0,"char is_sum_of_abundant(unsigned long N)
{
    /* optimized logic:
     * i + j = N   where both i and j should be abundant
     * hence we can simply check for j = N - i as we loop through i
     */
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf(""\t%4lu + %4lu = %4lu\n"", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}"
main,"int argc, char **argv","check if a given number can be represented as a sum
of two abundant numbers.
\returns 1 - if yes
\returns 0 - if not",-1 | 0,"int main(int argc, char **argv)
{
    long MAX_N = 28123; /* Limit of numbers to check */

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

    /* byte array to store flags to identify abundant numbers
     * the flags are identified by bits
     */
    abundant_flags = (char *)calloc(MAX_N >> 3, 1);
    if (!abundant_flags)
    {
        perror(""Unable to allocate memoey!"");
        return -1;
    }

#ifdef _OPENMP
    printf(""Using OpenMP parallleization with %d threads\n"",
           omp_get_max_threads());
#else
    printf(""Not using parallleization!\n"");
#endif

    clock_t start_time = clock();

    /* Loop to set abundant flags */
    long N;
#ifdef _OPENMP
#pragma omp for schedule(runtime)
#endif
    for (N = 1; N <= MAX_N; N++)
    {
        char ret = get_perfect_number(N);
        if (ret == 1)
        {
            // int byte_offset = N % 8, index = N >> 3;
            int byte_offset = N & 7, index = N >> 3;
#ifdef _OPENMP
#pragma omp critical
#endif
            abundant_flags[index] |= ret << byte_offset;
        }
        // if (i % 100 == 0)
        //     printf(""... %5lu: %8lu\r"", i, sum);
    }

    clock_t end_time = clock();
    double t1 = 1e3 * (end_time - start_time) / CLOCKS_PER_SEC;
    printf(""Time taken to get abundant numbers: %.4g ms\n"", t1);

    clock_t t2 = 0;
    long i;
#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum)
#endif
    for (i = 1; i < MAX_N; i++)
    {
        clock_t start_time1 = clock();
        if (!is_sum_of_abundant(i))
        {
            // #ifdef _OPENMP
            // #pragma omp critical
            // #endif
            sum += i;
        }
        clock_t end_time1 = clock();
#ifdef _OPENMP
#pragma omp critical
#endif
        t2 += end_time1 - start_time1;

        printf(""... %5lu: %8lu\r"", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

#ifdef DEBUG
    putchar('\n');
#endif
    double t22 = 1e3 * t2 / CLOCKS_PER_SEC;
    printf(""Time taken for final sum: %.4g ms\nTotal Time taken: %.4g ms\n"",
           t22, t1 + t22);
    printf(""Memory used: %lu bytes\n"", MAX_N >> 3);
    printf(
        ""Sum of numbers that cannot be represented as sum of two abundant ""
        ""numbers : %lu\n"",
        sum);

    free(abundant_flags);

    return 0;
}"
get_perfect_number,unsigned long N,,ret,"char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
    // #ifdef DEBUG
    //     printf(""%5lu: %5lu : %d\n"", N, sum, ret);
    // #endif
    return ret;
}"
is_sum_of_abundant,unsigned long N,,1 | 0,"char is_sum_of_abundant(unsigned long N)
{
    /* optimized logic:
     * i + j = N   where both i and j should be abundant
     * hence we can simply check for j = N - i as we loop through i
     */
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf(""\t%4lu + %4lu = %4lu\n"", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}"
main,"int argc, char **argv","check if a given number can be represented as a sum
of two abundant numbers.
\returns 1 - if yes
\returns 0 - if not",0,"int main(int argc, char **argv)
{
    unsigned long MAX_N = 28123; /* upper limit of numbers to check */

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

#ifdef _OPENMP
    printf(""Using OpenMP parallleization with %d threads\n"",
           omp_get_max_threads());
#else
    printf(""Not using parallleization!\n"");
#endif

    double total_duration = 0.f;
    long i;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : sum) schedule(runtime)
#endif
    for (i = 1; i <= MAX_N; i++)
    {
        clock_t start_time = clock();
        if (!is_sum_of_abundant(i))
        {
            sum += i;
        }
        clock_t end_time = clock();
        total_duration += (double)(end_time - start_time) / CLOCKS_PER_SEC;

        printf(""... %5lu: %8lu\r"", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

    printf(""Time taken: %.4g s\n"", total_duration);
    printf(
        ""Sum of numbers that cannot be represented as sum of two abundant ""
        ""numbers : %lu\n"",
        sum);

    return 0;
}"
main,,,0,"int main()
{
    int n;
    scanf(""%d"", &n);
    int number_of_prime = 0;
    for (int i = 2;; i++)
    {
        int divisors = 0;
        for (int j = 1; j <= i; j++)
        {
            if (i % j == 0)
            {
                divisors++;
            }
        }
        if (divisors == 2)
        {
            number_of_prime++;
            if (number_of_prime == n)
            {
                printf(""%d"", i);
                break;
            }
        }
    }

    return 0;
}"
main,,,0,"int main(void)
{
    char *sieve;
    size_t i;
    unsigned count = 0;
    size_t n = 1000000;
    const unsigned target = 10001;

    sieve = (char *)calloc(n, sizeof(char));
    for (i = 2; i < n; i++)
    {
        if (!sieve[i])
        {
            size_t j;
            count++;
            if (count == target)
            {
                printf(""%lu\n"", i);
                break;
            }
            for (j = i * 2; j < n; j += i)
            {
                sieve[j] = 1;
            }
        }
    }
    free(sieve);
    return 0;
}"
main,,,,"int main()
{
    int n = 0;
    int sum = 0;
    scanf(""%d"", &n);

    int terms = (n - 1) / 3;
    sum += ((terms) * (6 + (terms - 1) * 3)) / 2;  // sum of an A.P.
    terms = (n - 1) / 5;
    sum += ((terms) * (10 + (terms - 1) * 5)) / 2;
    terms = (n - 1) / 15;
    sum -= ((terms) * (30 + (terms - 1) * 15)) / 2;

    printf(""%d\n"", sum);
}"
main,,,0,"int main()
{
    int t;
    printf(""Enter number of times you want to try"");
    scanf(""%d"", &t);
    while (t--)  // while t > 0, decrement 't' before every iteration
    {
        unsigned long long N, p = 0, sum = 0;
        printf(""Enter the value of N "");

        scanf(""%lld"", &N);  // Take input of N from user
        p = (N - 1) / 3;
        sum = ((3 * p * (p + 1)) / 2);

        p = (N - 1) / 5;
        sum = sum + ((5 * p * (p + 1)) / 2);

        p = (N - 1) / 15;
        sum = sum - ((15 * p * (p + 1)) / 2);
        printf(""%lld\n"", sum);  // print the sum of all numbers that are
                                // multiples of 3 & 5 below N
    }
    return 0;
}"
main,,,0,"int main()
{
    int t;
    printf(""Enter number of times you want to try"");
    scanf(""%d"", &t);
    while (t--)
    {
        unsigned long long N, p = 0, sum = 0;
        printf(""Enter the value of N "");

        scanf(""%lld"", &N);  // Take input of N from user
        for (int i = 0; i < N; i++)
        {
            if (i % 3 == 0 || i % 5 == 0)
            {
                sum = sum + i;
            }
        }
        printf(""%lld\n"", sum);  // print the sum of all numbers that are
                                // multiples of 3 & 5 below N
    }
    return 0;
}"
main,,,0,"int main()
{
    int n = 0;
    int sum = 0;
    int num = 0;
    scanf(""%d"", &n);

    while (1)
    {
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
    }

    printf(""%d\n"", sum);
    return 0;
}"
main,"int argc, char **argv",,-1 | 0,"int main(int argc, char **argv)
{
    const double tmp = log(10) / log(2); /* required to get number of digits */
    unsigned long MAX_NUM_DIGITS;
    uint8_t *digits =
        NULL; /* array to store individual digits. index 0 = units place */
    int N = 1000, sum = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    MAX_NUM_DIGITS = (N + tmp) / tmp;

    digits = calloc(MAX_NUM_DIGITS, sizeof(uint8_t));
    digits[0] = 1;

    if (!digits)
    {
        perror(""Unable to allocate memory!"");
        return -1;
    }

    for (int i = 0; i < N; i++)
    {
        int carry = 0;
        for (int j = 0; j < MAX_NUM_DIGITS; j++)
        {
            digits[j] = (digits[j] << 1) + carry; /* digit * 2 + carry */
            // printf(""\t value: %d\t"", digits[j]);
            if (digits[j] > 9)
            {
                carry = 1;
                digits[j] -= 10;
            }
            else
                carry = 0;
            // printf(""carry: %d\t value: %d\n"", carry, digits[j]);

            /* accumulate sum for last multiplication */
            if (i == N - 1)
                sum += digits[j];
        }
    }

    printf(""2^%d = "", N);
    for (int i = MAX_NUM_DIGITS - 1; i >= 0; i--) putchar(digits[i] + 0x30);
    printf(""\n\t Sum: %d\t Num. digits: %lu\n"", sum, MAX_NUM_DIGITS);

    free(digits);
    return 0;
}"
inList,"const char* filename, int line",,counter | -1,"int inList(const char* filename, int line)
{
	mem_info* tmp = memoryInformation;
	int counter = 0;
	int len = strlen(filename);

	while (tmp)
	{
		if (len == strlen(tmp->fileName))
		{
			if (!memcmp(filename, tmp->fileName, len) && tmp->line == line)
			{
				return counter;
			}
		}
		tmp = tmp->next;
		counter++;
	}
	return -1;
}"
editInfo,"int elemPos, size_t bytes",,null,"void editInfo(int elemPos, size_t bytes)
{
	int counter = 0;
	mem_info* tmp = memoryInformation;

	while (counter != elemPos)
	{
		tmp = tmp->next;
		counter++;
	}
	tmp->bytes += bytes;
}"
malloc_dbg,"size_t bytes, int line, const char* filename, const char* functionName",,NULL | ptrToReturn,"void* malloc_dbg(size_t bytes, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = malloc(bytes);
	int pos = 0;
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	pos = inList(filename, line);
	if (pos == -1)
	{
		// Add a new element in the mem_info list
		memoryInformation = addMemInfo(memoryInformation, ptrToReturn, bytes, line, filename, functionName);
		if (!memoryInformation)
		{
			free(ptrToReturn);
			return NULL;
		}
	}
	else
	{
		editInfo(pos, bytes);
	}
	return ptrToReturn;
}"
calloc_dbg,"size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName",,NULL | ptrToReturn,"void* calloc_dbg(size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = calloc(elementCount, elementSize);
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	// Add a new element in the mem_info list
	memoryInformation = addMemInfo(memoryInformation, ptrToReturn, elementCount * elementSize, line, filename, functionName);
	if (!memoryInformation)
	{
		free(ptrToReturn);
		return NULL;
	}

	return ptrToReturn;
}"
free_dbg,void* ptrToFree,,null,"void free_dbg(void* ptrToFree)
{
	mem_info* tmp = memoryInformation;
	mem_info* toFree = NULL;
	mem_info* previous = NULL;

	// Check if the head contains the pointer to free
	if (tmp->ptr == ptrToFree)
	{
		toFree = tmp;
		memoryInformation = tmp->next;
		free(toFree->ptr);
		free(toFree);
		if (memoryInformation)
		{
			memoryInformation->previous = NULL;
		}
		return;
	}

	// We can loop through the list without any problems, the head is not the pointer
	while (tmp)
	{
		if (tmp->ptr == ptrToFree) // If we found the pointer that must be freed
		{
			toFree = tmp;
			tmp = tmp->next;
			previous = toFree->previous;

			if (previous)
			{
				previous->next = tmp;
			}
			if (tmp)
			{
				tmp->previous = previous;
			}

			free(toFree->ptr);
			if (toFree == memoryInformation)
			{
				memoryInformation = NULL;
			}
			free(toFree);
			return;
		}
		tmp = tmp->next;
	}
}"
printLeaks,,,null,"void printLeaks()
{
	mem_info* tmp = memoryInformation;
	mem_info* previous = NULL;
	size_t sum = 0;
	int nbBlocks = 0;

	if (tmp)
	{
		printf(""Memory Leaks detected.\n"");
	}

	while (tmp)
	{
		previous = tmp;
		printf(""\n%ld bytes lost\n"", tmp->bytes);
		printf(""address : 0x%p in %s\t%s:%d\n"", tmp->ptr, tmp->functionName, tmp->fileName, tmp->line);
		printf(""\n====================================\n"");
		sum += tmp->bytes;
		tmp = tmp->next;
		free(previous);
		nbBlocks++;
	}

	printf(""SUMMARY :\n%ld bytes lost in %d blocks\n"", sum, nbBlocks);
}"
main,,,,"int main()
{
    // print strings using `printf` and `min_printf`
    min_printf("":%d: :%1.6d:\n"", 12, 56);
    printf("":%d: :%1.6d:\n"", 12, 56);

    printf(""\n""); /// Printing an empty new line

    // print floats or doubles using `printf` and `min_printf`
    min_printf("":%f: :%3.6f:\n"", 104.5654, 43.766443332);
    printf("":%f: :%3.6f:\n"", 104.5654, 43.766443332);

    printf(""\n"");

    // print integers `printf` and `min_printf`
    min_printf("":%s: :%4.3s:\n"", ""Hello, World!"", ""Hello, World!"");
    printf("":%s: :%4.3s:\n"", ""Hello, World!"", ""Hello, World!"");

}"
main,"int argc, char* argv[]",,0,"int main(int argc, char* argv[])
{
	int* iptr = malloc(10 * sizeof(int));
	char* cptr = calloc(256, sizeof(char));

	free(iptr);
	// free(cptr);

	return 0;
}"
validEntryLineColumn,"int line, char column",,1 | 0,"int validEntryLineColumn(int line, char column)
{
    if ((line >= 1 && line <= 10) && (column >= 65 && column <= 74))
    {
        return 1;
    }

    return 0;
}"
validatePosition,"int mat[10][10], int boat, int line, int column, char guide",,0 | 1,"int validatePosition(int mat[10][10], int boat, int line, int column,
                     char guide)
{
    int cont = 0;
    int i, j;

    if (line < 0 || line > 9 || column < 0 || column > 9 ||
        (guide != 'H' && guide != 'V') || boat < 1 || boat > 3)
    {
        return 0;
    }

    if (guide == 'H')
    {
        if ((10 - column) < boat)
        {
            return 0;
        }
        else
        {
            for (j = column; j < (column + boat); j++)
            {
                if (mat[line][j] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (guide == 'V')
    {
        if ((10 - line) < boat)
        {
            return 0;
        }

        else
        {
            for (i = line; i < (line + boat); i++)
            {
                if (mat[i][column] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (cont == boat)
    {
        return 1;
    }
    return 0;
}"
canShoot,"int mat[10][10], int line, int column",,0 | 1,"int canShoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == -2 || mat[line][column] == 10 ||
        mat[line][column] == 20 || mat[line][column] == 30 ||
        mat[line][column] == 50)
    {
        return 0;
    }

    return 1;
}"
positionBoat,"int mat[10][10], int boat",,null,"void positionBoat(int mat[10][10], int boat)
{
    int line, j;
    char column, guide;

    if (boat == 1)
    {
        scanf(""%d %c"", &line, &column);

        while (validEntryLineColumn(line, column) != 1 ||
               validatePosition(mat, boat, (line - 1), (column - 65), 'H') != 1)
        {
            printf(""Position unavailable!\n"");
            scanf(""%d %c"", &line, &column);
        }
    }

    else
    {
        scanf(""%d %c %c"", &line, &column, &guide);

        while (validEntryLineColumn(line, column) == 0 ||
               validatePosition(mat, boat, (line - 1), (column - 65), guide) ==
                   0)
        {
            printf(""Position unavailable!\n"");
            scanf(""%d %c %c"", &line, &column, &guide);
        }
    }

    int aux = column - 'A';
    line -= 1;

    if (boat == 1)
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }

        for (int a = line - 1; a < (line + boat + 1); a++)
        {
            for (int b = aux - 1; b < (aux + boat + 1); b++)
            {
                if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                {
                    if (mat[a][b] != boat)
                    {
                        mat[a][b] = -1;
                    }
                }
            }
        }
    }

    if (guide == 'H')
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat - 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }

    if (guide == 'V')
    {
        for (j = line; j < (line + boat); j++)
        {
            mat[j][aux] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat - 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }
}"
printMessage,char *msg,,null,"void printMessage(char *msg)
{
    printf(""************************\n"");
    printf(""*\n"");
    printf(""* %s\n"", msg);
    printf(""*\n"");
    printf(""************************\n"");
}"
printMessageScore,"int pts1, int pts2",,null,"void printMessageScore(int pts1, int pts2)
{
    printf(""************************\n"");
    printf(""*\n"");
    printf(""* Player'S SCORE 1: %02d\n"", pts1);
    printf(""* Player'S SCORE 2: %02d\n"", pts2);
    printf(""*\n"");
    printf(""************************\n"");
}"
printTable,"int logic, int stage",,'.' | '*' | '1' | '2' | '3' | 'x' | 'N' | 'A',"char printTable(int logic, int stage)
{
    if (stage == 0)
    {
        if (logic == 0)
        {
            return '.';
        }

        else if (logic == -1)
        {
            return '*';
        }

        else if (logic == 1)
        {
            return '1';
        }

        else if (logic == 2)
        {
            return '2';
        }

        else
        {
            return '3';
        }
    }

    else
    {
        if (logic == 0 || logic == -1 || logic == 1 || logic == 2 || logic == 3)
        {
            return '.';
        }

        else if (logic == -2)
        {
            return 'x';
        }

        else if (logic == 10 || logic == 20 || logic == 30)
        {
            return 'N';
        }

        else
        {
            return 'A';
        }
    }
}"
printsTray,"int mat[10][10], int stage",,null,"void printsTray(int mat[10][10], int stage)
{
    int logic;
    char imp;

    printf(""     "");
    for (int i = 65; i < 75; i++)
    {
        printf(""%c"", i);
        if (i < 74)
        {
            printf("" "");
        }
    }
    printf(""\n"");

    for (int i = 0; i < 12; i++)
    {
        if (i > 0 && i < 11)
        {
            printf(""%02d "", i);
        }

        else
        {
            printf(""   "");
        }

        for (int j = 0; j < 12; j++)
        {
            if ((i > 0 && i < 11) && (j > 0 && j < 11))
            {
                logic = mat[i - 1][j - 1];
                imp = printTable(logic, stage);
                printf(""%c"", imp);
            }
            else
            {
                printf(""#"");
            }

            if (j < 11)
            {
                printf("" "");
            }
        }
        printf(""\n"");
    }
}"
shoot,"int mat[10][10], int line, int column",,null,"void shoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == 0 || mat[line][column] == -1)
    {
        mat[line][column] = -2;
    }

    else if (mat[line][column] == 1)
    {
        mat[line][column] = 10;
    }

    else if (mat[line][column] == 2)
    {
        mat[line][column] = 20;
    }

    else if (mat[line][column] == 3)
    {
        mat[line][column] = 30;
    }
}"
calculateScore,"int mat[10][10], int line, int column",,2 | 4 | 0 | 7,"int calculateScore(int mat[10][10], int line, int column)
{
    int c = 0, b = 0, e = 0, d = 0;

    if (mat[line][column] == 10)
    {
        mat[line][column] = 50;
        return 2;
    }

    else if (mat[line][column] == 20)
    {
        if (mat[line + 1][column] == 20)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 20)
        {
            c = 1;
        }

        if (mat[line][column + 1] == 20)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 20)
        {
            e = 1;
        }

        if (b == 1)
        {
            if (mat[line + 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (c == 1)
        {
            if (mat[line - 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (d == 1)
        {
            if (mat[line][column + 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (e == 1)
        {
            if (mat[line][column - 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }
    }

    else if (mat[line][column] == 30)
    {
        if (mat[line + 1][column] == 30)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 30)
        {
            c = 1;
        }
        if (mat[line][column + 1] == 30)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 30)
        {
            e = 1;
        }

        if (b == 1 && c == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line - 1][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line - 1][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1 && e == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column - 1] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column + 1] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column + 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                mat[line][column + 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (e == 1)
        {
            if (mat[line][column - 1] == 30 && mat[line][column - 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column - 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (c == 1)
        {
            if (mat[line - 1][column] == 30 && mat[line - 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                mat[line - 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (b == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line + 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line + 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }
    }
    return 0;
}"
printPositioning,"int Player, int boat, int nm",,null,"void printPositioning(int Player, int boat, int nm)
{
    if (Player == 1)
    {
        char msg1[60] = ""Player 1 - Position the size boat 1 (1/6)"";
        char msg2[60] = ""Player 1 - Position the size boat 1 (2/6)"";
        char msg3[60] = ""Player 1 - Position the size boat 1 (3/6)"";
        char msg4[60] = ""Player 1 - Position the size boat 1 (4/6)"";
        char msg5[60] = ""Player 1 - Position the size boat 1 (5/6)"";
        char msg6[60] = ""Player 1 - Position the size boat 1 (6/6)"";

        char msg7[60] = ""Player 1 - Position the size boat 2 (1/4)"";
        char msg8[60] = ""Player 1 - Position the size boat 2 (2/4)"";
        char msg9[60] = ""Player 1 - Position the size boat 2 (3/4)"";
        char msg10[60] = ""Player 1 - Position the size boat 2 (4/4)"";

        char msg11[60] = ""Player 1 - Position the size boat 3 (1/2)"";
        char msg12[60] = ""Player 1 - Position the size boat 3 (2/2)"";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }

            else if (nm == 4)
            {
                printMessage(msg4);
            }

            else if (nm == 5)
            {
                printMessage(msg5);
            }

            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }

    if (Player == 2)
    {
        char msg1[60] = ""Player 2 - Position the size boat 1 (1/6)"";
        char msg2[60] = ""Player 2 - Position the size boat 1 (2/6)"";
        char msg3[60] = ""Player 2 - Position the size boat 1 (3/6)"";
        char msg4[60] = ""Player 2 - Position the size boat 1 (4/6)"";
        char msg5[60] = ""Player 2 - Position the size boat 1 (5/6)"";
        char msg6[60] = ""Player 2 - Position the size boat 1 (6/6)"";

        char msg7[60] = ""Player 2 - Position the size boat 2 (1/4)"";
        char msg8[60] = ""Player 2 - Position the size boat 2 (2/4)"";
        char msg9[60] = ""Player 2 - Position the size boat 2 (3/4)"";
        char msg10[60] = ""Player 2 - Position the size boat 2 (4/4)"";

        char msg11[60] = ""Player 2 - Position the size boat 3 (1/2)"";
        char msg12[60] = ""Player 2 - Position the size boat 3 (2/2)"";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }
            else if (nm == 4)
            {
                printMessage(msg4);
            }
            else if (nm == 5)
            {
                printMessage(msg5);
            }
            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            else if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }
}"
main,,,0,"int main()
{
    int Player1[10][10];
    int Player2[10][10];
    int plays = 1;
    int pts1 = 0, pts2 = 0, a1 = 0, a2 = 0;
    int line, col = 0, lin = 0;
    char column;

    // filling matrix with 0
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            Player1[i][j] = 0;
            Player2[i][j] = 0;
        }
    }

    // positioning boats
    for (int i = 1; i <= 2; i++)
    {
        for (int j = 1; j <= 6; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 1, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 1);
            }
            else if (i == 2)
            {
                printPositioning(i, 1, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 1);
            }
        }
        for (int j = 1; j <= 4; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 2, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 2);
            }
            else if (i == 2)
            {
                printPositioning(i, 2, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 2);
            }
        }
        for (int j = 1; j <= 2; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 3, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 3);
            }
            else if (i == 2)
            {
                printPositioning(i, 3, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 3);
            }
        }
    }

    // starting the game
    while (plays <= 40)
    {
        if (plays % 2 != 0)
        {
            printMessageScore(pts1, pts2);
            printMessage(""Player 1's turn"");
            printsTray(Player2, 1);
            scanf(""%d %c"", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player2, line - 1, column - 65) != 1)
            {
                line = 0;
                column = 'a';
                printf(""Position unavailable!\n"");
                scanf(""%d %c"", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player2, lin, col);
            a1 = pts1;
            pts1 += calculateScore(Player2, lin, col);

            if (a1 != pts1)
            {
                printMessage(""Player 1 DROPPED A BOAT!"");
            }
        }
        else
        {
            printMessageScore(pts1, pts2);
            printMessage(""Player 2's turn"");
            printsTray(Player1, 1);
            scanf(""%d %c"", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player1, line - 1, column - 65) != 1)
            {
                printf(""Position unavailable!\n"");
                scanf(""%d %c"", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player1, lin, col);
            a2 = pts2;
            pts2 += calculateScore(Player1, lin, col);

            if (a2 != pts2)
            {
                printMessage(""Player 2 DROPPED A BOAT!"");
            }
        }

        plays++;
    }
    /**
     * the one with the most points wins, or the one who knocks down all boats
     * first.
     */
    printMessage(""END GAME\n"");
    printMessageScore(pts1, pts2);

    return 0;
}"
main,,,0,"int main() {

    struct game_instance game = new_game(); // new game created
    char guess; // current letter guessed by player

    // main loop - asks player for guesses
    while ((strchr(game.hidden, '_') != NULL) && game.incorrect <= 12) {
        do {
            printf(""\n****************************\n"");
            printf(""Your word: "");

            for (int i = 0; i < game.size; i++) {
                printf(""%c "", game.hidden[i]);
            }

            if (game.guesses_size > 0) {
                printf(""\nSo far, you have guessed: "");
                for (int i = 0; i < game.guesses_size; i++) {
                    printf(""%c "", game.guesses[i]);
                }
            }

            printf(""\nYou have %d guesses left."", (12 - game.incorrect));
            printf(""\nPlease enter a letter: "");
            scanf("" %c"", &guess);
            guess = tolower(guess);

        } while (new_guess(guess, game.guesses, game.guesses_size) != -1);

        game.guesses[game.guesses_size] = guess; // adds new letter to guesses array
        game.guesses_size++; // updates size of guesses array

        if (in_word(guess, game.current_word, game.size) == 1) {
            printf(""That letter is in the word!"");
            for (int i = 0; i < game.size; i++) {
                if ((game.current_word[i]) == guess) {
                    game.hidden[i] = guess;
                }
            }
        } else {
            printf(""That letter is not in the word.\n"");
            (game.incorrect)++;
        }
        picture(game.incorrect);
    }

    won(game.current_word, game.incorrect);
    return 0;
}"
new_guess,"char new_guess, const char guesses[], int size",,1 | -1,"int new_guess(char new_guess, const char guesses[], int size) {

    for (int j = 0; j < size; j++) {
        if (guesses[j] == new_guess) {
            printf(""\nYou have already guessed that letter."");
            return 1;
        }
    }

    return -1;
}"
in_word,"char letter, const char word[], unsigned int size",,1 | -1,"int in_word(char letter, const char word[], unsigned int size) {

    for (int i = 0; i < size; i++) {
        if ((word[i]) == letter) {
            return 1;
        }
    }

    return -1;
}"
new_game,,,current_game,"struct game_instance new_game() {

    char word[30]; // used throughout function

    FILE *fptr;
    fptr = fopen(""games/words.txt"", ""r"");

    if (fptr == NULL){
        fprintf(stderr, ""File not found.\n"");
        exit(EXIT_FAILURE);
    }

    // counts number of words in file - assumes each word on new line
    int line_number = 0;
    while (fgets(word, 30, fptr) != NULL) {
        line_number++;
    }

    rewind(fptr);

    // generates random number
    int random_num;
    srand(time(NULL));
    random_num = rand() % line_number;

    // selects randomly generated word
    int s = 0;
    while (s <= random_num){
        fgets(word, 30, fptr);
        s++;
    }

    // formats string correctly
    if (strchr(word, '\n') != NULL){
        word[strlen(word) - 1] = '\0';
    }

    fclose(fptr);

    // creates new game instance
    struct game_instance current_game;
    strcpy(current_game.current_word, word);
    current_game.size = strlen(word);
    for (int i = 0; i < (strlen(word)); i++) {
        current_game.hidden[i] = '_';
    }
    current_game.incorrect = 0;
    current_game.guesses_size = 0;

    return current_game;
}"
won,"const char word[], int score",,null,"void won(const char word[], int score) {
    if (score > 12) {
        printf(""\nYou lost! The word was: %s.\n"", word);
    }
    else {
        printf(""\nYou won! You had %d guesses left.\n"", (12 - score));
    }
}"
picture,int score,,null,"void picture(int score) {

    switch(score) {

        case 12:
            printf(""\n      _\n""
                   ""  __( ' )> \n""
                   "" \\_ < _ ) "");
            break;

        case 11:
            printf(""\n      _\n""
                   ""  __( ' )\n""
                   "" \\_ < _ ) "");
            break;

        case 10:
            printf(""\n      _\n""
                   ""  __(   )\n""
                   "" \\_ < _ ) "");
            break;

        case 9:
            printf(""\n        \n""
                   ""  __(   )\n""
                   "" \\_ < _ ) "");
            break;

        case 8:
            printf(""\n        \n""
                   ""  __(    \n""
                   "" \\_ < _ ) "");
            break;

        case 7:
            printf(""\n        \n""
                   ""  __     \n""
                   "" \\_ < _ ) "");
            break;

        case 6:
            printf(""\n        \n""
                   ""  _      \n""
                   "" \\_ < _ ) "");
            break;

        case 5:
            printf(""\n        \n""
                   ""  _      \n""
                   ""   _ < _ ) "");
            break;

        case 4:
            printf(""\n        \n""
                   ""         \n""
                   ""   _ < _ ) "");
            break;

        case 3:
            printf(""\n        \n""
                   ""         \n""
                   ""     < _ ) "");
            break;

        case 2:
            printf(""\n        \n""
                   ""         \n""
                   ""       _ ) "");
            break;

        case 1:
            printf(""\n        \n""
                   ""         \n""
                   ""         ) "");
            break;

        case 0:
            break;

        default:
            printf(""\n      _\n""
                   ""  __( ' )> QUACK!\n""
                   "" \\_ < _ ) "");
            break;
    }
}"
main,,,0,"int main()
{   
    srand( (unsigned int)time(NULL));
    int l = 0;
    do
    {
        int n = 0;

        // filling the table with multiple asterisks
        for (int i = 0; i < 9; i++) game_table[i] = '*';

        // displaying the main menu
        printf(""***************************************\n"");
        printf(""*************TIC TAC TOE***************\n"");
        printf(""***************************************\n"");
        printf(""***********1. YOU vs COMPUTER ***********\n"");
        printf(""***********2. YOU vs PLAYER ***********\n"");
        printf(""***********3.EXIT *********************\n"");
        printf(""Enter your choice : "");
        scanf(""%d"", &n);

        switch (n)  // switch case to select between single player mode or
                    // double player mode
        {
        case 1:
            singlemode();
            break;
        case 2:
            doublemode();
            break;
        default:
            printf(""THANK YOU and EXIT!"");
        }

        printf(""Next game ? : "");
        printf(""Enter 1 – YES and 0 - NO "");
        scanf(""%d"", &l);

    } while (l == 1);

    return 0;
}"
singlemode,,,null,"void singlemode()
{
    int m;
    int k = 0;
    int table_fill_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf(""%c "", game_table[k]);
            k++;
        }

        printf(""\n"");
    }

    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf(""Where would you like to place 'x' "");
        scanf(""%d"", &m);

        placex(m);
        if(table_fill_count<4)
        {
          place();
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf(""%c "", game_table[k]);
                k++;

            }

            printf(""\n"");
        }
        table_fill_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf(""YOU WIN\n"");
            }
            if (o == -2)
            {
                printf(""YOU LOSE\n"");
            }

            break;
        }

        if (table_fill_count==4)
        {
            printf(""\nDRAW "");
            break;
        }
    }
}"
doublemode,,,null,"void doublemode()
{
    int m;
    int e1;
    int k = 0;
    int doublemode_table_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf(""%c "", game_table[k]);
            k++;
        }

        printf(""\n"");
    }
    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf(""PLAYER1 - where would you like to place 'x' : "");
        scanf(""%d"", &m);

        placex(m);
        if(doublemode_table_count<4)
        {
        printf(""PLAYER2 - where would you like to place 'o' : "");
        scanf(""%d"", &e1);

        placey(e1);
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf(""%c "", game_table[k]);
                k++;
            }

            printf(""\n"");
        }
        doublemode_table_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf(""Player 1 WIN\n"");
            }
            if (o == -2)
            {
                printf(""Player 2 WIN\n"");
            }

            break;
        }
        if (doublemode_table_count==4)
        {
            printf(""\nDRAW "");
            break;
        }
    }
}"
check_placex,,,n1,"
int check_placex(){
	char input[50];
	int n1;
	while (1){
		fgets(input,49,stdin);
		if ( strlen(input) > 2 || strlen(input)  == 0){
			fprintf(stderr,""Invalid move, Enter number 1 - 9: "");
			continue;
		}
		if(sscanf(input,""%d"",&n1) != 1){
			fprintf(stderr,""Invalid move, Enter number 1 - 9: "");
			continue;
		} 
		if ((game_table[n1-1] == 'x') || (game_table[n1-1]) == 'o' || (n1== 0)){
			fprintf(stderr,""Already allocated, Enter number: "");
			continue;
		}
		return n1;
	}
}"
placex,int m,,null,"void placex(int m)
{
    int n1 = 0;
    if (m >= 1 && m <= 9)
    {
        if (game_table[m - 1] != 'x' && game_table[m - 1] != 'o')
        {
            game_table[m - 1] = 'x';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}"
place,,,null,"void place()
{

    int e = rand() % 9;

    if (e >= 0)
    {
        if (game_table[e] != 'x' && game_table[e] != 'o')
        {
            game_table[e] = 'o';
            printf(""\n Computer placed at %d position\n"", e + 1);
        }
        else
        {
            place();
        }
    }
}"
placey,int e1,,null,"void placey(int e1)
{
    int n1 = 0;
    if (e1 >= 1 && e1 <= 9)
    {
        if (game_table[e1 - 1] != 'x' && game_table[e1 - 1] != 'o')
        {
            game_table[e1 - 1] = 'o';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}"
checkwin,,,-1 | -2 | 0,"int checkwin()
{
    if (game_table[0] == game_table[1] && game_table[1] == game_table[2])
    {
        if (game_table[0] == 'x' && game_table[1] == 'x' &&
            game_table[2] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[1] == 'o' &&
            game_table[2] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[4] && game_table[4] == game_table[8])
    {
        if (game_table[0] == 'x' && game_table[4] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[4] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[3] && game_table[3] == game_table[6])
    {
        if (game_table[0] == 'x' && game_table[3] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[3] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[3] == game_table[4] && game_table[4] == game_table[5])
    {
        if (game_table[3] == 'x' && game_table[4] == 'x' &&
            game_table[5] == 'x')
        {
            return -1;
        }

        if (game_table[3] == 'o' && game_table[4] == 'o' &&
            game_table[5] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[6] == game_table[7] && game_table[7] == game_table[8])
    {
        if (game_table[6] == 'x' && game_table[7] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[6] == 'o' && game_table[7] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[1] == game_table[4] && game_table[4] == game_table[7])
    {
        if (game_table[1] == 'x' && game_table[4] == 'x' &&
            game_table[7] == 'x')
        {
            return -1;
        }

        if (game_table[1] == 'o' && game_table[4] == 'o' &&
            game_table[7] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[5] && game_table[5] == game_table[8])
    {
        if (game_table[2] == 'x' && game_table[5] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[5] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[4] && game_table[4] == game_table[6])
    {
        if (game_table[2] == 'x' && game_table[4] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[4] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    return 0;
}"
sentinel_linear_search,"int arr[], int len, int key",,len-1 | i != len-1 ? i : -1,"int sentinel_linear_search( int arr[], int len, int key ){
	if(key == arr[len-1]){
		return len-1;
	}
	
	int temp = arr[len-1]; 
	arr[len-1] = key;
	
	int i = 0;
	while (arr[len-1] != arr[i]) {
		i++;
	}
	
	arr[len-1] = temp;
	
	return i != len-1 ? i : -1;
	 
}"
test,,,null,"static void test(){
	int n,i;
	n = 5;
	/* init array */
	int arr[] = { 1, 2, 2, 6, 99, 100, 999 };

	assert(sentinel_linear_search( arr, n, 1 )==0);
	assert(sentinel_linear_search( arr, n, 2 )==1);
	assert(sentinel_linear_search( arr, n, 6 )==3);
	assert(sentinel_linear_search( arr, n, 101 )==-1);
	printf(""All test cases have successfully passed!\n"");
}"
main,,,0,"int main(){
	test();  // run self-test implementations
	return 0;
}"
duplicateNumber,"const uint32_t *in_arr, size_t n",,-1 | tortoise,"uint32_t duplicateNumber(const uint32_t *in_arr, size_t n)
{
    if (n <= 1) {  // to find duplicate in an array its size should be at least 2
        return -1;
    }
    uint32_t tortoise = in_arr[0];  ///< variable tortoise is used for the longer
                                    ///< jumps in the array
    uint32_t hare = in_arr[0];  ///< variable hare is used for shorter jumps in the array
    do {                                   // loop to enter the cycle
        tortoise = in_arr[tortoise];       // tortoise is moving by one step
        hare = in_arr[in_arr[hare]];       // hare is moving by two steps
    } while (tortoise != hare);
    tortoise = in_arr[0];
    while (tortoise != hare) {             // loop to find the entry point of cycle
        tortoise = in_arr[tortoise];
        hare = in_arr[hare];
    }
    return tortoise;
}"
test,,,null,"static void test()
{
    uint32_t arr[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}; // input array
    size_t n = sizeof(arr) / sizeof(int);

    printf(""1st test... "");
    uint32_t index = duplicateNumber(arr, n); // calling the duplicateNumber function to check which number occurs twice in the array
    assert(index == 1); // the number which occurs twice is 1 or not
    printf(""passed\n"");
}"
main,,,0,"int main()
{
    test();  // run self-test implementations
    return 0;
}"
binarysearch1,"const int *arr, int l, int r, int x",,"mid | binarysearch1(arr, l, mid - 1, x) | binarysearch1(arr, mid + 1, r, x) | -1","int binarysearch1(const int *arr, int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;

        // If element is present at middle
        if (arr[mid] == x)
            return mid;

        // If element is smaller than middle
        if (arr[mid] > x)
            return binarysearch1(arr, l, mid - 1, x);

        // Else element is in right subarray
        return binarysearch1(arr, mid + 1, r, x);
    }

    // When element is not present in array
    return -1;
}"
binarysearch2,"const int *arr, int l, int r, int x",,-1 | mid,"int binarysearch2(const int *arr, int l, int r, int x)
{
    int mid = l + (r - l) / 2;

    while (arr[mid] != x)
    {
        if (r <= l || r < 0)
            return -1;

        if (arr[mid] > x)
            // If element is smaller than middle
            r = mid - 1;
        else
            // Else element is in right subarray
            l = mid + 1;

        mid = l + (r - l) / 2;
    }

    // When element is not present in array
    return mid;
}"
test,,,null,"void test()
{
    // give function an array to work with
    int arr[] = {2, 3, 4, 10, 40};
    // get size of array
    int n = sizeof(arr) / sizeof(arr[0]);

    printf(""Test 1.... "");
    // set value to look for
    int x = 10;
    // set result to what is returned from binarysearch
    int result = binarysearch1(arr, 0, n - 1, x);
    assert(result == 3);
    printf(""passed recursive... "");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == 3);
    printf(""passed iterative...\n"");

    printf(""Test 2.... "");
    x = 5;
    // set result to what is returned from binarysearch
    result = binarysearch1(arr, 0, n - 1, x);
    assert(result == -1);
    printf(""passed recursive... "");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == -1);
    printf(""passed iterative...\n"");
}"
main,,,0,"int main(void)
{
    test();
    return 0;
}"
fibMonaccianSearch,"int arr[], int x, int n",,"index */
        else
            return i | offset + 1 | -1 */
    return -1 | 0","
int fibMonaccianSearch(int arr[], int x, int n)
{
    /* Initialize fibonacci numbers */
    int fibMMm2 = 0;               // (m-2)'th Fibonacci No.
    int fibMMm1 = 1;               // (m-1)'th Fibonacci No.
    int fibM = fibMMm2 + fibMMm1;  // m'th Fibonacci

    /* fibM is going to store the smallest Fibonacci
       Number greater than or equal to n */
    while (fibM < n)
    {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }

    // Marks the eliminated range from front
    int offset = -1;

    /* while there are elements to be inspected. Note that
       we compare arr[fibMm2] with x. When fibM becomes 1,
       fibMm2 becomes 0 */
    while (fibM > 1)
    {
        // Check if fibMm2 is a valid location

        // sets i to the min. of (offset+fibMMm2) and (n-1)
        int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);

        /* If x is greater than the value at index fibMm2,
           cut the subarray array from offset to i */
        if (arr[i] < x)
        {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        }

        /* If x is greater than the value at index fibMm2,
           cut the subarray after i+1  */
        else if (arr[i] > x)
        {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        }

        /* element found. return index */
        else
            return i;
    }

    /* comparing the last element with x */
    if (fibMMm1 && arr[offset + 1] == x)
        return offset + 1;

    /*element not found. return -1 */
    return -1;
}

int main(void)
{
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 85;
    printf(""Found at index: %d"", fibMonaccianSearch(arr, x, n));
    return 0;
}
"
main,,element not found. return -1,0,"
int main(void)
{
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 85;
    printf(""Found at index: %d"", fibMonaccianSearch(arr, x, n));
    return 0;
}"
binarySearch,"const int **mat, int i, int j_low, int j_high, int x",,j_mid | -1,"int binarySearch(const int **mat, int i, int j_low, int j_high, int x)
{
    while (j_low <= j_high)
    {
        int j_mid = (j_low + j_high) / 2;

        // Element found
        if (mat[i][j_mid] == x)
        {
            printf(""Found at (%d,%d)\n"", i, j_mid);
            return j_mid;
        }
        else if (mat[i][j_mid] > x)
            j_high = j_mid - 1;
        else
            j_low = j_mid + 1;
    }

    // element not found
    printf(""element not found\n"");
    return -1;
}"
modifiedBinarySearch,"const int **mat, int n, int m, int x",,null,"void modifiedBinarySearch(const int **mat, int n, int m, int x)
{  // If Single row matrix
    if (n == 1)
    {
        binarySearch(mat, 0, 0, m - 1, x);
        return;
    }

    // Do binary search in middle column.
    // Condition to terminate the loop when the 2 desired rows are found.
    int i_low = 0, i_high = n - 1, j_mid = m / 2;
    while ((i_low + 1) < i_high)
    {
        int i_mid = (i_low + i_high) / 2;
        // element found
        if (mat[i_mid][j_mid] == x)
        {
            printf(""Found at (%d,%d)\n"", i_mid, j_mid);
            return;
        }
        else if (mat[i_mid][j_mid] > x)
            i_high = i_mid;
        else
            i_low = i_mid;
    }
    // If element is present on the mid of the two rows
    if (mat[i_low][j_mid] == x)
        printf(""Found at (%d,%d)\n"", i_low, j_mid);
    else if (mat[i_low + 1][j_mid] == x)
        printf(""Found at (%d,%d)\n"", i_low + 1, j_mid);

    // Search element on 1st half of 1st row
    else if (x <= mat[i_low][j_mid - 1])
        binarySearch(mat, i_low, 0, j_mid - 1, x);

    // Search element on 2nd half of 1st row
    else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])
        binarySearch(mat, i_low, j_mid + 1, m - 1, x);

    // Search element on 1st half of 2nd row
    else if (x <= mat[i_low + 1][j_mid - 1])
        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);

    // search element on 2nd half of 2nd row
    else
        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);
}"
main,,,0,"int main()
{
    int x;     // element to be searched
    int m, n;  // m = columns, n = rows

    scanf(""%d %d %d\n"", &n, &m, &x);

    int **mat = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf(""%d"", &mat[i][j]);
        }
    }

    modifiedBinarySearch(mat, n, m, x);

    for (int i = 0; i < n; i++) free(mat[i]);
    free(mat);
    return 0;
}"
exponential_search,"const int64_t* arr, const uint16_t length, const int64_t n",,"-1 | binary_search(arr, lower_bound, upper_bound, n)","int64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n) 
{
    if ( length == 0 ) { return -1; }
    // find the upperbound
    uint32_t upper_bound = 1;
    while ( upper_bound <= length && arr[upper_bound] < n ) { upper_bound = upper_bound * 2; }
    // calculate the range ( between lower_boud and upper_bound )
    uint16_t lower_bound = upper_bound/2;
    if ( upper_bound > length ) { upper_bound = length; }
    // apply the binary search in the range
    return binary_search(arr, lower_bound, upper_bound, n);
}"
binary_search,"const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n",,"-1 | middle_index | binary_search(arr, l_index, middle_index-1, n) | binary_search(arr, middle_index+1, r_index, n)","int64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n) 
{
    // calculate the middle index of the array
    uint16_t middle_index = l_index + ( r_index - l_index ) / 2;
    // base cases
    if ( l_index > r_index ) { return -1; }
    if ( arr[middle_index] == n ) { return middle_index; }
    // recursion
    if ( arr[middle_index] > n ) { return binary_search(arr, l_index, middle_index-1, n); } // left
    return binary_search(arr, middle_index+1, r_index, n); // right
}"
main,,,0,"int main() 
{
    test();  // run self-test implementations
    return 0;
}"
test,,,null,"static void test()
{
    // empty array
    int64_t arr_empty[] = { 0 };
    assert(exponential_search(arr_empty, 0, 10) == -1);
    // elent not found
    int64_t arr_found[] = {1, 2, 3};
    assert(exponential_search(arr_found, 3, 10) == -1);
    // element found in an array of length 1
    int64_t arr_one[] = {1};
    assert(exponential_search(arr_found, 1, 1) == 0);
    // find the first element in an array of length 2
    int64_t arr_first_2[] = {1, 2};
    assert(exponential_search(arr_first_2, 2, 1) == 0);
    // find the last element in an array of length 2
    int64_t arr_last_2[] = {1, 2};
    assert(exponential_search(arr_last_2, 2, 2) == 1);
    // find the first element in an array of length n
    int64_t arr_first_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_first_n, 5, -1) == 0);
    // find the last element in an array of length n
    int64_t arr_last_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_last_n, 5, 8) == 4);
    // find an element in an array of length n
    int64_t arr_middle[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_middle, 5, 6) == 3);

    printf(""All tests have successfully passed!\n"");
}"
linearsearch,"int *arr, int size, int val",,1 | 0,"
int linearsearch(int *arr, int size, int val)
{
    int i;
    for (i = 0; i < size; i++)
    {
        if (arr[i] == val)
            return 1;
    }
    return 0;
}"
main,,,0,"
int main()
{
    int n, i, v;
    printf(""Enter the size of the array:\n"");
    scanf(""%d"", &n);  // Taking input for the size of Array

    int *a = (int *)malloc(n * sizeof(int));
    printf(""Enter the contents for an array of size %d:\n"", n);
    for (i = 0; i < n; i++)
        scanf(""%d"", &a[i]);  // accepts the values of array elements until the
                             // loop terminates//

    printf(""Enter the value to be searched:\n"");
    scanf(""%d"", &v);  // Taking input the value to be searched
    if (linearsearch(a, n, v))
        printf(""Value %d is in the array.\n"", v);
    else
        printf(""Value %d is not in the array.\n"", v);

    free(a);
    return 0;
}"
interpolationSearch,"int arr[], int n, int key",,pos | -1,"int interpolationSearch(int arr[], int n, int key)
{
    int low = 0, high = n - 1;
    while (low <= high && key >= arr[low] && key <= arr[high])
    {
        /* Calculate the nearest posible position of key */
        int pos =
            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        if (key > arr[pos])
            low = pos + 1;
        else if (key < arr[pos])
            high = pos - 1;
        else /* Found */
            return pos;
    }
    /* Not found */
    return -1;
}"
main,,Not found,0,"
int main()
{
    int x;
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf(""Array: "");
    for (int i = 0; i < n; i++) printf(""%d "", arr[i]);
    printf(""\nEnter the number to be searched: "");
    scanf(""%d"", &x); /* Element to be searched */

    int index = interpolationSearch(arr, n, x);

    /* If element was found */
    if (index != -1)
        printf(""Element found at position: %d\n"", index);
    else
        printf(""Element not found.\n"");
    return 0;
}"
binarySearch,"int array[], int leng, int searchX",,pos | -1,"
int binarySearch(int array[], int leng, int searchX)
{
    int pos = -1, right, left, i = 0;

    left = 0;
    right = leng - 1;

    while (left <= right)
    {
        pos = left + (right - left) / 2;
        if (array[pos] == searchX)
        {
            return pos;
        }
        else if (array[pos] > searchX)
        {
            right = pos - 1;
        }
        else
        {
            left = pos + 1;
        }
    }
    return -1; /* not found */
}"
main,"int argc, char *argv[]",not found,0,"
int main(int argc, char *argv[])
{
    int array[len] = {5, 8, 10, 14, 16};

    int position;
    position = binarySearch(array, len, 5);

    if (position < 0)
        printf(""The number %d doesnt exist in array\n"", 5);
    else
    {
        printf(""The number %d exist in array at position : %d \n"", 5, position);
    }

    return 0;
}"
ternarySearch,"int l, int r, int key, int ar[]",,"mid1 | mid2 | ternarySearch(l, mid1 - 1, key, ar) | ternarySearch(mid2 + 1, r, key, ar) | ternarySearch(mid1 + 1, mid2 - 1, key, ar) | -1","
int ternarySearch(int l, int r, int key, int ar[])
{
    if (r >= l)
    {
        // Find the mid1 and mid2
        int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;

        // Check if key is present at any mid
        if (ar[mid1] == key)
        {
            return mid1;
        }
        if (ar[mid2] == key)
        {
            return mid2;
        }

        // Since key is not present at mid,
        // check in which region it is present
        // then repeat the Search operation
        // in that region

        if (key < ar[mid1])
        {
            // The key lies in between l and mid1
            return ternarySearch(l, mid1 - 1, key, ar);
        }
        else if (key > ar[mid2])
        {
            // The key lies in between mid2 and r
            return ternarySearch(mid2 + 1, r, key, ar);
        }
        else
        {
            // The key lies in between mid1 and mid2
            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);
        }
    }

    // Key not found
    return -1;
}"
main,,,,"
int main()
{
    int l, r, p, key;

    // Get the array
    // Sort the array if not sorted
    int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Starting index
    l = 0;

    // length of array
    r = 9;

    // Checking for 5

    // Key to be searched in the array
    key = 5;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf(""Index of %d is %d\n"", key, p);

    // Checking for 50

    // Key to be searched in the array
    key = 50;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf(""Index of %d is %d"", key, p);
}"
jump_search,"const int *arr, int x, size_t n",,-1 | prev,"int jump_search(const int *arr, int x, size_t n)
{
    int step = floor(sqrt(n));
    int prev = 0;

    while (arr[min(step, n) - 1] < x)
    {
        prev = step;
        step += floor(sqrt(n));
        if (prev >= n)
        {
            return -1;
        }
    }

    while (arr[prev] < x)
    {
        prev = prev + 1;
        if (prev == min(step, n))
        {
            return -1;
        }
    }
    if (arr[prev] == x)
    {
        return prev;
    }
    return -1;
}"
test,,,null,"void test()
{
    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
    size_t n = sizeof(arr) / sizeof(int);

    int x = 55;
    printf(""Test 1.... "");
    int index = jump_search(arr, x, n);
    assert(index == 10);
    printf(""passed\nTest 2.... "");
    x = 56;
    index = jump_search(arr, x, n);
    assert(index == -1);
    printf(""passed\nTest 3.... "");
    x = 13;
    index = jump_search(arr, x, n);
    assert(index == 7);
    printf(""passed\n"");
}"
main,,,0,"int main()
{
    test();
    return 0;
}"
max,"int a, int b",,(a > b) ? a : b,"
int max(int a, int b) { return (a > b) ? a : b; }"
computeArray,"char *pattern, int size, int arr[NUM_OF_CHARS]",,null,"
void computeArray(char *pattern, int size, int arr[NUM_OF_CHARS])
{
    int i;

    for (i = 0; i < NUM_OF_CHARS; i++) arr[i] = -1;
    /* Fill the actual value of last occurrence of a character */
    for (i = 0; i < size; i++) arr[(int)pattern[i]] = i;
}"
boyer_moore_search,"char *str, char *pattern",,null,"void boyer_moore_search(char *str, char *pattern)
{
    int n = strlen(str);
    int m = strlen(pattern);
    int shift = 0;
    int arr[NUM_OF_CHARS];

    computeArray(pattern, m, arr);
    while (shift <= (n - m))
    {
        int j = m - 1;
        while (j >= 0 && pattern[j] == str[shift + j]) j--;
        if (j < 0)
        {
            printf(""--Pattern is found at: %d\n"", shift);
            shift += (shift + m < n) ? m - arr[str[shift + m]] : 1;
        }
        else
        {
            shift += max(1, j - arr[str[shift + j]]);
        }
    }
}"
main,,,0,"
int main()
{
    char str[] = ""AABCAB12AFAABCABFFEGABCAB"";
    char pat1[] = ""ABCAB"";
    char pat2[] = ""FFF""; /* not found */
    char pat3[] = ""CAB"";

    printf(""String test: %s\n"", str);
    printf(""Test1: search pattern %s\n"", pat1);
    boyer_moore_search(str, pat1);
    printf(""Test2: search pattern %s\n"", pat2);
    boyer_moore_search(str, pat2);
    printf(""Test3: search pattern %s\n"", pat3);
    boyer_moore_search(str, pat3);
    return 0;
}"
rabin_karp_search,"char *str, char *pattern, int d, int q",,null,"void rabin_karp_search(char *str, char *pattern, int d, int q)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);
    int i, h = 1;
    int hash_s = 0; /* hash value for string text */
    int hash_p = 0; /* hash value for pattern */

    /* h = pow(d, len_pat - 1) % q */
    for (i = 0; i < len_pat - 1; i++) h = d * h % q;
    /* Calculating hashing of pattern and the 1st window of text */
    for (i = 0; i < len_pat; i++)
    {
        hash_p = (d * hash_p + pattern[i]) % q;
        hash_s = (d * hash_s + str[i]) % q;
    }

    for (i = 0; i <= len_str - len_pat; i++)
    {
        /* Check hash value of current window of text, and pattern
           If it is match, check each character to make sure pattern
           is match with current window of text */
        if (hash_p == hash_s)
        {
            int j;
            for (j = 0; j < len_pat; j++)
            {
                if (pattern[j] != str[i + j])
                    break;
            }
            if (len_pat == j)
                printf(""--Pattern is found at: %d\n"", i);
        }
        /* Calculate hash value for next window by removing the leading
           element of current window text, and adding its trailing */
        hash_s = (d * (hash_s - str[i] * h) + str[i + len_pat]) % q;
        /* Converting hash value to positive when it is negative */
        if (hash_s < 0)
            hash_s = hash_s + q;
    }
}"
main,,,0,"
int main()
{
    char str[] = ""AABCAB12AFAABCABFFEGABCAB"";
    char pat1[] = ""ABCAB"";
    char pat2[] = ""FFF""; /* not found */
    char pat3[] = ""CAB"";

    printf(""String test: %s\n"", str);
    printf(""Test1: search pattern %s\n"", pat1);
    rabin_karp_search(str, pat1, 256, 29);
    printf(""Test2: search pattern %s\n"", pat2);
    rabin_karp_search(str, pat2, 256, 29);
    printf(""Test3: search pattern %s\n"", pat3);
    rabin_karp_search(str, pat3, 256, 29);
    return 0;
}"
naive_search,"char *str, char *pattern",,null,"void naive_search(char *str, char *pattern)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);

    for (int i = 0; i <= len_str - len_pat; i++)
    {
        int j;
        for (j = 0; j < len_pat; j++)
        {
            if (str[i + j] != pattern[j])
                break;
        }
        if (j == len_pat)
            printf(""--Pattern is found at: %d\n"", i);
    }
}"
main,,,0,"
int main()
{
    char str[] = ""AABCAB12AFAABCABFFEGABCAB"";
    char pat1[] = ""ABCAB"";
    char pat2[] = ""FFF""; /* not found */
    char pat3[] = ""CAB"";

    printf(""String test: %s\n"", str);
    printf(""Test1: search pattern %s\n"", pat1);
    naive_search(str, pat1);
    printf(""Test2: search pattern %s\n"", pat2);
    naive_search(str, pat2);
    printf(""Test3: search pattern %s\n"", pat3);
    naive_search(str, pat3);
    return 0;
}"
G,"block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y",,null,"static void G(block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,
              uint64_t y)
{
    v[a] += v[b] + x;
    v[d] = ROTR64(v[d] ^ v[a], R1);
    v[c] += v[d];
    v[b] = ROTR64(v[b] ^ v[c], R2);
    v[a] += v[b] + y;
    v[d] = ROTR64(v[d] ^ v[a], R3);
    v[c] += v[d];
    v[b] = ROTR64(v[b] ^ v[c], R4);
}"
F,"uint64_t h[8], block_t m, u128 t, int f",,null,"static void F(uint64_t h[8], block_t m, u128 t, int f)
{
    int i;
    block_t v;

    /* v[0..7] := h[0..7] */
    for (i = 0; i < 8; i++)
    {
        v[i] = h[i];
    }
    /* v[8..15] := IV[0..7] */
    for (; i < 16; i++)
    {
        v[i] = blake2b_iv[i - 8];
    }

    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */
    v[13] ^= t[1]; /* v[13] ^ (t >> w) */

    if (f)
    {
        v[14] = ~v[14];
    }

    for (i = 0; i < 12; i++)
    {
        const uint8_t *s = blake2b_sigma[i];

        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);
        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);
        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);
        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);

        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);
        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);
        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);
        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);
    }

    for (i = 0; i < 8; i++)
    {
        h[i] ^= v[i] ^ v[i + 8];
    }
}"
BLAKE2B,"uint8_t *dest, block_t *d, size_t dd, u128 ll, uint8_t kk, uint8_t nn",,0 | NULL | dest,"static int BLAKE2B(uint8_t *dest, block_t *d, size_t dd, u128 ll, uint8_t kk,
                   uint8_t nn)
{
    uint8_t bytes[8];
    uint64_t i, j;
    uint64_t h[8];
    u128 t = U128_ZERO;

    /* h[0..7] = IV[0..7] */
    for (i = 0; i < 8; i++)
    {
        h[i] = blake2b_iv[i];
    }

    h[0] ^= 0x01010000 ^ (kk << 8) ^ nn;

    if (dd > 1)
    {
        for (i = 0; i < dd - 1; i++)
        {
            u128_increment(t, bb);
            F(h, d[i], t, 0);
        }
    }

    if (kk != 0)
    {
        u128_increment(ll, bb);
    }
    F(h, d[dd - 1], ll, 1);

    /* copy bytes from h to destination buffer */
    for (i = 0; i < nn; i++)
    {
        if (i % sizeof(uint64_t) == 0)
        {
            /* copy values from uint64 to 8 u8's */
            for (j = 0; j < sizeof(uint64_t); j++)
            {
                uint16_t offset = 8 * j;
                uint64_t mask = 0xFF;
                mask <<= offset;

                bytes[j] = (h[i / 8] & (mask)) >> offset;
            }
        }

        dest[i] = bytes[i % 8];
    }

    return 0;
}

/**
 * @brief blake2b hash function
 *
 * This is the front-end function that sets up the argument for BLAKE2B().
 *
 * @param message the message to be hashed
 * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)
 * for this implementation)
 * @param key optional secret key
 * @param kk length of optional secret key (0 <= kk <= 64)
 * @param nn length of output digest (1 <= nn < 64)
 *
 * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated
 * memory nn bytes large
 */
uint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,
                 uint8_t kk, uint8_t nn)
{
    uint8_t *dest = NULL;
    uint64_t long_hold;
    size_t dd, has_key, i;
    size_t block_index, word_in_block;
    u128 ll;
    block_t *blocks;

    if (message == NULL)
    {
        len = 0;
    }
    if (key == NULL)
    {
        kk = 0;
    }

    kk = MIN(kk, KK_MAX);
    nn = MIN(nn, NN_MAX);

    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);

    blocks = calloc(dd, sizeof(block_t));
    if (blocks == NULL)
    {
        return NULL;
    }

    dest = malloc(nn * sizeof(uint8_t));
    if (dest == NULL)
    {
        free(blocks);
        return NULL;
    }

    /* If there is a secret key it occupies the first block */
    for (i = 0; i < kk; i++)
    {
        long_hold = key[i];
        long_hold <<= 8 * (i % 8);

        word_in_block = (i % bb) / 8;
        /* block_index will always be 0 because kk <= 64 and bb = 128*/
        blocks[0][word_in_block] |= long_hold;
    }

    has_key = kk > 0 ? 1 : 0;

    for (i = 0; i < len; i++)
    {
        /* long_hold exists because the bit-shifting will overflow if we don't
         * store the value */
        long_hold = message[i];
        long_hold <<= 8 * (i % 8);

        block_index = has_key + (i / bb);
        word_in_block = (i % bb) / 8;

        blocks[block_index][word_in_block] |= long_hold;
    }

    u128_fill(ll, len);

    BLAKE2B(dest, blocks, dd, ll, kk, nn);

    free(blocks);

    return dest;
}

/** @} */

/**
 * @brief Self-test implementations
 * @returns void
 */
static void assert_bytes(const uint8_t *expected, const uint8_t *actual,
                         uint8_t len)
{
    uint8_t i;

    assert(expected != NULL);
    assert(actual != NULL);
    assert(len > 0);

    for (i = 0; i < len; i++)
    {
        assert(expected[i] == actual[i]);
    }
}

/**
 * @brief testing function
 *
 * @returns void
 */
static void test()
{
    uint8_t *digest = NULL;

    /* ""abc"" example straight out of RFC-7693 */
    uint8_t abc[3] = {'a', 'b', 'c'};
    uint8_t abc_answer[64] = {
        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,
        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,
        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,
        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,
        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,
        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};

    digest = blake2b(abc, 3, NULL, 0, 64);
    assert_bytes(abc_answer, digest, 64);

    free(digest);

    uint8_t key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t key_answer[64] = {
        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,
        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,
        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,
        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,
        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,
        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};

    digest = blake2b(NULL, 0, key, 64, 64);
    assert_bytes(key_answer, digest, 64);

    free(digest);

    uint8_t zero[1] = {0};
    uint8_t zero_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t zero_answer[64] = {
        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,
        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,
        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,
        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,
        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,
        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};

    digest = blake2b(zero, 1, zero_key, 64, 64);
    assert_bytes(zero_answer, digest, 64);

    free(digest);

    uint8_t filled[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_answer[64] = {
        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,
        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,
        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,
        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,
        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,
        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};

    digest = blake2b(filled, 64, filled_key, 64, 64);
    assert_bytes(filled_answer, digest, 64);

    free(digest);

    printf(""All tests have successfully passed!\n"");
}

/**
 * @brief main function
 *
 * @returns 0 on successful program exit
 */
int main()
{
    test();
    return 0;
}"
blake2b,"const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn",,NULL | dest | 0,"uint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,
                 uint8_t kk, uint8_t nn)
{
    uint8_t *dest = NULL;
    uint64_t long_hold;
    size_t dd, has_key, i;
    size_t block_index, word_in_block;
    u128 ll;
    block_t *blocks;

    if (message == NULL)
    {
        len = 0;
    }
    if (key == NULL)
    {
        kk = 0;
    }

    kk = MIN(kk, KK_MAX);
    nn = MIN(nn, NN_MAX);

    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);

    blocks = calloc(dd, sizeof(block_t));
    if (blocks == NULL)
    {
        return NULL;
    }

    dest = malloc(nn * sizeof(uint8_t));
    if (dest == NULL)
    {
        free(blocks);
        return NULL;
    }

    /* If there is a secret key it occupies the first block */
    for (i = 0; i < kk; i++)
    {
        long_hold = key[i];
        long_hold <<= 8 * (i % 8);

        word_in_block = (i % bb) / 8;
        /* block_index will always be 0 because kk <= 64 and bb = 128*/
        blocks[0][word_in_block] |= long_hold;
    }

    has_key = kk > 0 ? 1 : 0;

    for (i = 0; i < len; i++)
    {
        /* long_hold exists because the bit-shifting will overflow if we don't
         * store the value */
        long_hold = message[i];
        long_hold <<= 8 * (i % 8);

        block_index = has_key + (i / bb);
        word_in_block = (i % bb) / 8;

        blocks[block_index][word_in_block] |= long_hold;
    }

    u128_fill(ll, len);

    BLAKE2B(dest, blocks, dd, ll, kk, nn);

    free(blocks);

    return dest;
}

/** @} */

/**
 * @brief Self-test implementations
 * @returns void
 */
static void assert_bytes(const uint8_t *expected, const uint8_t *actual,
                         uint8_t len)
{
    uint8_t i;

    assert(expected != NULL);
    assert(actual != NULL);
    assert(len > 0);

    for (i = 0; i < len; i++)
    {
        assert(expected[i] == actual[i]);
    }
}

/**
 * @brief testing function
 *
 * @returns void
 */
static void test()
{
    uint8_t *digest = NULL;

    /* ""abc"" example straight out of RFC-7693 */
    uint8_t abc[3] = {'a', 'b', 'c'};
    uint8_t abc_answer[64] = {
        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,
        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,
        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,
        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,
        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,
        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};

    digest = blake2b(abc, 3, NULL, 0, 64);
    assert_bytes(abc_answer, digest, 64);

    free(digest);

    uint8_t key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t key_answer[64] = {
        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,
        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,
        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,
        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,
        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,
        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};

    digest = blake2b(NULL, 0, key, 64, 64);
    assert_bytes(key_answer, digest, 64);

    free(digest);

    uint8_t zero[1] = {0};
    uint8_t zero_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t zero_answer[64] = {
        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,
        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,
        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,
        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,
        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,
        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};

    digest = blake2b(zero, 1, zero_key, 64, 64);
    assert_bytes(zero_answer, digest, 64);

    free(digest);

    uint8_t filled[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_answer[64] = {
        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,
        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,
        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,
        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,
        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,
        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};

    digest = blake2b(filled, 64, filled_key, 64, 64);
    assert_bytes(filled_answer, digest, 64);

    free(digest);

    printf(""All tests have successfully passed!\n"");
}

/**
 * @brief main function
 *
 * @returns 0 on successful program exit
 */
int main()
{
    test();
    return 0;
}"
assert_bytes,"const uint8_t *expected, const uint8_t *actual, uint8_t len",,null,"static void assert_bytes(const uint8_t *expected, const uint8_t *actual,
                         uint8_t len)
{
    uint8_t i;

    assert(expected != NULL);
    assert(actual != NULL);
    assert(len > 0);

    for (i = 0; i < len; i++)
    {
        assert(expected[i] == actual[i]);
    }
}"
test,,,null,"static void test()
{
    uint8_t *digest = NULL;

    /* ""abc"" example straight out of RFC-7693 */
    uint8_t abc[3] = {'a', 'b', 'c'};
    uint8_t abc_answer[64] = {
        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,
        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,
        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,
        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,
        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,
        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};

    digest = blake2b(abc, 3, NULL, 0, 64);
    assert_bytes(abc_answer, digest, 64);

    free(digest);

    uint8_t key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t key_answer[64] = {
        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,
        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,
        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,
        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,
        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,
        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};

    digest = blake2b(NULL, 0, key, 64, 64);
    assert_bytes(key_answer, digest, 64);

    free(digest);

    uint8_t zero[1] = {0};
    uint8_t zero_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t zero_answer[64] = {
        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,
        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,
        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,
        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,
        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,
        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};

    digest = blake2b(zero, 1, zero_key, 64, 64);
    assert_bytes(zero_answer, digest, 64);

    free(digest);

    uint8_t filled[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_key[64] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
    uint8_t filled_answer[64] = {
        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,
        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,
        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,
        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,
        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,
        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};

    digest = blake2b(filled, 64, filled_key, 64, 64);
    assert_bytes(filled_answer, digest, 64);

    free(digest);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    test();
    return 0;
}"
adler32,const char* s,,(b << 16) | a,"uint32_t adler32(const char* s)
{
    uint32_t a = 1;
    uint32_t b = 0;
    const uint32_t MODADLER = 65521;

    size_t i = 0;
    while (s[i] != '\0')
    {
        a = (a + s[i]) % MODADLER;
        b = (b + a) % MODADLER;
        i++;
    }
    return (b << 16) | a;
}"
test_adler32,,,null,"void test_adler32()
{
    assert(adler32(""Hello World"") == 403375133);
    assert(adler32(""Hello World!"") == 474547262);
    assert(adler32(""Hello world"") == 413860925);
    assert(adler32(""Hello world!"") == 487130206);
    printf(""Tests passed\n"");
}"
main,,,0,"int main()
{
    test_adler32();
    return 0;
}"
xor8,const char* s,,(((hash ^ 0xff) + 1) & 0xff),"uint8_t xor8(const char* s)
{
    uint8_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = (hash + s[i]) & 0xff;
        i++;
    }
    return (((hash ^ 0xff) + 1) & 0xff);
}"
test_xor8,,,null,"void test_xor8()
{
    assert(xor8(""Hello World"") == 228);
    assert(xor8(""Hello World!"") == 195);
    assert(xor8(""Hello world"") == 196);
    assert(xor8(""Hello world!"") == 163);
    printf(""Tests passed\n"");
}"
main,,,0,"int main()
{
    test_xor8();
    return 0;
}"
crc32,const char* s,,crc ^ 0xffffffff,"uint32_t crc32(const char* s)
{
    uint32_t crc = 0xffffffff;
    size_t i = 0;
    while (s[i] != '\0')
    {
        uint8_t byte = s[i];
        crc = crc ^ byte;
        for (uint8_t j = 8; j > 0; --j)
        {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }

        i++;
    }
    return crc ^ 0xffffffff;
}"
test_crc32,,,null,"void test_crc32()
{
    assert(crc32(""Hello World"") == 1243066710);
    assert(crc32(""Hello World!"") == 472456355);
    assert(crc32(""Hello world"") == 2346098258);
    assert(crc32(""Hello world!"") == 461707669);
    printf(""Tests passed\n"");
}"
main,,,0,"int main()
{
    test_crc32();
    return 0;
}"
djb2,const char* s,,hash,"uint64_t djb2(const char* s)
{
    uint64_t hash = 5381; /* init value */
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = ((hash << 5) + hash) + s[i];
        i++;
    }
    return hash;
}"
test_djb2,,,null,"void test_djb2(void)
{
    assert(djb2(""Hello World"") == 13827776004929097857);
    assert(djb2(""Hello World!"") == 13594750393630990530);
    assert(djb2(""Hello world"") == 13827776004967047329);
    assert(djb2(""Hello world!"") == 13594750394883323106);
    printf(""Tests passed\n"");
}"
main,,,0,"int main()
{
    test_djb2();
    return 0;
}"
sdbm,const char* s,,hash,"uint64_t sdbm(const char* s)
{
    uint64_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = s[i] + (hash << 6) + (hash << 16) - hash;
        i++;
    }
    return hash;
}"
test_sdbm,,,null,"void test_sdbm()
{
    assert(sdbm(""Hello World"") == 12881824461405877380U);
    assert(sdbm(""Hello World!"") == 7903571203300273309);
    assert(sdbm(""Hello world"") == 15154913742888948900U);
    assert(sdbm(""Hello world!"") == 15254999417003201661U);
    printf(""Tests passed\n"");
}"
main,,,0,"int main()
{
    test_sdbm();
    return 0;
}"
encode,"uint8_t *out, int16_t *in, size_t len",,null,"void encode(uint8_t *out, int16_t *in, size_t len)
{
    uint8_t alaw = 0;
    int16_t pcm = 0;
    int32_t sign = 0;
    int32_t abcd = 0;
    int32_t eee = 0;
    int32_t mask = 0;
    for (size_t i = 0; i < len; i++)
    {
        pcm = *in++;
        /* 0-7 kinds of quantization level from the table above */
        eee = 7;
        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */

        /* Get sign bit */
        sign = (pcm & 0x8000) >> 8;

        /* Turn negative pcm to positive */
        /* The absolute value of a negative number may be larger than the size
         * of the corresponding positive number, so here needs `-pcm -1` after
         * taking the opposite number. */
        pcm = sign ? (-pcm - 1) : pcm;

        /* Get eee and abcd bit */
        /* Use mask to locate the first `1` bit and quantization level at the
         * same time */
        while ((pcm & mask) == 0 && eee > 0)
        {
            eee--;
            mask >>= 1;
        }

        /* The location of abcd bits is related with quantization level. Check
         * the table above to determine how many bits to `>>` to get abcd */
        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;

        /* Put the quantization level number at right bit location to get eee
         * bits */
        eee <<= 4;

        /* Splice results */
        alaw = (sign | eee | abcd);

        /* The standard specifies that all resulting even bits (LSB
         * is even) are inverted before the octet is transmitted. This is to
         * provide plenty of 0/1 transitions to facilitate the clock recovery
         * process in the PCM receivers. Thus, a silent A-law encoded PCM
         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the
         * octets. (Reference from wiki above) */
        *out++ = alaw ^ 0xD5;
    }
}"
decode,"int16_t *out, uint8_t *in, size_t len",,null,"void decode(int16_t *out, uint8_t *in, size_t len)
{
    uint8_t alaw = 0;
    int32_t pcm = 0;
    int32_t sign = 0;
    int32_t eee = 0;
    for (size_t i = 0; i < len; i++)
    {
        alaw = *in++;

        /* Re-toggle toggled bits */
        alaw ^= 0xD5;

        /* Get sign bit */
        sign = alaw & 0x80;

        /* Get eee bits */
        eee = (alaw & 0x70) >> 4;

        /* Get abcd bits and add 1/2 quantization step */
        pcm = (alaw & 0x0f) << 4 | 8;

        /* If quantization level > 0, there need `1` bit before abcd bits */
        pcm += eee ? 0x100 : 0x0;

        /* Left shift according quantization level */
        pcm <<= eee > 1 ? (eee - 1) : 0;

        /* Use the right sign */
        *out++ = sign ? -pcm : pcm;
    }
}"
test,"int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len",,null,"static void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)
{
    /* run encode */
    encode(coded, pcm, len);

    /* check encode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(coded[i] == r_coded[i]);
    }

    /* run decode */
    decode(decoded, coded, len);

    /* check decode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(decoded[i] == r_decoded[i]);
    }
}"
main,"int argc, char *argv[]","@brief Self-test implementations
@param pcm signed 16bit pcm array
@param coded unsigned 8bit alaw array
@param decoded signed 16bit pcm array
@param len length of test array
@returns void",0,"int main(int argc, char *argv[])
{
    /* output alaw encoded by encode() */
    uint8_t coded[LEN];

    /* output pcm decoded by decode() from coded[LEN] */
    int16_t decoded[LEN];

    test(pcm, coded, decoded, LEN);  // run self-test implementations

    /* print test pcm inputs */
    printf(""inputs: "");
    for (size_t i = 0; i < LEN; i++)
    {
        printf(""%d "", pcm[i]);
    }
    printf(""\n"");

    /* print encoded alaw */
    printf(""encode: "");
    for (size_t i = 0; i < LEN; i++)
    {
        printf(""%u "", coded[i]);
    }
    printf(""\n"");

    /* print decoded pcm */
    printf(""decode: "");
    for (size_t i = 0; i < LEN; i++)
    {
        printf(""%d "", decoded[i]);
    }
    printf(""\n"");

    /* It can be seen that the encoded alaw is smaller than the input PCM, so
     * the purpose of compression is achieved. And the decoded PCM is almost the
     * same as the original input PCM, which verifies the correctness of the
     * decoding. The reason why it is not exactly the same is that there is
     * precision loss during encode / decode.  */

    return 0;
}"
int_to_string,"uint16_t value, char *dest, int base",,dest,"char *int_to_string(uint16_t value, char *dest, int base)
{
    const char hex_table[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    int len = 0;
    do
    {
        dest[len++] = hex_table[value % base];
        value /= base;
    } while (value != 0);

    /* reverse characters */
    for (int i = 0, limit = len / 2; i < limit; ++i)
    {
        char t = dest[i];
        dest[i] = dest[len - 1 - i];
        dest[len - 1 - i] = t;
    }
    dest[len] = '\0';
    return dest;
}"
test,,,null,"static void test()
{
    const int MAX_SIZE = 100;
    char *str1 = (char *)calloc(sizeof(char), MAX_SIZE);
    char *str2 = (char *)calloc(sizeof(char), MAX_SIZE);

    for (int i = 1; i <= 100; ++i) /* test 100 random numbers */
    {
        /* Generate value from 0 to 100 */
        int value = rand() % 100;

        // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) ==
        //        0);
        snprintf(str1, MAX_SIZE, ""%o"", value);  //* standard C - to octal */
        assert(strcmp(str1, int_to_string(value, str2, 8)) == 0);
        snprintf(str1, MAX_SIZE, ""%d"", value); /* standard C - to decimal */
        assert(strcmp(str1, int_to_string(value, str2, 10)) == 0);
        snprintf(str1, MAX_SIZE, ""%x"", value); /* standard C - to hexadecimal */
        assert(strcmp(str1, int_to_string(value, str2, 16)) == 0);
    }

    free(str1);
    free(str2);
}"
main,,,0,"int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}"
main,,,0,"
int main()
{
#define MAX_STR_LEN 17
    char hex[MAX_STR_LEN];
    long long octal, bin, place;
    int i = 0, rem, val;

    /* Input hexadecimal number from user */
    printf(""Enter any hexadecimal number: "");
    fgets(hex, MAX_STR_LEN, stdin);

    octal = 0ll;
    bin = 0ll;
    place = 0ll;

    /* Hexadecimal to binary conversion */
    for (i = 0; hex[i] != '\0'; i++)
    {
        bin = bin * place;

        switch (hex[i])
        {
        case '0':
            bin += 0;
            break;
        case '1':
            bin += 1;
            break;
        case '2':
            bin += 10;
            break;
        case '3':
            bin += 11;
            break;
        case '4':
            bin += 100;
            break;
        case '5':
            bin += 101;
            break;
        case '6':
            bin += 110;
            break;
        case '7':
            bin += 111;
            break;
        case '8':
            bin += 1000;
            break;
        case '9':
            bin += 1001;
            break;
        case 'a':
        case 'A':
            bin += 1010;
            break;
        case 'b':
        case 'B':
            bin += 1011;
            break;
        case 'c':
        case 'C':
            bin += 1100;
            break;
        case 'd':
        case 'D':
            bin += 1101;
            break;
        case 'e':
        case 'E':
            bin += 1110;
            break;
        case 'f':
        case 'F':
            bin += 1111;
            break;
        default:
            printf(""Invalid hexadecimal input."");
        }

        place = 10000;
    }

    place = 1;

    /* Binary to octal conversion */
    while (bin > 0)
    {
        rem = bin % 1000;

        switch (rem)
        {
        case 0:
            val = 0;
            break;
        case 1:
            val = 1;
            break;
        case 10:
            val = 2;
            break;
        case 11:
            val = 3;
            break;
        case 100:
            val = 4;
            break;
        case 101:
            val = 5;
            break;
        case 110:
            val = 6;
            break;
        case 111:
            val = 7;
            break;
        }

        octal = (val * place) + octal;
        bin /= 1000;

        place *= 10;
    }

    printf(""Hexadecimal number = %s\n"", hex);
    printf(""Octal number = %lld"", octal);

    return 0;
}"
convert_to_decimal,uint64_t number,,decimal_number,"int convert_to_decimal(uint64_t number) {
    int decimal_number = 0, i = 0;

    while (number > 0) {
        decimal_number += (number % 10) * pow(2, i);
        number = number / 10;
        i++;
    }

    return decimal_number;
}"
tests,,,null,"static void tests() {
    assert(convert_to_decimal(111) == 7);
    assert(convert_to_decimal(101) == 5);
    assert(convert_to_decimal(1010) == 10);
    assert(convert_to_decimal(1101) == 13);
    assert(convert_to_decimal(100001) == 33);
    assert(convert_to_decimal(10101001) == 169);
    assert(convert_to_decimal(111010) == 58);
    assert(convert_to_decimal(100000000) == 256);
    assert(convert_to_decimal(10000000000) == 1024);
    assert(convert_to_decimal(101110111) == 375);

    printf(""All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
    tests();  // run self-test implementations
    return 0;
}"
decimal2Hexadecimal,long num,,null,"void decimal2Hexadecimal(long num)
{
    long decimalnum = num;
    long quotient, remainder;
    int i, j = 0;
    char hexadecimalnum[100];

    quotient = decimalnum;

    while (quotient != 0)
    {
        remainder = quotient % 16;
        if (remainder < 10)
            hexadecimalnum[j++] = 48 + remainder;

        else
            hexadecimalnum[j++] = 55 + remainder;

        quotient = quotient / 16;
    }

    // print the hexadecimal number

    for (i = j; i >= 0; i--)
    {
        printf(""%c"", hexadecimalnum[i]);
    }

    printf(""\n"");
}"
main,,,0,"
int main(void)
{
    int base, i, j;
    char number[100];
    unsigned long decimal = 0;

    printf(""Enter the base: "");
    scanf(""%d"", &base);
    printf(""Enter the number: "");
    scanf(""%s"", &number[0]);

    for (i = 0; number[i] != '\0'; i++)
    {
        if (isdigit(number[i]))
            number[i] -= '0';
        else if (isupper(number[i]))
            number[i] -= 'A' - 10;
        else if (islower(number[i]))
            number[i] -= 'a' - 10;
        else
            number[i] = base + 1;

        if (number[i] >= base)
        {
            printf(""invalid number\n"");
            return 0;
        }
    }

    for (j = 0; j < i; j++)
    {
        decimal *= base;
        decimal += number[j];
    }

    printf(""%lu\n"", decimal);
}"
converted_len,"uint64_t nb, short base",,"(converted_len(nb/base, base) + 1) | 1","uint64_t converted_len(uint64_t nb, short base) {
	/* Counting the number of characters translated to the base*/
	if (nb > base - 1) {
		return (converted_len(nb/base, base) + 1);
	}
	return 1;
}"
convertion,"uint64_t nb, const char* alphabet, short base, char* converted","@brief Calculate the final length of the converted number
@param nb to convert
@param base calculated from alphabet
@return Converted nb string length",null,"void convertion(uint64_t nb, const char* alphabet, short base, char* converted) {
	/* Recursive convertion */
	*(converted) = *(alphabet + nb%base);
	if (nb > base - 1) {
		convertion(nb/base, alphabet, base, --converted);
	}
}"
decimal_to_anybase,"uint64_t nb, const char* alphabet",,NULL | converted,"char* decimal_to_anybase(uint64_t nb, const char* alphabet) {
	char* converted;

	/* Verify that alphabet is valid */
	if (isbad_alphabet(alphabet)) {
		return NULL;
	}
	/* Convertion */
	uint64_t base = strlen(alphabet);
	uint64_t final_len = converted_len(nb, base);
	converted = malloc(sizeof(char) * (final_len + 1));
	converted[final_len] = 0;
	convertion(nb, alphabet, base, converted + final_len - 1);
	return converted;
}"
test,,,null,"static void test()
{
	char* ret = NULL;
	char* reference = NULL;

	/* min dec*/
	reference = ""0"";
	ret = decimal_to_anybase(0, ""0123456789"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* max dec*/
	reference = ""18446744073709551615"";
	ret = decimal_to_anybase(18446744073709551615, ""0123456789"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* negative dec*/
	reference = ""18446744073709551615"";
	ret = decimal_to_anybase(-1, ""0123456789"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}

	/* bin */
	reference = ""101010"";
	ret = decimal_to_anybase(42, ""01"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* octal */
	reference = ""52"";
	ret = decimal_to_anybase(42, ""01234567"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* hexa */
	reference = ""2A"";
	ret = decimal_to_anybase(42, ""0123456789ABCDEF"");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	printf(""[+] All tests have successfully passed!\n"");
}"
main,,,0,"int main()
{
	test(); // run self-test implementations
	return 0;
}"
main,,,0,"int main()
{
#define MAX_HEX_STR_LEN 17 /* FFFF_FFFF_FFFF_FFFF */
    char hex[MAX_HEX_STR_LEN];

    /* Input hexadecimal number from user */
    printf(""Enter any hexadecimal number: "");
    fgets(hex, MAX_HEX_STR_LEN, stdin);

    const char *octal = hex_to_oct(hex);

    printf(""Hexadecimal number = %s\n"", hex);
    printf(""Octal number = %s\n"", octal);

    return 0;
}"
octalToBinary,int octalnum,,binarynum,"long octalToBinary(int octalnum)
{
    int decimalnum = 0, i = 0;
    long binarynum = 0;

    /* This loop converts octal number ""octalnum"" to the
     * decimal number ""decimalnum""
     */
    while (octalnum != 0)
    {
        decimalnum = decimalnum + (octalnum % 10) * pow(8, i);
        i++;
        octalnum = octalnum / 10;
    }

    // i is re-initialized
    i = 1;

    /* This loop converts the decimal number ""decimalnum"" to the binary
     * number ""binarynum""
     */
    while (decimalnum != 0)
    {
        binarynum = binarynum + (long)(decimalnum % 2) * i;
        decimalnum = decimalnum / 2;
        i = i * 10;
    }

    // Returning the binary number that we got from octal number
    return binarynum;
}"
main,,,0,"int main()
{
    int octalnum;

    printf(""Enter an octal number: "");
    scanf(""%d"", &octalnum);

    // Calling the function octaltoBinary
    printf(""Equivalent binary number is: %ld"", octalToBinary(octalnum));
    return 0;
}"
main,,,1 | 0,"
int main()
{
    // input of the user
    int inputNumber;

    // for the remainder
    int re;

    // contains the bits 0/1
    int bits[MAXBITS];

    // for the loops
    int j;
    int i = 0;

    printf(""\t\tConverter decimal --> binary\n\n"");

    // reads a decimal number from the user.
    printf(""\nenter a positive integer number: "");
    scanf(""%d"", &inputNumber);

    // make sure the input number is a positive integer.
    if (inputNumber < 0)
    {
        printf(""only positive integers >= 0\n"");
        return 1;
    }

    // actual processing
    while (inputNumber > 0)
    {
        // computes the remainder by modulo 2
        re = inputNumber % 2;

        // computes the quotient of division by 2
        inputNumber = inputNumber / 2;

        bits[i] = re;
        i++;
    }

    printf(""\n the number in binary is: "");

    // iterates backwards over all bits
    for (j = i - 1; j >= 0; j--)
    {
        printf(""%d"", bits[j]);
    }

    // for the case the input number is 0
    if (i == 0)
    {
        printf(""0"");
    }

    return 0;
}"
decimal2Octal,long decimalnum,,null,"void decimal2Octal(long decimalnum)
{
    long remainder, quotient;

    int octalNumber[100], i = 1, j;
    quotient = decimalnum;

    while (quotient != 0)
    {
        octalNumber[i++] = quotient % 8;

        quotient = quotient / 8;
    }

    for (j = i - 1; j > 0; j--) printf(""%d"", octalNumber[j]);

    printf(""\n"");
}"
convertValue,"int num, int i",,"num * pow(8, i)","
int convertValue(int num, int i) { return num * pow(8, i); }"
main,,,0,"
int main()
{
    printf(""Enter octal value: "");

    int octal_value;

    scanf(""%d"", &octal_value);

    long long result = toDecimal(octal_value);

    printf(""%d in decimal is %lld\n"", octal_value, result);

    return 0;
}"
push,char opd,,null,"void push(char opd) {
	if(st.top == 9)	{		// overflow condition
		printf(""Stack overflow..."");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}"
pop,,,item,"char pop() {
	char item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf(""Stack underflow..."");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}"
isEmpty,,,1 | 0,"uint16_t isEmpty() {
	if(st.top == -1) {
		return 1;
	}
	return 0;
}"
Top,,,st.stack[st.top],"char Top() {
	return st.stack[st.top];
}"
priority,char opr,,0 | 1 | -1,"int16_t priority(char opr) {
	if(opr == '+' || opr == '-') {
		return 0;
	}
	else if(opr == '/' || opr == '*' || opr == '%') {
		return 1;
	}
	else {
		return -1;
	}
}"
convert,char inf[],,post,"char *convert(char inf[]) {
	static char post[25];				///< to store the postfix expression
	int i;								///< loop iterator
	int j = 0;							///< keeps track of end of postfix string
	for(i = 0; i < strlen(inf); i++) {
		if(isalnum(inf[i]))	{			// if scanned element is an alphabet or number
			post[j] = inf[i];			// append in postfix expression
			j++;
		}
		else if(inf[i] == '(') {		// if scanned element is opening parentheses
			push(inf[i]);				// push on stack.
		}
		else if(inf[i] == ')') {		// if scanned element is closing parentheses,
			while(Top() != '(') {		// pop elements from stack and append in postfix expression
				post[j] = pop();		// until opening parentheses becomes top.
				j++;
			}
			pop();						// pop opening parentheses
		}
		else {							// if scanned element is an operator
			while( (!isEmpty()) && (priority(inf[i]) <= priority(Top())) ) {	// pop and append until stack becomes
				post[j] = pop();												// empty or priority of top operator
				j++;															// becomes smaller than scanned operator
			}																	// '(' has priority -1
			push(inf[i]);				// push the scanned operator
		}
	}
	while(!isEmpty()) {					// pop and append residual operators from stack
		post[j] = pop();
		j++;
	}
	post[j] = '\0';						// end postfix string with null character
	return post;
}"
test,,,null,"static void test() {
    /* check sample test case
	   input- ""(A/(B-C)*D+E)""
	   expected output- ""ABC-/D*E+""
	 */
	assert(strcmp(convert(""(A/(B-C)*D+E)""), ""ABC-/D*E+"") == 0); 			/// this ensures that the algorithm works as expected
	/* input- ""7-(2*3+5)*(8-4/2)""
	   expected output- ""723*5+842/-*-""
	 */
	assert(strcmp(convert(""7-(2*3+5)*(8-4/2)""), ""723*5+842/-*-"") == 0); 			/// this ensures that the algorithm works as expected
	printf(""All tests have successfully passed!\n"");
}"
main,,"@brief Self-test implementations
@returns void",0,"int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	char inf[25];			///< to store input infix expression
	printf(""Enter infix: "");
	scanf(""%s"", inf);
	printf(""Postfix: %s"", convert(inf));
	return 0;
}"
decimal_to_binary,unsigned int number,,number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2),"int decimal_to_binary(unsigned int number)
{
    return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2);
}"
test,,,null,"void test()
{
    const int sets[][2] = {
        {0, 0}, {1, 1}, {2, 10}, {3, 11}, {4, 100}, {6, 110}, {7, 111},
        /* add more data sets to test */
    };

    for (int i = 0, size = sizeof(sets) / sizeof(sets[0]); i < size; ++i)
    {
        assert(decimal_to_binary(sets[i][0]) == sets[i][1]);
    }
}"
main,,,0,"int main()
{
    test();
    return 0;
}"
three_digits,int n,,d,"
int three_digits(int n)
{
    int r, d = 0, p = 1;

    for (int i = 0; i < 3; i++)
    {
        r = n % 10;
        d += r * p;
        p *= 10;
        n /= 10;
    }
    return d;
}"
main,,,0,"
int main(void)
{
    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;

    printf(""Enter the binary no: "");
    scanf(""%d"", &binary_num);

    while (binary_num > 0)
    {
        if (binary_num >
            111)  // Checking if binary number is greater than three digits
            td = three_digits(binary_num);

        else
            td = binary_num;

        binary_num /= 1000;

        d = 0, base = 1;

        // Converting the last three digits to decimal
        while (td > 0)
        {
            remainder = td % 10;
            td /= 10;
            d += (base * remainder);
            base *= 2;
        }

        res += d * ord;  // Calculating the octal value
        ord *= 10;
    }

    printf(""\nOctal equivalent is: %d"", res);
    return 0;
}"
decimal_to_octal,int decimal,,decimal | 0 | ((decimal_to_octal(decimal / 8) * 10) + decimal % 8),"
int decimal_to_octal(int decimal)
{
    if ((decimal < 8) && (decimal > 0))
    {
        return decimal;
    }
    else if (decimal == 0)
    {
        return 0;
    }
    else
    {
        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);
    }
}"
main,,,0,"
int main()
{
    int octalNumber, decimalNumber;
    printf(""\nEnter your decimal number : "");
    scanf(""%d"", &decimalNumber);
    octalNumber = decimal_to_octal(decimalNumber);
    printf(""\nThe octal of %d is : %d"", decimalNumber, octalNumber);
    return 0;
}"
test,,,null,"static void test() {
    // 1st test
    double input = 0.0;
    double expected = 32.0;

    double output = celcius_to_fahrenheit(input);

    // 1st test
    printf(""TEST 1\n"");
    printf(""Input: %f\n"", input);
    printf(""Expected Output: %f\n"", expected);
    printf(""Output: %f\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");

    // 2nd test
    input = 100.0;
    expected = 212.0;

    output = celcius_to_fahrenheit(input);

    printf(""TEST 2\n"");
    printf(""Input: %f\n"", input);
    printf(""Expected Output: %f\n"", expected);
    printf(""Output: %f\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");

    // 3rd test
    input = 22.5;
    expected = 72.5;

    output = celcius_to_fahrenheit(input);

    printf(""TEST 3\n"");
    printf(""Input: %f\n"", input);
    printf(""Expected Output: %f\n"", expected);
    printf(""Output: %f\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");
}"
main,,,0,"int main() {
    test();  // run self-test implementations
    return 0;
}"
symbol,char symbol,,value,"int symbol(char symbol) {
    int value = 0;
    switch(symbol) {
        case 'I':
            value = 1;
            break;
        case 'V':
            value = 5;
            break;
        case 'X':
            value = 10;
            break;
        case 'L':
            value = 50;
            break;
        case 'C':
            value = 100;
            break;
        case 'D':
            value = 500;
            break;
        case 'M':
            value = 1000;
            break;
    }
    return value;    
}"
roman_to_decimal,char input[],,result,"int roman_to_decimal(char input[]) {
    int result = 0; // result in decimal

    for(int i = 0; i < strlen(input); i++) {
        if(strlen(input) > i + 1) {
            if(symbol(input[i]) >= symbol(input[i + 1])) {
                result += symbol(input[i]); // add value to sum
            } else {
                result += symbol(input[i + 1]) - symbol(input[i]); // if the current symbol is smaller than the next (ex. IV), subtract it from the next symbol
                i++; // skip over an extra symbol 
            }
        } else {
            result += symbol(input[i]); // add value to sum
        }
    }
    return result;
}"
test,,,null,"static void test() {
    // 1st test
    char input[] = ""MCMIV"";
    int expected = 1904;
    
    int output = roman_to_decimal(input);

    printf(""TEST 1\n"");
    printf(""Input: %s\n"", input);
    printf(""Expected Output: %d\n"", expected);
    printf(""Output: %d\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");

    // 2nd test
    char input2[] = ""MMMDCCXXIV"";
    expected = 3724;
    
    output = roman_to_decimal(input2);

    printf(""TEST 2\n"");
    printf(""Input: %s\n"", input2);
    printf(""Expected Output: %d\n"", expected);
    printf(""Output: %d\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");

    // 3rd test
    char input3[] = ""III"";
    expected = 3;
    
    output = roman_to_decimal(input3);

    printf(""TEST 3\n"");
    printf(""Input: %s\n"", input3);
    printf(""Expected Output: %d\n"", expected);
    printf(""Output: %d\n"", output);
    assert(output == expected);
    printf(""== TEST PASSED ==\n\n"");
}"
main,,,0,"int main() {
    test();  // run self-test implementations
    return 0;
}"
c_atoi,const char *str,,(-1) | (0) | (value),"int c_atoi(const char *str)
{
    int i;
    int sign;
    long value;
    long prev;

    i = 0;
    sign = 1;
    value = 0;

    /* skipping the spaces */
    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\0')
        i++;

    /* store the sign if it is negative sign */
    if (str[i] == '-')
	{
        sign = -1;
	i++;
	}
    else if (str[i] == '+')
	{
        sign = 1;
	i++;
	}

    /* converting char by char to a numeric value */
    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\0')
    {
        prev = value;
        value = value * 10 + sign * (str[i] - '0');

        /* managing the overflow */
        if (sign == 1 && prev > value)
            return (-1);
        else if (sign == -1 && prev < value)
            return (0);
        i++;
    }
    return (value);
}"
test_c_atoi,,,null,"void test_c_atoi()
{
    printf(""<<<< TEST FUNCTION >>>>\n"");
    assert(c_atoi(""123"") == atoi(""123""));
    assert(c_atoi(""-123"") == atoi(""-123""));
    assert(c_atoi("""") == atoi(""""));
    assert(c_atoi(""-h23"") == atoi(""-h23""));
    assert(c_atoi(""         23"") == atoi(""         23""));
    assert(c_atoi(""999999999"") == atoi(""999999999""));
    printf(""<<<< TEST DONE >>>>\n"");
}"
main,"int argc, char **argv",,(0) | (1),"int main(int argc, char **argv)
{
    test_c_atoi();

    if (argc == 2)
    {
        printf(""Your number + 5 is %d\n"", c_atoi(argv[1]) + 5);
        return (0);
    }
    printf(""wrong number of parmeters\n"");
    return (1);
}"
octalToDecimal,long octalValue,,decimalValue,"long octalToDecimal(long octalValue){
    long decimalValue = 0;
    int i = 0;
    while (octalValue) {
        // Extracts right-most digit, multiplies it with 8^i, and increment i by 1
        decimalValue += (long)(octalValue % 10) * pow(8, i++);
        // Shift right in base 10
        octalValue /= 10;
    }
    return decimalValue;
}"
octalToHexadecimal,long octalValue,,hexadecimalValue,"char *octalToHexadecimal(long octalValue){
    char *hexadecimalValue = malloc(256 * sizeof(char));
    sprintf(hexadecimalValue, ""%lX"", octalToDecimal(octalValue));
    return hexadecimalValue;
}"
test,,,null,"static void test() {
    /* test that hexadecimal value of octal number 213 is 8B */
    assert(strcmp(octalToHexadecimal(213), ""8B"") == 0);

    /* test that hexadecimal value of octal number 174 is 7C */
    assert(strcmp(octalToHexadecimal(174), ""7C"") == 0);
}"
main,,"@brief Test function
@returns void","0 and exit
    return 0","int main()
{
    // execute the tests
    test();

    // get the value of octal number as input
    int octalValue;
    printf(""Enter an octal number: "");
    scanf(""%d"", &octalValue);

    // call the function octalToHexadecimal and print the hexadecimal value
    char *hexadecimalValue = octalToHexadecimal(octalValue);
    printf(""Equivalent hexadecimal number is: %s"", hexadecimalValue);

    // free the memory allocated dynamically in function octalToHexadecimal
    free(hexadecimalValue);

    // return 0 and exit
    return 0;
}"
main,,,0,"int main()
{
    char infix[20], postfix[20];  // initialize empty infix and postfix array

    printf(""Enter infix expression: "");  // example : A+B-C*D/E$F
    scanf(""%s"", infix);                  // get values for infix array

    convert(infix, postfix);
    printf(""Postfix expression is %s"", postfix);  // output : AB+CD*EF$/-

    return 0;
}"
push,"struct Stack *p, char x",,null,"void push(struct Stack *p, char x)
{
    if (p->tos == 9)  // check if stack has reached its max limit
    {
        printf(""Stack Overflow!"");
        return;
    }

    p->tos += 1;         // increment tos
    p->arr[p->tos] = x;  // assign char x to index of stack pointed by tos
}"
pop,struct Stack *p,,'\0' | x,"char pop(struct Stack *p)
{
    char x;

    if (p->tos == -1)
    {
        printf(""Stack Underflow!"");
        return '\0';
    }

    x = p->arr[p->tos];  // assign the value of stack at index tos to x
    p->tos -= 1;         // decrement tos

    return x;
}"
isOprnd,char ch,,"1 | for true result
    }
    else
    {
        return 0","int isOprnd(char ch)
{
    if ((ch >= 65 && ch <= 90) ||
        (ch >= 97 && ch <= 122) ||  // check if ch is an operator or
        (ch >= 48 && ch <= 57))     // operand using ASCII values
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}"
isEmpty,struct Stack s,,"1 | for true result
    }
    else
    {
        return 0","int isEmpty(struct Stack s)
{
    if (s.tos == -1)  // check if stack is empty
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}"
convert,"char infix[], char postfix[]",,null,"void convert(char infix[], char postfix[])
{
    struct Stack s;  // initialze object reference of stack
    s.tos = -1;      // initalize the tos

    int i, j = 0, pr;
    char ch, temp;

    for (i = 0; infix[i] != '\0'; i++)
    {
        ch = infix[i];

        if (isOprnd(ch) == 1)  // check if char is operand or operator
        {
            postfix[j] = ch;  // assign ch to postfix array with index j
            j++;              // incement j
        }
        else
        {
            if (ch == '(')
            {
                push(&s, ch);
            }
            else
            {
                if (ch == ')')
                {
                    while ((temp = pop(&s)) != '(')
                    {
                        postfix[j] = temp;
                        j++;
                    }
                }
                else
                {
                    while (isEmpty(s) == 0)  // check if stack is empty
                    {
                        pr = getPrecedence (ch,
                                   s.arr[s.tos]);  // check operator precedence

                        if (pr == 1)
                        {
                            break;  // if ch has a greater precedence than
                                    // s.arr[s.top]
                        }

                        postfix[j] = pop(&s);
                        j++;
                    }

                    push(&s, ch);  // push ch to stack
                }
            }
        }
    }

    while (isEmpty(s) == 0)  // check if stack is empty
    {
        postfix[j] = pop(&s);
        j++;
    }

    postfix[j] = '\0';
}"
getPrecedence,"char op1, char op2",,0 | 1,"int getPrecedence (char op1, char op2)
{
    if (op2 == '$')
    {
        return 0;
    }
    else if (op1 == '$')
    {
        return 1;
    }
    else if (op2 == '*' || op2 == '/' || op2 == '%')
    {
        return 0;
    }
    else if (op1 == '*' || op1 == '/' || op1 == '%')
    {
        return 1;
    }
    else if (op2 == '+' || op2 == '-')
    {
        return 0;
    }
    else
    {
        return 1;
    }
}"
main,,,0,"
int main()
{
    long int binary, hexa = 0, i = 1, remainder;

    printf(""Enter the binary number: "");
    scanf(""%ld"", &binary);
    while (binary != 0)
    {
        remainder = binary % 10;
        hexa = hexa + remainder * i;
        i = i * 2;
        binary = binary / 10;
    }
    printf(""The equivalent hexadecimal value: %lX"", hexa);
    return 0;
}"
vector_dot,"double *a, double *b, int L",,mag,"double vector_dot(double *a, double *b, int L)
{
    double mag = 0.f;
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp parallel for reduction(+ : mag)
#endif
    for (i = 0; i < L; i++) mag += a[i] * b[i];

    return mag;
}"
vector_mag,"double *vector, int L",,sqrt(dot),"double vector_mag(double *vector, int L)
{
    double dot = vector_dot(vector, vector, L);
    return sqrt(dot);
}"
vector_proj,"double *a, double *b, double *out, int L",,NULL | out,"double *vector_proj(double *a, double *b, double *out, int L)
{
    const double num = vector_dot(a, b, L);
    const double deno = vector_dot(b, b, L);
    if (deno == 0) /*! check for division by zero */
        return NULL;

    const double scalar = num / deno;
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
    for (i = 0; i < L; i++) out[i] = scalar * b[i];

    return out;
}"
vector_sub,"double *a, /**< minuend */ double *b, /**< subtrahend */ double *out, /**< resultant vector */ int L /**< length of vectors */",,out,"double *vector_sub(double *a,   /**< minuend */
                   double *b,   /**< subtrahend */
                   double *out, /**< resultant vector */
                   int L        /**< length of vectors */
)
{
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
    for (i = 0; i < L; i++) out[i] = a[i] - b[i];

    return out;
}"
qr_decompose,"double **A, /**< input matrix to decompose */ double **Q, /**< output decomposed matrix */ double **R, /**< output decomposed matrix */ int M, /**< number of rows of matrix A */ int N /**< number of columns of matrix A */",,null,"void qr_decompose(double **A, /**< input matrix to decompose */
                  double **Q, /**< output decomposed matrix */
                  double **R, /**< output decomposed matrix */
                  int M,      /**< number of rows of matrix A */
                  int N       /**< number of columns of matrix A */
)
{
    double *col_vector = (double *)malloc(M * sizeof(double));
    double *col_vector2 = (double *)malloc(M * sizeof(double));
    double *tmp_vector = (double *)malloc(M * sizeof(double));
    for (int i = 0; i < N;
         i++) /* for each column => R is a square matrix of NxN */
    {
        int j;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < i; j++) /* second dimension of column */
            R[i][j] = 0.;       /* make R upper triangular */

            /* get corresponding Q vector */
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < M; j++)
        {
            tmp_vector[j] = A[j][i]; /* accumulator for uk */
            col_vector[j] = A[j][i];
        }
        for (j = 0; j < i; j++)
        {
            for (int k = 0; k < M; k++) col_vector2[k] = Q[k][j];
            vector_proj(col_vector, col_vector2, col_vector2, M);
            vector_sub(tmp_vector, col_vector2, tmp_vector, M);
        }
        double mag = vector_mag(tmp_vector, M);

#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < M; j++) Q[j][i] = tmp_vector[j] / mag;

        /* compute upper triangular values of R */
        for (int kk = 0; kk < M; kk++) col_vector[kk] = Q[kk][i];
        for (int k = i; k < N; k++)
        {
            for (int kk = 0; kk < M; kk++) col_vector2[kk] = A[kk][k];
            R[i][k] = vector_dot(col_vector, col_vector2, M);
        }
    }

    free(col_vector);
    free(col_vector2);
    free(tmp_vector);
}"
child_entry,,,0,"static int child_entry(void)
{
    longjmp(jenv, 1);
    return 0;
}"
fork,,,"0 | as a child */
    }

    /* check whether the entry points are initilized and get them if necessary
     */
    if (!ZwCreateProcess && !haveLoadedFunctionsForFork())
    {
        return -1 | (int)cid.UniqueProcess","int fork(void)
{
    HANDLE hProcess = 0, hThread = 0;
    OBJECT_ATTRIBUTES oa = {sizeof(oa)};
    MEMORY_BASIC_INFORMATION mbi;
    CLIENT_ID cid;
    USER_STACK stack;
    PNT_TIB tib;
    THREAD_BASIC_INFORMATION tbi;

    CONTEXT context = {CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS |
                       CONTEXT_FLOATING_POINT};

    if (setjmp(jenv) != 0)
    {
        return 0; /* return as a child */
    }

    /* check whether the entry points are initilized and get them if necessary
     */
    if (!ZwCreateProcess && !haveLoadedFunctionsForFork())
    {
        return -1;
    }

    /* create forked process */
    ZwCreateProcess(&hProcess, PROCESS_ALL_ACCESS, &oa, NtCurrentProcess(),
                    TRUE, 0, 0, 0);

    /* set the Eip for the child process to our child function */
    ZwGetContextThread(NtCurrentThread(), &context);

    /* In x64 the Eip and Esp are not present, their x64 counterparts are Rip
    and Rsp respectively.
    */
#if _WIN64
    context.Rip = (ULONG)child_entry;
#else
    context.Eip = (ULONG)child_entry;
#endif

#if _WIN64
    ZwQueryVirtualMemory(NtCurrentProcess(), (PVOID)context.Rsp,
                         MemoryBasicInformation, &mbi, sizeof mbi, 0);
#else
    ZwQueryVirtualMemory(NtCurrentProcess(), (PVOID)context.Esp,
                         MemoryBasicInformation, &mbi, sizeof mbi, 0);
#endif

    stack.FixedStackBase = 0;
    stack.FixedStackLimit = 0;
    stack.ExpandableStackBase = (PCHAR)mbi.BaseAddress + mbi.RegionSize;
    stack.ExpandableStackLimit = mbi.BaseAddress;
    stack.ExpandableStackBottom = mbi.AllocationBase;

    /* create thread using the modified context and stack */
    ZwCreateThread(&hThread, THREAD_ALL_ACCESS, &oa, hProcess, &cid, &context,
                   &stack, TRUE);

    /* copy exception table */
    ZwQueryInformationThread(NtCurrentThread(), ThreadMemoryPriority, &tbi,
                             sizeof tbi, 0);
    tib = (PNT_TIB)tbi.TebBaseAddress;
    ZwQueryInformationThread(hThread, ThreadMemoryPriority, &tbi, sizeof tbi,
                             0);
    ZwWriteVirtualMemory(hProcess, tbi.TebBaseAddress, &tib->ExceptionList,
                         sizeof tib->ExceptionList, 0);

    /* start (resume really) the child */
    ZwResumeThread(hThread, 0);

    /* clean up */
    ZwClose(hThread);
    ZwClose(hProcess);

    /* exit with child's pid */
    return (int)cid.UniqueProcess;
}

#endif /* __FORK_H__ */
/*--------------------------------------------------------------------------*/"
power_of_ten,int a,,n,"int power_of_ten(int a)
{
	int n = 1; ///< This number will be returned as ten to power of a
	for (int i = 1; i <= a; ++i)
		n *= 10 ;
	return n;
}"
is_number,char *c,,(*c >= '0' && *c <= '9') ? 1 : 0,"int is_number(char *c)
{
	return (*c >= '0' && *c <= '9') ? 1 : 0;
}"
get_ch,"char *p, Buffer *buffer",,buffer->buffr_char | *p++,"char get_ch(char *p, Buffer *buffer)
{
	if (buffer->buf_size) {
		buffer->buf_size = 0; ///< Since character is used, this sets `buffer->buf_size` to zero
		return buffer->buffr_char; // Returns character inside buffer->buffr_char
	}
	return *p++;
}"
unget_ch,"char *c, Buffer *buffer",,null,"void unget_ch(char *c, Buffer *buffer)
{
	buffer->buffr_char = *c;	// Character initializes inside buffer->buffr_char
	buffer->buf_size = 1; // Sets bufsize to one as new character is stored in buffr_char
}"
get_number_of_digits,int n,,digits,"int get_number_of_digits(int n)
{
	int digits = 0; // Stores encountered number of digits
	while (n > 0) {
		++digits; // Since number still contains a digit, so increment digit variable
		n /= 10; // Removes last digit from number
	}
	return digits;
}"
put_char,char s,,null,"void put_char(char s)
{
	/* buf used for storing character to be printed in an array (+1 for '\0')*/
	char *buf = (char *) malloc(sizeof(char) + 1); 
	*buf = s;
	*(buf + 1) = '\0';
	write(1, buf, 1);
	free(buf);
}"
reverse_str,char *p,"@brief Prints one character on screen
@param s character to be printed on the screen",null,"void reverse_str(char *p)
{
	char *l = p; // Points to first character of p
	char *h = p; // Will be used to point to last character of p
	char temp; // Temporarily stores a character, Used in swapping

	while (*h != '\0') 
		++h;
	--h; // Now h point to last valid character of string 

	/* Swap character which lower and higher are pointing until lower < higher. At that point string will be reversed.*/
	while (l < h) {
		temp = *l;
		*l = *h;
		*h = temp;
		++l; // Increment lower to next character
		--h; // Decrement higher to previous character from current character
	}
}"
print_int_value,"int n, int width, int precision",,null,"void print_int_value(int n, int width, int precision)
{
	char *p = (char *) malloc(INT_MAX_LENGTH * sizeof(char) + 1); /* +1 for '\0' */
	char *s = p; // Temporary pointer
	int size = 0; //!< Used to store number of digits in number

	while (n > 0) {
		*s++ = n % 10 + '0'; // Converts last digit of number to character and store it in p
		++size; // Increment size variable as one more digit is occurred
		n /= 10; // Removes the last digit from the number n as we have successfully stored it in p
	}
	*s = '\0';

	s = p; // Again point back s to starting of p

	reverse_str(p);

	/*!
	 * The next two conditions check weather it is required to 
	 * add blanks before printing the number (ie: width)and is it specified how many
	 * zeros to be printed before the number is printed (ie: precision)
	*/
	if (width > 0 && size < width)
		for (int i = 0; i < (width - precision); ++i) 
			put_char(' ');

	if (precision > 0 && precision > size)
		for (int i = 0; i < (precision - size); ++i)
			put_char('0');

	/* Prints the number.*/
	while (*s != '\0')
		put_char(*s++);

	free(p);
}"
print_double_value,"double dval, int width, int precision",,null,"void print_double_value(double dval, int width, int precision)
{
	int ndigits = get_number_of_digits((int) dval); // Store number of digits before decimal in dval
	int reqd_blanks = width - (precision + 1) - ndigits; // Blanks to be printed before printing dval, just to cover the width
	
	print_int_value((int) dval, reqd_blanks, 0); // Prints the part before decimal

	put_char('.'); // Print decimal

	/*Deletes digits before decimal and makes them zero. For example:
		if dval = 1923.79022, them this will make dval = 0.79022
	*/
	dval = dval - (int) dval;

	dval *= power_of_ten(precision); // Brings precision number of digits after decimal to before decimal
	
	print_int_value((int) dval, 0, precision); // Prints the remaining number
}"
print_string,"char *p, int width, int precision",,null,"void print_string(char *p, int width, int precision)
{
	int size = 0; // Stores number of character in string
	char *s = p; // Temporary pointer

	/* Calculates size of string p*/
	while (*s != '\0') { 
		++size;
		++s;
	}

	s = p; // Point s to starting of p

	/* Checks how many characters to be printed.
		if precision is defined then size variable is changed to precision so that only precision
		number of characters were printed.
	*/
	if (precision != 0 && precision < size)
		size = precision;

	/* Prints blanks to cover the width if required*/
	for (int i = 0; i < (width - size); ++i)
		put_char(' ');

	/* Print the string.*/
	for (int i = 0; i < size; ++i)
		put_char(*s++);

}"
get_width_and_precision,"char *p, Buffer *buffer, int *width, int *precision",,p,"char *get_width_and_precision(char *p, Buffer *buffer, int *width, int *precision)
{
	/* Skip % if p is pointing to it.*/
	if (*p == '%')
		++p;
	
	/* Calculates the width specified. */
	while (*p != '.' && is_number(p)) 
		*width = *width * 10 + (*p++ - '0');

	/* Calculates the precision specified.*/
	if (*p == '.' /* Since a precision is always specified after a '.'. */) { 
		while (is_number(++p))
			*precision = *precision * 10 + (*p - '0'); 
		unget_ch(p, buffer); // The non number will be stored in `buffer->buffr`
	}
	return p;
}"
min_printf,"char *fmt, ...",,null,"void min_printf(char *fmt, ...)
{
	va_list ap; // Points to each unnamed arg in turn
	char *p, *sval; // p will be used to point to fmt and sval will store string value
	char cval; // Stores character value
	int ival; // For integer values
	double dval; // For double or float values
	va_start(ap, fmt); // Makes ap points to first unnames argument

	/* Initializing the buffer for storing character. */
	Buffer *buffer = (Buffer *) malloc(sizeof(Buffer));
	buffer->buf_size = 0; // Initially set buffer size to zero as no character is inserted

	for (p = fmt; *p != '\0'; ++p) {
		
		/* If p != '%' then the character is printed to screen. */
		if (*p != '%') {
			put_char(*p);
			continue;
		}
		
		int width = 0; // Stores width specified
		int precision = 0; // Stores precision specified

		/* Updates values of width, precision and p. */
		p = get_width_and_precision(p, buffer, &width, &precision); 
		
		/* Checks format of next argument.*/
		switch (get_ch(p, buffer)) {
			case 'd': // Integer
				ival = va_arg(ap, int);
				print_int_value(ival, width, precision);
				break;
			case 'c': // Character
				cval = va_arg(ap, int);
				put_char(cval);
				break;
			case 'f': // Float or Double
				dval = va_arg(ap, double);

				// If precision is not specified then default value is applied
				if (precision == 0)
					precision = PRECISION_FOR_FLOAT;
				print_double_value(dval, width, precision);
				break;
			case 's': // String pointer
				sval = va_arg(ap, char *);
				print_string(sval, width, precision);
				break;
			default:
				put_char(*p);
				break;
		}
	}
	va_end(ap);
}"
